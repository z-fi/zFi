
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ethPM</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect fill='%23000' width='100' height='100' rx='12'/><text x='50' y='55' font-family='system-ui,sans-serif' font-size='16' font-weight='700' fill='%23627EEA' text-anchor='middle'>eth</text><text x='50' y='72' font-family='system-ui,sans-serif' font-size='14' font-weight='700' fill='%2300FF00' text-anchor='middle'>PM</text></svg>" type="image/svg+xml">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/6.15.0/ethers.umd.min.js" integrity="sha512-UXYETj+vXKSURF1UlgVRLzWRS9ZiQTv3lcL4rbeLyqTXCPNZC6PTLF/Ik3uxm2Zo+E109cUpJPZfLxJsCgKSng==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdn.jsdelivr.net/npm/@walletconnect/ethereum-provider@2.10.0/dist/index.umd.js" integrity="sha384-ACTo60vL1/AfeYkCCXRvB1G0ugjHF0/SHU9YN7e4/KH/mitAIYpLcw5PKXW/+ekM" crossorigin="anonymous"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    button, input, select { font: inherit; }
    :root { --bg: #fff; --fg: #000; }
    [data-theme="dark"] { --bg: #000; --fg: #fff; }

    body {
      font: bold 16px Helvetica, Arial, sans-serif;
      background: var(--bg);
      color: var(--fg);
      min-height: 100vh;
      padding: 20px;
      transition: background 0.2s, color 0.2s;
      overflow-x: hidden;
    }

    .corner {
      position: fixed;
      font-size: 14px;
      text-decoration: underline;
      text-underline-offset: 3px;
      cursor: pointer;
      background: none;
      border: none;
      color: var(--fg);
      z-index: 100;
    }
    .corner:hover { opacity: 0.5; }
    #wallet { top: 20px; right: 20px; text-decoration-color: #0FF; }
    #theme { bottom: 20px; right: 20px; text-decoration-color: #F0F; }
    #docs { top: 20px; left: 20px; text-decoration-color: #627EEA; }
    #create { top: 44px; left: 20px; text-decoration-color: #0F0; }
    #browse { top: 68px; left: 20px; text-decoration-color: #0FF; }

    .logo {
      position: fixed;
      bottom: 20px;
      left: 20px;
      font-size: clamp(32px, 10vw, 64px);
      letter-spacing: -2px;
      z-index: 10;
    }
    .logo span { text-decoration: underline; text-underline-offset: 4px; cursor: pointer; text-decoration-color: #627EEA; }
    .logo span:hover { opacity: 0.5; }

    @media (max-width: 600px) {
      .logo { font-size: 28px; bottom: 12px; left: 12px; }
      #docs { top: 12px; left: 12px; font-size: 12px; }
      #create { top: 28px; left: 12px; font-size: 12px; }
      #browse { top: 44px; left: 12px; right: auto; font-size: 12px; }
      #theme { bottom: 12px; right: 12px; }
      #wallet { top: 12px; right: 12px; }
    }

    .main { max-width: 500px; margin: 80px auto 100px; }

    h1 {
      font-size: clamp(28px, 7vw, 44px);
      text-align: center;
      line-height: 1.15;
      letter-spacing: -1px;
      margin-bottom: 32px;
    }
    h1 u { text-decoration-thickness: 3px; text-underline-offset: 4px; }

    .meta {
      text-align: center;
      font-size: 12px;
      margin-bottom: 16px;
      opacity: 0.6;
    }
    .meta a { color: inherit; }

    .odds { display: flex; flex-wrap: wrap; min-height: 72px; border: 3px solid var(--fg); position: relative; }
    .odds > .bar { flex-shrink: 0; height: 72px; }
    .odds.loading .bar { animation: pulse 1.2s ease-in-out infinite; }
    @keyframes pulse {
      0%, 100% { opacity: 0.4; }
      50% { opacity: 0.7; }
    }
    .bar {
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: clamp(18px, 5vw, 30px);
      cursor: pointer;
      transition: opacity 0.2s, width 0.3s;
      min-width: 40px;
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
      padding: 0 4px;
      box-sizing: border-box;
    }
    .bar:hover { opacity: 0.7; }
    .bar.dim { opacity: 0.2; pointer-events: none; }
    .y { background: var(--fg); color: #0F0; }
    .n { background: var(--bg); color: #F00; border-left: 3px solid var(--fg); }

    .liq-toggle {
      position: absolute;
      bottom: -28px;
      left: 50%;
      transform: translateX(-50%);
      background: none;
      border: none;
      font-size: 14px;
      cursor: pointer;
      opacity: 0.3;
      transition: opacity 0.2s;
      padding: 4px 8px;
    }
    .liq-toggle:hover { opacity: 0.7; }
    .liq-toggle.active { opacity: 1; }

    .drop {
      flex-basis: 100%;
      border-top: 3px solid #000;
      padding: 16px;
      display: none;
      flex-direction: column;
      gap: 12px;
      z-index: 100;
    }
    .drop.open { display: flex; }
    .drop.yes { background: #0F0; color: #000; }
    .drop.no { background: #F00; color: #fff; }

    .trade-row {
      display: flex;
      gap: 12px;
      align-items: center;
    }

    .input-wrapper {
      flex: 1;
      position: relative;
      display: flex;
      align-items: center;
    }

    .drop input {
      flex: 1;
      min-width: 0;
      border: 3px solid #000;
      padding: 12px;
      padding-right: 50px;
      font-size: clamp(20px, 5vw, 26px);
      background: rgba(255,255,255,0.25);
      outline: none;
    }
    .drop input::placeholder { color: rgba(0,0,0,0.4); }
    .drop.no input { border-color: #fff; background: rgba(0,0,0,0.15); color: #fff; }
    .drop.no input::placeholder { color: rgba(255,255,255,0.5); }

    .max-btn {
      position: absolute;
      right: 6px;
      padding: 2px 6px;
      font-size: 10px;
      font-weight: normal;
      background: transparent;
      border: 1px solid rgba(0,0,0,0.2);
      border-radius: 3px;
      cursor: pointer;
      color: inherit;
      opacity: 0.5;
      text-transform: uppercase;
      letter-spacing: 0.3px;
    }
    .max-btn:hover { opacity: 0.8; background: rgba(0,0,0,0.1); }
    .drop.no .max-btn { border-color: rgba(255,255,255,0.3); }
    .drop.no .max-btn:hover { background: rgba(255,255,255,0.15); }

    .trade-info {
      font-size: 14px;
      letter-spacing: 0.5px;
      text-align: center;
      padding: 10px 12px;
      background: rgba(0,0,0,0.1);
      border-radius: 4px;
    }
    .trade-info b { font-size: 18px; }
    .drop.no .trade-info { background: rgba(255,255,255,0.15); }

    .drop button {
      padding: 12px 20px;
      font-size: clamp(14px, 3.5vw, 18px);
      letter-spacing: 1px;
      cursor: pointer;
      border: none;
      background: #000;
      color: #fff;
      flex-shrink: 0;
      box-sizing: border-box;
      max-width: 100%;
    }
    .drop button:hover { opacity: 0.7; }
    .drop button:disabled { opacity: 0.3; cursor: not-allowed; }
    .drop.no button { background: #fff; color: #000; }

    /* Venue waterfall bar - retro ASCII style */
    .waterfall {
      display: none;
      font-family: monospace;
      text-align: center;
      margin-top: 8px;
    }
    .waterfall.active { display: block; }
    .waterfall-bar {
      font-size: 14px;
      letter-spacing: 1px;
      line-height: 1;
      cursor: default;
    }
    .waterfall-bar .pool { color: #0F0; }
    .waterfall-bar .vault { color: #0FF; }
    .waterfall-bar .amm { color: #F0F; }
    .waterfall-bar .mint { color: #FA0; }
    .waterfall-legend {
      font-size: 10px;
      margin-top: 4px;
      opacity: 0.8;
      display: flex;
      justify-content: center;
      gap: 8px;
      flex-wrap: wrap;
    }
    .waterfall-legend .pool { color: #0F0; }
    .waterfall-legend .vault { color: #0FF; }
    .waterfall-legend .amm { color: #F0F; }
    .waterfall-legend .mint { color: #FA0; }

    /* Liquidity depth bar - retro ASCII style */
    .liq-depth {
      display: none;
      max-width: 400px;
      margin: 12px auto 4px;
      font-family: monospace;
      text-align: center;
    }
    .liq-depth.active { display: block; }
    .liq-depth-bar {
      font-size: 14px;
      letter-spacing: 1px;
      line-height: 1;
      cursor: default;
    }
    .liq-depth-bar .bids { color: #0F0; }
    .liq-depth-bar .vault { color: #0FF; }
    .liq-depth-bar .amm { color: #F0F; }
    .liq-depth-bar .empty { opacity: 0.2; }
    .liq-depth-legend .routing { font-size: 10px; letter-spacing: -1px; cursor: help; }
    .liq-depth-legend .routing .filled { opacity: 1; }
    .liq-depth-legend .routing .empty { opacity: 0.3; }
    .liq-depth-legend .routing .remaining { color: #555; opacity: 0.4; }
    .liq-depth-legend .routing.active { color: #0F0; }
    .liq-depth-legend .routing.active .filled { color: #0F0; }
    .liq-depth-legend .routing.building { color: #FA0; }
    .liq-depth-legend .routing.building .filled { color: #FA0; }
    .liq-depth-legend .routing .need { font-size: 9px; opacity: 0.6; margin-left: 4px; color: #888; }
    .liq-depth-legend {
      display: flex;
      justify-content: center;
      font-size: 10px;
      margin-top: 4px;
      opacity: 0.6;
    }
    .liq-depth-legend span { cursor: help; }
    .liq-depth-legend .bids { color: #0F0; }
    .liq-depth-legend .vault { color: #0FF; }
    .liq-depth-legend .amm { color: #F0F; }
    /* Venue breakdown as tooltip on bar hover */
    .liq-depth { position: relative; cursor: help; }
    .liq-depth-bar:hover + .liq-depth-legend .venue-breakdown,
    .liq-depth-legend .venue-breakdown:hover {
      opacity: 1;
      visibility: visible;
    }
    .liq-depth-legend .venue-breakdown {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      top: -20px;
      display: flex;
      gap: 10px;
      background: var(--bg);
      padding: 2px 8px;
      border: 1px solid rgba(255,255,255,0.2);
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.15s ease;
      white-space: nowrap;
      z-index: 10;
    }
    .liq-depth-legend .total-liq { display: none; }

    /* Toast notifications */
    .toast {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%) translateY(100px);
      background: var(--fg);
      color: var(--bg);
      padding: 12px 20px;
      border-radius: 4px;
      font-size: 14px;
      z-index: 3000;
      opacity: 0;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 12px;
      max-width: 90vw;
    }
    .toast.show { transform: translateX(-50%) translateY(0); opacity: 1; }
    .toast.success { background: #0F0; color: #000; }
    .toast.error { background: #F00; color: #fff; }
    .toast.pending { background: #F50; color: #000; }
    .toast a { color: inherit; font-weight: bold; text-decoration: underline; }
    .toast-close { cursor: pointer; opacity: 0.6; font-size: 18px; }
    .toast-close:hover { opacity: 1; }

    /* Navigation chevrons */
    .nav-chevron {
      position: fixed;
      top: 50%;
      transform: translateY(-50%);
      width: 48px;
      height: 120px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      opacity: 0.5;
      transition: opacity 0.2s;
      font-size: 48px;
      font-weight: bold;
      color: #000;
      user-select: none;
      z-index: 100;
    }
    [data-theme="dark"] .nav-chevron { color: #fff; }
    .nav-chevron:hover { opacity: 0.8; }
    .nav-chevron:active { opacity: 1; }
    .nav-chevron.left { left: 12px; }
    .nav-chevron.right { right: 12px; }
    .nav-chevron.disabled { opacity: 0.1; pointer-events: none; }
    @media (max-width: 600px) {
      .nav-chevron { display: none; }
    }

    /* Mobile navigation - inline below content */
    .mobile-nav {
      display: none;
      justify-content: center;
      align-items: center;
      gap: 20px;
      margin: 32px auto 16px;
      padding: 16px;
    }
    .mobile-nav-btn {
      font-size: 72px;
      font-weight: bold;
      background: none;
      color: var(--fg);
      border: none;
      cursor: pointer;
      padding: 0 8px;
      line-height: 1;
      transition: opacity 0.2s;
    }
    .mobile-nav-btn:hover { opacity: 0.7; }
    .mobile-nav-btn:active { opacity: 0.5; }
    .mobile-nav-label {
      font-size: 14px;
      opacity: 0.6;
      min-width: 50px;
      text-align: center;
    }
    .mobile-nav.hidden { display: none !important; }
    @media (max-width: 600px) {
      .mobile-nav { display: flex; }
    }

    /* Modals */
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.8);
      backdrop-filter: blur(4px);
      z-index: 2000;
      justify-content: center;
      align-items: center;
      overflow-y: auto;
      padding: 20px;
    }
    .modal-overlay.active { display: flex; }
    .modal {
      background: var(--bg);
      border: 3px solid var(--fg);
      padding: 20px;
      width: 100%;
      max-width: 400px;
      max-height: 90vh;
      overflow-y: auto;
    }
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
    }
    .modal-title { font-size: 18px; }
    .modal-close {
      background: none;
      border: none;
      color: var(--fg);
      font-size: 24px;
      cursor: pointer;
      line-height: 1;
    }
    .modal-close:hover { opacity: 0.5; }
    .wallet-option {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px;
      background: var(--bg);
      border: 2px solid var(--fg);
      cursor: pointer;
      margin-bottom: 8px;
      transition: all 0.15s;
    }
    .wallet-option:hover { background: var(--fg); color: var(--bg); }
    .wallet-option-icon { font-size: 1.5rem; }
    .wallet-option-name { font-weight: 600; }
    .wallet-option.disconnect {
      border-color: #F00;
      color: #F00;
      justify-content: center;
    }
    .wallet-option.disconnect:hover {
      background: #F00;
      color: #fff;
    }

    /* Create Market Form */
    .form-group { margin-bottom: 16px; }
    .form-label {
      display: block;
      font-size: 11px;
      margin-bottom: 6px;
      opacity: 0.6;
      letter-spacing: 1px;
      text-transform: uppercase;
    }
    .form-input {
      width: 100%;
      padding: 12px;
      border: 2px solid var(--fg);
      background: var(--bg);
      color: var(--fg);
      font-size: 16px;
      font-family: inherit;
      box-sizing: border-box;
    }
    .form-input:focus { outline: none; border-color: #0F0; }
    .form-input::placeholder { opacity: 0.4; }
    [data-theme="dark"] .form-input::-webkit-calendar-picker-indicator { filter: invert(1); }
    .form-row { display: flex; gap: 12px; }
    .form-row > * { flex: 1; }
    .form-hint { font-size: 11px; margin-top: 4px; opacity: 0.5; }
    .form-hint.success { color: #0F0; opacity: 1; }
    .form-hint.error { color: #F00; opacity: 1; }
    .date-presets {
      display: flex;
      gap: 6px;
      margin-top: 6px;
      flex-wrap: wrap;
    }
    .date-preset {
      padding: 4px 8px;
      font-size: 10px;
      background: transparent;
      border: 1px solid var(--fg);
      color: var(--fg);
      cursor: pointer;
      opacity: 0.5;
      transition: opacity 0.2s;
    }
    .date-preset:hover { opacity: 1; }
    .form-btn {
      width: 100%;
      padding: 14px;
      border: none;
      background: var(--fg);
      color: var(--bg);
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      letter-spacing: 1px;
      margin-top: 8px;
    }
    .form-btn:hover { opacity: 0.8; }
    .form-btn:disabled { opacity: 0.3; cursor: not-allowed; }
    .form-divider {
      text-align: center;
      margin: 20px 0 16px;
      font-size: 11px;
      letter-spacing: 1px;
      opacity: 0.5;
      border-top: 1px solid rgba(128,128,128,0.2);
      padding-top: 16px;
    }
    .form-preview {
      text-align: center;
      padding: 16px;
      background: rgba(128,128,128,0.1);
      border: 2px solid var(--fg);
      margin-bottom: 16px;
      font-size: 14px;
      line-height: 1.4;
    }
    .form-preview b { color: #0F0; }
    .live-price {
      text-align: center;
      padding: 8px;
      margin-bottom: 16px;
      font-size: 12px;
      opacity: 0.7;
    }
    .live-price b { color: #0F0; font-size: 14px; }

    /* Market type tabs */
    .market-type-tabs {
      display: flex;
      gap: 0;
      margin-bottom: 20px;
    }
    .market-type-tab {
      flex: 1;
      padding: 10px 4px;
      border: 2px solid var(--fg);
      border-right: none;
      background: transparent;
      color: var(--fg);
      font-size: 9px;
      font-weight: bold;
      letter-spacing: 0.5px;
      cursor: pointer;
      text-align: center;
      transition: all 0.15s;
    }
    .market-type-tab:last-child { border-right: 2px solid var(--fg); }
    .market-type-tab.active { background: var(--fg); color: var(--bg); }
    .market-type-tab:hover:not(.active) { background: rgba(128,128,128,0.1); }

    .market-form-section { display: none; }
    .market-form-section.active { display: block; }

    .live-info {
      text-align: center;
      padding: 8px;
      border: 1px solid rgba(128,128,128,0.3);
      margin-bottom: 16px;
      font-size: 11px;
      opacity: 0.6;
    }
    .live-info b { font-size: 13px; color: #0F0; }

    /* Positions */
    .positions {
      margin-top: 24px;
      padding: 16px;
      border: 2px solid var(--fg);
      font-size: 14px;
    }
    .positions-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 1px;
      opacity: 0.5;
      margin-bottom: 12px;
    }
    .positions-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 0;
    }
    .positions-row + .positions-row { border-top: 1px solid rgba(128,128,128,0.2); }
    .positions-label { display: flex; align-items: center; gap: 8px; }
    .positions-dot { width: 10px; height: 10px; border-radius: 50%; }
    .positions-dot.yes { background: #0F0; }
    .positions-dot.no { background: #F00; }
    .positions-value { font-variant-numeric: tabular-nums; }
    .positions-empty { opacity: 0.4; font-size: 12px; }

    /* Trade mode toggle */
    .trade-toggle {
      display: flex;
      gap: 0;
      margin-bottom: 12px;
    }
    .trade-toggle button {
      flex: 1;
      padding: 8px;
      border: 2px solid #000;
      background: transparent;
      color: #000;
      font-size: 12px;
      font-weight: bold;
      letter-spacing: 1px;
      cursor: pointer;
      transition: all 0.15s;
    }
    .trade-toggle button:first-child { border-right: none; }
    .trade-toggle button.active { background: #000; color: #fff; }
    .trade-toggle button:hover:not(.active) { opacity: 0.6; }
    .drop.yes .trade-toggle button { border-color: #000; }
    .drop.yes .trade-toggle button.active { background: #000; color: #0F0; }
    .drop.no .trade-toggle button { border-color: #fff; color: #fff; background: rgba(0,0,0,0.25); }
    .drop.no .trade-toggle button.active { background: #fff; color: #F00; }

    /* Sell mode styling */
    .drop.sell-mode .trade-info { font-size: 13px; }

    /* Resolved market */
    .resolved-badge {
      display: inline-block;
      padding: 4px 10px;
      font-size: 11px;
      font-weight: bold;
      letter-spacing: 1px;
      text-transform: uppercase;
      border-radius: 2px;
      margin-left: 8px;
    }
    .resolved-badge.yes { background: #0F0; color: #000; }
    .resolved-badge.no { background: #F00; color: #fff; }

    .claim-section {
      margin-top: 16px;
      padding-top: 16px;
      border-top: 1px solid rgba(128,128,128,0.2);
    }
    .claim-info {
      font-size: 13px;
      margin-bottom: 12px;
      opacity: 0.8;
    }
    .claim-amount {
      font-size: 18px;
      font-weight: bold;
      color: #0F0;
      margin-bottom: 12px;
    }
    .claim-btn {
      width: 100%;
      padding: 12px;
      border: none;
      background: #0F0;
      color: #000;
      font-size: 14px;
      font-weight: bold;
      letter-spacing: 1px;
      cursor: pointer;
    }
    .claim-btn:hover { opacity: 0.8; }
    .claim-btn:disabled { opacity: 0.3; cursor: not-allowed; }
    .claim-btn.claimed {
      background: var(--fg);
      color: var(--bg);
      opacity: 0.5;
    }

    /* Resolved market - dim the bars */
    .odds.resolved .bar { cursor: default; }
    .odds.resolved .bar:hover { opacity: 1; }

    /* LP Modal */
    .lp-summary {
      display: flex;
      justify-content: space-between;
      padding: 12px;
      background: rgba(128,128,128,0.1);
      border: 2px solid var(--fg);
      margin-bottom: 16px;
      font-size: 13px;
    }
    .lp-summary-item { text-align: center; }
    .lp-summary-label { font-size: 10px; opacity: 0.6; text-transform: uppercase; letter-spacing: 0.5px; }
    .lp-summary-value { font-size: 16px; font-weight: bold; margin-top: 4px; }

    .lp-allocation {
      margin-bottom: 20px;
    }
    .lp-alloc-row {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 12px;
    }
    .lp-alloc-label {
      width: 80px;
      font-size: 12px;
      font-weight: bold;
    }
    .lp-alloc-label.yes { color: #0F0; }
    .lp-alloc-label.no { color: #F00; }
    .lp-alloc-label.amm { color: #0FF; }
    .lp-alloc-slider {
      flex: 1;
      -webkit-appearance: none;
      height: 8px;
      background: rgba(128,128,128,0.3);
      border-radius: 4px;
      outline: none;
    }
    .lp-alloc-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 20px;
      height: 20px;
      background: var(--fg);
      border-radius: 50%;
      cursor: pointer;
    }
    .lp-alloc-slider::-moz-range-thumb {
      width: 20px;
      height: 20px;
      background: var(--fg);
      border-radius: 50%;
      cursor: pointer;
      border: none;
    }
    .lp-alloc-pct {
      width: 50px;
      text-align: right;
      font-size: 14px;
      font-weight: bold;
      font-variant-numeric: tabular-nums;
    }
    .lp-alloc-hint {
      font-size: 11px;
      opacity: 0.5;
      margin-top: -8px;
      margin-bottom: 12px;
      padding-left: 92px;
    }

    /* Bid Pool Styles */
    .lp-alloc-label.bid { color: #FFA500; }
    .lp-pos-dot.bid { background: #FFA500; }
    .bid-pool-section {
      margin-top: 16px;
      padding-top: 16px;
      border-top: 1px solid rgba(255,255,255,0.1);
    }
    .bid-pool-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }
    .bid-pool-title {
      font-size: 11px;
      opacity: 0.6;
      letter-spacing: 0.1em;
    }
    .bid-pool-hint {
      font-size: 9px;
      opacity: 0.4;
    }
    .bid-side-toggle {
      display: flex;
      gap: 0;
      margin-bottom: 12px;
    }
    .bid-side-btn {
      flex: 1;
      padding: 10px 0;
      background: #111;
      border: 1px solid #333;
      color: #666;
      font-family: monospace;
      font-size: 11px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.15s;
    }
    .bid-side-btn:first-child { border-radius: 4px 0 0 4px; border-right: none; }
    .bid-side-btn:last-child { border-radius: 0 4px 4px 0; }
    .bid-side-btn.active.yes { background: rgba(0,255,0,0.15); border-color: #0F0; color: #0F0; }
    .bid-side-btn.active.no { background: rgba(255,0,0,0.15); border-color: #F00; color: #F00; }
    .bid-side-btn:not(.active):hover { border-color: #555; color: #888; }
    .bid-inputs {
      display: flex;
      gap: 8px;
      margin-bottom: 12px;
    }
    .bid-input-group {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .bid-input-label {
      font-size: 9px;
      opacity: 0.5;
      text-transform: uppercase;
    }
    .bid-input-group .form-input {
      margin: 0;
      width: 100%;
    }
    .bid-preview {
      background: rgba(255,165,0,0.08);
      border: 1px solid rgba(255,165,0,0.2);
      border-radius: 4px;
      padding: 10px 12px;
      margin-bottom: 12px;
      font-size: 10px;
    }
    .bid-preview-row {
      margin-bottom: 6px;
      line-height: 1.4;
    }
    .bid-preview-row:last-child { margin-bottom: 0; }
    .bid-preview-order { color: #FFA500; }
    .bid-preview-win { color: #0F0; opacity: 0.8; }
    .bid-preview-lose { color: #F66; opacity: 0.8; }
    .bid-preview .shares { color: #FFF; font-weight: bold; }
    .bid-preview .collateral { color: #0FF; }
    .bid-add-btn {
      width: 100%;
      padding: 10px 16px;
      background: linear-gradient(135deg, #FFA500 0%, #FF8C00 100%);
      color: #000;
      border: none;
      font-weight: bold;
      font-size: 11px;
      cursor: pointer;
      border-radius: 4px;
      transition: opacity 0.15s;
    }
    .bid-add-btn:hover { opacity: 0.9; }
    .bid-add-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    /* Order Type Toggle (BUY/SELL) */
    .order-type-toggle {
      display: flex;
      gap: 0;
      margin-bottom: 16px;
    }
    .order-type-btn {
      flex: 1;
      padding: 12px 0;
      background: #111;
      border: 1px solid #333;
      color: #666;
      font-family: monospace;
      font-size: 12px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.15s;
    }
    .order-type-btn:first-child { border-radius: 4px 0 0 4px; border-right: none; }
    .order-type-btn:last-child { border-radius: 0 4px 4px 0; }
    .order-type-btn.active.buy { background: rgba(0,255,0,0.15); border-color: #0F0; color: #0F0; }
    .order-type-btn.active.sell { background: rgba(255,100,100,0.15); border-color: #F66; color: #F66; }
    .order-type-btn:not(.active):hover { border-color: #555; color: #888; }

    /* Balance type toggle (ETH vs Token) */
    .balance-type-toggle {
      display: flex;
      gap: 0;
    }
    .balance-type-btn {
      flex: 1;
      padding: 10px 0;
      background: transparent;
      border: 2px solid var(--fg);
      color: var(--fg);
      font-family: inherit;
      font-size: 12px;
      font-weight: bold;
      cursor: pointer;
      opacity: 0.4;
      transition: all 0.15s;
    }
    .balance-type-btn:first-child { border-right: none; }
    .balance-type-btn.active { opacity: 1; background: var(--fg); color: var(--bg); }
    .balance-type-btn:not(.active):hover { opacity: 0.7; }

    .order-side-label {
      font-size: 10px;
      opacity: 0.6;
      margin-bottom: 8px;
      text-transform: uppercase;
    }

    .lp-preview {
      padding: 12px;
      background: rgba(0,255,255,0.1);
      border: 2px solid #0FF;
      margin-bottom: 16px;
      font-size: 12px;
    }
    .lp-preview-title {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 1px;
      opacity: 0.6;
      margin-bottom: 8px;
    }
    .lp-preview-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 4px;
    }
    .lp-preview-row:last-child { margin-bottom: 0; }

    /* LP Button in positions */
    .lp-btn {
      width: 100%;
      padding: 10px;
      margin-top: 12px;
      border: 2px solid #0FF;
      background: transparent;
      color: #0FF;
      font-size: 12px;
      font-weight: bold;
      letter-spacing: 1px;
      cursor: pointer;
      transition: all 0.15s;
    }
    .lp-btn:hover { background: #0FF; color: #000; }

    /* LP Positions */
    .lp-positions {
      margin-top: 16px;
      padding-top: 16px;
      border-top: 1px solid rgba(128,128,128,0.2);
    }
    .lp-positions-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 1px;
      opacity: 0.5;
      margin-bottom: 12px;
      color: #0FF;
    }
    .lp-pos-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 0;
    }
    .lp-pos-row + .lp-pos-row { border-top: 1px solid rgba(128,128,128,0.1); }
    .lp-pos-label {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
    }
    .lp-pos-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
    }
    .lp-pos-dot.yes { background: #0F0; }
    .lp-pos-dot.no { background: #F00; }
    .lp-pos-dot.amm { background: #0FF; }
    .lp-pos-right {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .lp-pos-value {
      font-size: 12px;
      font-variant-numeric: tabular-nums;
    }
    .lp-withdraw-btn {
      padding: 4px 10px;
      font-size: 10px;
      font-weight: bold;
      letter-spacing: 0.5px;
      border: 1px solid var(--fg);
      background: transparent;
      color: var(--fg);
      cursor: pointer;
      opacity: 0.6;
      transition: all 0.15s;
    }
    .lp-withdraw-btn:hover { opacity: 1; background: var(--fg); color: var(--bg); }
    .lp-withdraw-btn:disabled { opacity: 0.2; cursor: not-allowed; }

    .lp-pos-fees {
      display: inline-block;
      margin-left: 6px;
      padding: 2px 5px;
      font-size: 9px;
      font-weight: bold;
      background: rgba(0,255,0,0.15);
      color: #0F0;
      border-radius: 2px;
    }
    .lp-pos-fees:empty { display: none; }

    .lp-harvest-btn {
      padding: 4px 8px;
      font-size: 9px;
      font-weight: bold;
      letter-spacing: 0.5px;
      border: 1px solid #0F0;
      background: transparent;
      color: #0F0;
      cursor: pointer;
      opacity: 0.8;
      transition: all 0.15s;
    }
    .lp-harvest-btn:hover { opacity: 1; background: #0F0; color: #000; }
    .lp-harvest-btn:disabled { opacity: 0.2; cursor: not-allowed; border-color: var(--fg); color: var(--fg); }

    /* Pool Stats */
    .pool-stats {
      padding: 10px;
      background: rgba(0,255,255,0.05);
      border: 1px solid rgba(0,255,255,0.2);
      border-radius: 4px;
      margin-top: 8px;
    }
    .pool-stats-title {
      font-size: 9px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: #0FF;
      opacity: 0.7;
      margin-bottom: 8px;
    }
    .pool-stats-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
    }
    .pool-stat-item {
      display: flex;
      justify-content: space-between;
      font-size: 11px;
    }
    .pool-stat-label { opacity: 0.6; }
    .pool-stat-val { font-weight: bold; font-variant-numeric: tabular-nums; }
    .pool-stat-val.yes { color: #0F0; }
    .pool-stat-val.no { color: #F00; }
    .pool-stat-val.cyan { color: #0FF; }

    /* Resolve Section */
    .resolve-section {
      margin-top: 24px;
    }
    .resolve-toggle {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px;
      border: 1px solid var(--fg);
      opacity: 0.6;
      cursor: pointer;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .resolve-toggle:hover { opacity: 0.8; }
    .resolve-toggle.expanded { opacity: 1; border-color: #F50; }
    .resolve-toggle-status { font-weight: bold; }
    .resolve-toggle-status.pending { color: #F50; }
    .resolve-toggle-status.ready { color: #0F0; }
    .resolve-toggle-status.resolved { color: #0FF; }
    .resolve-details {
      display: none;
      padding: 16px;
      border: 1px solid var(--fg);
      border-top: none;
      background: rgba(128,128,128,0.05);
    }
    .resolve-details.expanded { display: block; }
    .resolve-details.ready { border-color: #0F0; background: rgba(0,255,0,0.05); }
    .resolve-condition {
      font-size: 13px;
      margin-bottom: 16px;
      line-height: 1.5;
    }
    .resolve-condition-target { opacity: 0.7; font-size: 11px; }
    .resolve-condition-val { font-weight: bold; color: #0FF; }
    .resolve-condition-thresh { font-weight: bold; color: #0F0; }
    .resolve-progress {
      margin-bottom: 16px;
      font-family: monospace;
    }
    .resolve-progress-bar {
      font-size: 14px;
      letter-spacing: 1px;
      margin-bottom: 4px;
      color: var(--fg);
    }
    .resolve-progress-bar .filled { color: #0F0; }
    .resolve-progress-bar .empty { opacity: 0.3; }
    .resolve-progress-bar.met .filled { color: #0F0; }
    .resolve-progress-text {
      display: flex;
      justify-content: space-between;
      font-size: 11px;
      opacity: 0.7;
    }
    .resolve-btn {
      width: 100%;
      padding: 12px;
      border: none;
      background: #F50;
      color: #fff;
      font-size: 14px;
      font-weight: bold;
      letter-spacing: 1px;
      cursor: pointer;
    }
    .resolve-btn:hover { opacity: 0.8; }
    .resolve-btn:disabled { opacity: 0.3; cursor: not-allowed; }
    .resolve-hint {
      font-size: 10px;
      opacity: 0.5;
      margin-top: 8px;
      text-align: center;
    }
    .inspect-toggle {
      display: block;
      width: 100%;
      margin-top: 12px;
      padding: 6px;
      background: none;
      border: none;
      color: inherit;
      font-size: 10px;
      opacity: 0.3;
      cursor: pointer;
      text-align: center;
    }
    .inspect-toggle:hover { opacity: 0.6; }
    .inspect-panel {
      display: none;
      margin-top: 8px;
      padding: 8px;
      background: rgba(0,0,0,0.3);
      border: 1px solid rgba(255,255,255,0.1);
      font-size: 10px;
      font-family: monospace;
    }
    .inspect-panel.expanded { display: block; }
    .inspect-row {
      display: flex;
      justify-content: space-between;
      padding: 4px 0;
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }
    .inspect-row:last-child { border-bottom: none; }
    .inspect-label { opacity: 0.5; }
    .inspect-value {
      word-break: break-all;
      text-align: right;
      max-width: 70%;
      color: #0FF;
    }
    .inspect-value a { color: #0FF; text-decoration: underline; }

    /* Price Chart Section */
    .chart-section {
      margin-top: 24px;
      padding: 16px;
      border: 1px solid rgba(255,255,255,0.1);
      background: rgba(0,0,0,0.2);
    }
    .chart-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }
    .chart-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 1px;
      opacity: 0.6;
    }
    .chart-prices {
      display: flex;
      gap: 16px;
      font-size: 12px;
    }
    .chart-price {
      display: flex;
      align-items: center;
      gap: 4px;
    }
    .chart-price-label { opacity: 0.5; }
    .chart-price-val { font-weight: bold; }
    .chart-price-val.spot { color: #0FF; }
    .chart-price-val.twap { color: #F0F; }
    .chart-container {
      height: 40px;
      border-bottom: 1px solid rgba(255,255,255,0.1);
      padding-bottom: 8px;
    }
    .price-visual {
      display: flex;
      height: 100%;
      border-radius: 4px;
      overflow: hidden;
    }
    .price-bar {
      display: flex;
      align-items: center;
      justify-content: center;
      transition: width 0.3s;
      min-width: 40px;
    }
    .price-bar.yes {
      background: linear-gradient(90deg, #0A0, #0F0);
    }
    .price-bar.no {
      background: linear-gradient(90deg, #F00, #A00);
    }
    .price-label {
      font-size: 11px;
      font-weight: bold;
      text-shadow: 0 1px 2px rgba(0,0,0,0.5);
    }
    .chart-footer {
      display: flex;
      justify-content: space-between;
      font-size: 9px;
      opacity: 0.4;
      margin-top: 4px;
    }
    .chart-link {
      font-size: 10px;
      color: #0FF;
      text-decoration: none;
      opacity: 0.7;
    }
    .chart-link:hover { opacity: 1; }
    .chart-empty {
      height: 80px;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0.3;
      font-size: 11px;
    }
    .chart-price-val.fee {
      color: #fa0;
    }
    .liquidity-breakdown {
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid rgba(255,255,255,0.1);
    }
    .liquidity-row {
      display: flex;
      justify-content: space-between;
      font-size: 11px;
      margin-bottom: 4px;
    }
    .liq-label { opacity: 0.6; }
    .liq-value { font-family: monospace; }
    .orderbook-title {
      font-size: 10px;
      opacity: 0.6;
      margin: 8px 0 4px;
      padding-top: 8px;
      border-top: 1px solid rgba(255,255,255,0.05);
    }
    .orderbook-side { margin-bottom: 4px; }
    .ob-level {
      display: flex;
      justify-content: space-between;
      font-size: 10px;
      padding: 1px 0;
      font-family: monospace;
    }
    .ob-price { opacity: 0.7; }
    .ob-depth.ask { color: #0f0; }
    .ob-depth.bid { color: #0cf; }
    /* Liquidity presets - brutalist */
    .liq-presets {
      display: flex;
      gap: 0;
      margin-bottom: 12px;
    }
    .liq-preset {
      flex: 1;
      padding: 10px 4px;
      background: transparent;
      border: 2px solid var(--fg);
      border-right: none;
      color: inherit;
      font-size: 12px;
      cursor: pointer;
      text-align: center;
    }
    .liq-preset:last-child { border-right: 2px solid var(--fg); }
    .liq-preset:hover { opacity: 0.6; }
    .liq-preset.active { background: var(--fg); color: var(--bg); }
    /* Split summary - minimal */
    .liq-split-bar { display: none; }
    .liq-split-legend {
      display: flex;
      justify-content: center;
      gap: 16px;
      font-size: 10px;
      opacity: 0.5;
      margin: 8px 0 16px;
    }
    .liq-leg-item { display: flex; align-items: center; gap: 4px; }
    .liq-leg-dot { width: 6px; height: 6px; }
    .liq-leg-dot.amm { background: #0f0; }
    .liq-leg-dot.vault { background: #0cf; }
    .liq-leg-dot.bids { background: #fa0; }
    /* Advanced - hidden by default */
    .advanced-toggle {
      font-size: 10px;
      opacity: 0.3;
      cursor: pointer;
      margin: 8px 0;
      text-align: center;
    }
    .advanced-toggle:hover { opacity: 0.6; }
    .advanced-toggle svg { display: none; }
    .advanced-section {
      display: none;
      padding: 12px 0;
      border-top: 1px solid rgba(128,128,128,0.2);
      margin-bottom: 12px;
    }
    .advanced-section.open { display: block; }

    /* Market Browser */
    .market-browser { width: 100%; max-width: 500px; }
    .market-filters { display: flex; gap: 0; margin-bottom: 12px; }
    .market-filter {
      flex: 1;
      padding: 10px 4px;
      background: transparent;
      border: 2px solid var(--fg);
      border-right: none;
      color: inherit;
      font-size: 11px;
      font-weight: bold;
      cursor: pointer;
      text-align: center;
    }
    .market-filter:last-child { border-right: 2px solid var(--fg); }
    .market-filter:hover { opacity: 0.6; }
    .market-filter.active { background: var(--fg); color: var(--bg); }
    .market-status-filters { display: flex; gap: 0; margin-bottom: 12px; }
    .market-status-filter {
      flex: 1;
      padding: 8px 4px;
      background: transparent;
      border: 2px solid var(--fg);
      border-right: none;
      color: inherit;
      font-size: 10px;
      font-weight: bold;
      cursor: pointer;
      text-align: center;
    }
    .market-status-filter:last-child { border-right: 2px solid var(--fg); }
    .market-status-filter:hover { opacity: 0.6; }
    .market-status-filter.active { background: var(--fg); color: var(--bg); }
    .market-search {
      width: 100%;
      padding: 12px;
      border: 2px solid var(--fg);
      background: var(--bg);
      color: var(--fg);
      font-size: 14px;
      margin-bottom: 12px;
    }
    .market-search:focus { outline: none; border-color: #0FF; }
    .market-list { max-height: 400px; overflow-y: auto; }
    .market-item {
      padding: 12px;
      border: 2px solid var(--fg);
      border-top: none;
      cursor: pointer;
    }
    .market-item:first-child { border-top: 2px solid var(--fg); }
    .market-item:hover { opacity: 0.7; }
    .market-item-q { font-size: 14px; font-weight: bold; }
    .market-item-meta { font-size: 11px; opacity: 0.6; margin-top: 4px; }
    .market-item-pct { float: right; font-size: 18px; font-weight: bold; }
    .market-type-dot {
      display: inline-block;
      width: 8px;
      height: 8px;
      margin-right: 6px;
    }
    .market-type-dot.price { background: #627EEA; }
    .market-type-dot.balance { background: #8247E5; }
    .market-type-dot.supply { background: #FA0; }
    .market-empty { padding: 40px; text-align: center; opacity: 0.5; font-size: 14px; }

    /* Market Gallery */
    .market-gallery {
      display: none;
      max-width: 900px;
      margin: 60px auto 100px;
      padding: 0 20px;
    }
    .market-gallery.active { display: block; }
    .gallery-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 24px;
    }
    .gallery-title {
      font-size: 24px;
      font-weight: bold;
      letter-spacing: -1px;
    }
    .gallery-close {
      background: none;
      border: none;
      font-size: 24px;
      cursor: pointer;
      color: var(--fg);
      opacity: 0.5;
    }
    .gallery-close:hover { opacity: 1; }
    .gallery-search {
      width: 100%;
      padding: 14px 16px;
      border: 2px solid var(--fg);
      background: var(--bg);
      color: var(--fg);
      font-size: 16px;
      margin-bottom: 24px;
    }
    .gallery-search:focus { outline: none; border-color: #0FF; }
    .gallery-search::placeholder { opacity: 0.4; }
    .gallery-filters {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
      flex-wrap: wrap;
    }
    .gallery-filter {
      padding: 6px 12px;
      font-size: 12px;
      background: transparent;
      border: 1px solid var(--fg);
      color: var(--fg);
      cursor: pointer;
      opacity: 0.5;
      transition: opacity 0.15s;
    }
    .gallery-filter:hover { opacity: 0.8; }
    .gallery-filter.active { opacity: 1; background: var(--fg); color: var(--bg); }
    .gallery-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      gap: 16px;
    }
    .market-card {
      border: 2px solid var(--fg);
      padding: 16px;
      cursor: pointer;
      transition: opacity 0.15s;
      text-decoration: none;
      color: inherit;
      display: block;
    }
    .market-card:hover { opacity: 0.7; }
    .market-card-q {
      font-size: 15px;
      font-weight: bold;
      line-height: 1.3;
      margin-bottom: 12px;
      min-height: 40px;
    }
    .market-card-odds {
      display: flex;
      height: 32px;
      border: 2px solid var(--fg);
      margin-bottom: 12px;
      font-size: 12px;
      font-weight: bold;
    }
    .market-card-odds .y {
      background: var(--fg);
      color: #0F0;
      display: flex;
      align-items: center;
      justify-content: center;
      min-width: 36px;
    }
    .market-card-odds .n {
      background: var(--bg);
      color: #F00;
      display: flex;
      align-items: center;
      justify-content: center;
      flex: 1;
      border-left: 2px solid var(--fg);
    }
    .market-card-meta {
      display: flex;
      justify-content: space-between;
      font-size: 11px;
      opacity: 0.6;
    }
    .market-card-tvl { font-weight: bold; }
    .market-card.resolved { opacity: 0.8; }
    .market-card-outcome {
      display: inline-block;
      padding: 2px 6px;
      font-size: 10px;
      font-weight: bold;
      border-radius: 2px;
      margin-left: 8px;
    }
    .market-card-outcome.yes { background: #0F0; color: #000; }
    .market-card-outcome.no { background: #F00; color: #fff; }
    .market-card-claim {
      width: 100%;
      margin-top: 8px;
      padding: 8px;
      font-size: 12px;
      font-weight: bold;
      background: #0F0;
      color: #000;
      border: none;
      cursor: pointer;
    }
    .market-card-claim:hover { opacity: 0.8; }
    .market-card-claim:disabled { opacity: 0.4; cursor: not-allowed; }
    .market-card-claim.checking { background: #888; color: #fff; }
    .market-card-claim.claimed { background: #0a0; color: #fff; opacity: 1; }
    .market-card-odds.loading {
      opacity: 0.5;
      animation: pulse 1.5s ease-in-out infinite;
    }
    .market-card-odds.loading .y,
    .market-card-odds.loading .n {
      color: #888;
    }
    @keyframes pulse {
      0%, 100% { opacity: 0.5; }
      50% { opacity: 0.3; }
    }
    @media (max-width: 600px) {
      .market-gallery { margin-top: 50px; padding: 0 12px; }
      .gallery-grid { grid-template-columns: 1fr; }
      .gallery-title { font-size: 20px; }
    }

    /* Raw description viewer */
    .raw-desc-btn {
      cursor: pointer;
      opacity: 0.3;
      font-size: 10px;
      margin-left: 4px;
      transition: opacity 0.15s;
    }
    .raw-desc-btn:hover { opacity: 0.8; }
    .raw-desc-tooltip {
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: var(--fg);
      color: var(--bg);
      padding: 8px 12px;
      font-size: 11px;
      font-family: monospace;
      white-space: nowrap;
      max-width: 90vw;
      overflow-x: auto;
      border: 2px solid var(--fg);
      z-index: 100;
      display: none;
    }
    .meta { position: relative; }

    /* Resolver info line */
    .resolver-info {
      font-size: 11px;
      opacity: 0.5;
      margin-top: 4px;
      text-align: center;
    }
    .resolver-info a {
      color: inherit;
      text-decoration: underline;
      text-decoration-color: #666;
    }
    .resolver-info a:hover { opacity: 0.7; }
    .liq-indicator {
      display: inline-block;
      width: 6px;
      height: 6px;
      border-radius: 50%;
      margin-left: 6px;
      vertical-align: middle;
    }
    .liq-indicator.vault { background: #0F0; }
    .liq-indicator.bid { background: #FFA500; }
    .liq-indicator.amm { background: #0FF; }
    .liq-indicator.none { background: #F00; opacity: 0.5; }

    /* Footer */
    .site-footer {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 11px;
      opacity: 0.4;
      letter-spacing: 0.5px;
      white-space: nowrap;
    }
    .site-footer a {
      color: inherit;
      text-decoration: underline;
    }
    .site-footer a:hover { opacity: 0.7; }
  </style>
</head>
<body>

<a class="corner" id="docs" href="https://docs.ethpm.eth.limo/" target="_blank" rel="noopener">docs</a>
<button class="corner" id="create" onclick="showCreateModal()">+ create</button>
<button class="corner" id="wallet" onclick="toggleWallet()">connect</button>
<button class="corner" id="theme" onclick="toggleTheme()">dark</button>
<button class="corner" id="browse" onclick="showGallery()"># browse</button>

<div class="nav-chevron left" id="navPrev" onclick="prev()" title="Previous market">‹</div>
<div class="nav-chevron right" id="navNext" onclick="next()" title="Next market">›</div>

<div class="main">
  <h1 id="q"></h1>
  <div class="meta" id="meta"></div>
  <div class="resolver-info" id="resolverInfo" style="display:none;"></div>
  <div class="odds">
    <div class="bar y" id="yBar" onclick="vote('Y')"></div>
    <div class="bar n" id="nBar" onclick="vote('N')"></div>
    <div class="drop" id="drop">
      <div class="trade-toggle">
        <button id="buyToggle" class="active" onclick="setTradeMode('buy')">BUY</button>
        <button id="sellToggle" onclick="setTradeMode('sell')">SELL</button>
      </div>
      <div class="trade-row">
        <div class="input-wrapper">
          <input id="amt" inputmode="decimal" placeholder="0.00" oninput="calc()" onkeydown="if(event.key==='Enter')executeTrade()">
          <button class="max-btn" onclick="setMaxTradeAmount()">MAX</button>
        </div>
        <button id="tradeBtn" onclick="executeTrade()">BUY</button>
      </div>
      <div class="trade-info" id="tradeInfo">ETH &rarr; <b id="out">0.00</b> <b id="side">Y</b></div>
      <div class="waterfall" id="waterfall"></div>
    </div>
  </div>
  <div class="liq-depth" id="liqDepth" title="Liquidity sources"></div>
  <div class="positions" id="positions" style="display:none;">
    <div class="positions-title">Your Position</div>
    <div class="positions-row">
      <span class="positions-label"><span class="positions-dot yes"></span> YES</span>
      <span class="positions-value" id="yesBalance">0</span>
    </div>
    <div class="positions-row">
      <span class="positions-label"><span class="positions-dot no"></span> NO</span>
      <span class="positions-value" id="noBalance">0</span>
    </div>
    <div class="claim-section" id="claimSection" style="display:none;">
      <div class="claim-info" id="claimInfo">You have winning shares to claim</div>
      <div class="claim-amount" id="claimAmount">0 ETH</div>
      <button class="claim-btn" id="claimBtn" onclick="claim()">CLAIM</button>
    </div>
    <div class="lp-positions" id="lpPositions" style="display:none;">
      <div class="lp-positions-title">Your LP Positions</div>
      <div class="lp-pos-row" id="yesVaultRow">
        <span class="lp-pos-label"><span class="lp-pos-dot yes"></span> YES Vault</span>
        <span class="lp-pos-right">
          <span class="lp-pos-value"><span id="yesVaultBalance">0</span><span class="lp-pos-fees" id="yesVaultFees"></span></span>
          <button class="lp-harvest-btn" id="yesHarvestBtn" onclick="harvestFees(true)">HARVEST</button>
          <button class="lp-withdraw-btn" id="yesVaultWithdrawBtn" onclick="withdrawVault(true)">WITHDRAW</button>
        </span>
      </div>
      <div class="lp-pos-row" id="noVaultRow">
        <span class="lp-pos-label"><span class="lp-pos-dot no"></span> NO Vault</span>
        <span class="lp-pos-right">
          <span class="lp-pos-value"><span id="noVaultBalance">0</span><span class="lp-pos-fees" id="noVaultFees"></span></span>
          <button class="lp-harvest-btn" id="noHarvestBtn" onclick="harvestFees(false)">HARVEST</button>
          <button class="lp-withdraw-btn" id="noVaultWithdrawBtn" onclick="withdrawVault(false)">WITHDRAW</button>
        </span>
      </div>
      <div class="lp-pos-row" id="ammLpRow">
        <span class="lp-pos-label"><span class="lp-pos-dot amm"></span> AMM LP</span>
        <span class="lp-pos-right">
          <span class="lp-pos-value" id="ammLpBalance">0</span>
          <button class="lp-withdraw-btn" id="ammLpWithdrawBtn" onclick="withdrawAmmLP()">WITHDRAW</button>
        </span>
      </div>
      <div class="lp-pos-row" id="bidPoolRow" style="display:none;">
        <span class="lp-pos-label"><span class="lp-pos-dot bid"></span> Bid Pool</span>
        <span class="lp-pos-right">
          <span class="lp-pos-value" id="bidPoolBalance">--</span>
          <button class="lp-withdraw-btn" id="bidPoolAddBtn" onclick="showLPModal()" title="Add more bids">+ ADD</button>
        </span>
      </div>
      <div class="pool-stats" id="poolStats" style="display:none;">
        <div class="pool-stats-title">AMM Pool Stats</div>
        <div class="pool-stats-grid">
          <div class="pool-stat-item">
            <span class="pool-stat-label">YES Reserve</span>
            <span class="pool-stat-val yes" id="poolYesReserve">0</span>
          </div>
          <div class="pool-stat-item">
            <span class="pool-stat-label">NO Reserve</span>
            <span class="pool-stat-val no" id="poolNoReserve">0</span>
          </div>
          <div class="pool-stat-item">
            <span class="pool-stat-label">Total LP</span>
            <span class="pool-stat-val" id="poolTotalSupply">0</span>
          </div>
          <div class="pool-stat-item">
            <span class="pool-stat-label">Your Share</span>
            <span class="pool-stat-val cyan" id="poolUserShare">0%</span>
          </div>
        </div>
      </div>
    </div>
    <button class="lp-btn" id="lpBtnPos" onclick="showLPModal()" style="display:none;">+ PROVIDE LIQUIDITY</button>
  </div>
  <div class="chart-section" id="chartSection" style="display:none;">
    <div class="chart-header">
      <span class="chart-title">Market Info</span>
      <div class="chart-prices">
        <div class="chart-price">
          <span class="chart-price-label">Spot:</span>
          <span class="chart-price-val spot" id="chartSpot">--</span>
        </div>
        <div class="chart-price" id="chartTwapRow">
          <span class="chart-price-label">TWAP:</span>
          <span class="chart-price-val twap" id="chartTwap">--</span>
        </div>
        <div class="chart-price">
          <span class="chart-price-label">Fee:</span>
          <span class="chart-price-val fee" id="chartFee">--</span>
        </div>
      </div>
    </div>
    <div class="chart-container" id="chartContainer">
      <div class="chart-empty">Loading...</div>
    </div>
    <div class="liquidity-breakdown" id="liquidityBreakdown" style="display:none;">
      <div class="liquidity-row" id="liqVaultRow">
        <span class="liq-label">Vault OTC</span>
        <span class="liq-value" id="liqVault">--</span>
      </div>
      <div class="liquidity-row" id="liqAmmRow">
        <span class="liq-label">AMM Pool</span>
        <span class="liq-value" id="liqAmm">--</span>
      </div>
      <div class="liquidity-row" id="liqBidPoolRow" style="display:none;">
        <span class="liq-label">Bid Pool</span>
        <span class="liq-value"><span id="liqBidPoolAmt">--</span> @ <span id="liqBidPoolPrice">--</span></span>
      </div>
      <div id="orderbookLevels"></div>
    </div>
    <div class="chart-footer">
      <span id="chartOldest">--</span>
      <a href="#" class="chart-link" id="chartLink" target="_blank">View on ZAMM →</a>
      <span id="chartNewest">--</span>
    </div>
  </div>
  <div class="resolve-section" id="resolveSection" style="display:none;">
    <div class="resolve-toggle" id="resolveToggle" onclick="toggleResolveDetails()">
      <span id="resolveToggleLabel">⚙ Resolution</span>
      <span class="resolve-toggle-status pending" id="resolveToggleStatus">PENDING</span>
    </div>
    <div class="resolve-details" id="resolveDetails"></div>
  </div>
  <div class="mobile-nav" id="mobileNav">
    <button class="mobile-nav-btn" onclick="prev()" title="Previous market">‹</button>
    <span class="mobile-nav-label" id="mobileNavLabel">1 / 1</span>
    <button class="mobile-nav-btn" onclick="next()" title="Next market">›</button>
  </div>
</div>

<!-- Market Gallery -->
<div class="market-gallery" id="marketGallery">
  <div class="gallery-header">
    <div class="gallery-title">MARKETS <span onclick="shareGallery()" style="cursor:pointer;font-size:14px;opacity:0.5" title="Copy link">&#128279;</span></div>
    <button class="gallery-close" onclick="closeGallery()">&times;</button>
  </div>
  <input class="gallery-search" id="gallerySearch" type="text" placeholder="search markets..." oninput="onGallerySearch(event)">
  <div class="gallery-filters">
    <button class="gallery-filter active" onclick="setGalleryStatus('open')">Open</button>
    <button class="gallery-filter" onclick="setGalleryStatus('resolved')">Resolved</button>
    <button class="gallery-filter" onclick="setGalleryStatus('all')">All</button>
  </div>
  <div class="gallery-grid" id="galleryGrid"></div>
</div>

<div class="logo"><span id="logo" onclick="showGallery()">eth</span>PM</div>

<!-- Wallet Modal -->
<div class="modal-overlay" id="walletModal" onclick="if(event.target===this)closeWalletModal()">
  <div class="modal">
    <div class="modal-header">
      <div class="modal-title">Connect Wallet</div>
      <button class="modal-close" onclick="closeWalletModal()">&times;</button>
    </div>
    <div class="modal-body" id="walletOptions"></div>
  </div>
</div>

<!-- Create Market Modal -->
<div class="modal-overlay" id="createModal" onclick="if(event.target===this)closeCreateModal()">
  <div class="modal">
    <div class="modal-header">
      <div class="modal-title" id="createModalTitle">Create Market</div>
      <button class="modal-close" onclick="closeCreateModal()">&times;</button>
    </div>

    <!-- Market Type Tabs -->
    <div class="market-type-tabs">
      <button class="market-type-tab active" onclick="switchMarketType('price')" title="ETH price prediction">
        PRICE
      </button>
      <button class="market-type-tab" onclick="switchMarketType('balance')" title="ETH or token balance of an address">
        BALANCE
      </button>
      <button class="market-type-tab" onclick="switchMarketType('totalSupply')" title="ERC20 token total supply">
        SUPPLY
      </button>
    </div>

    <!-- PRICE MARKET FORM -->
    <div class="market-form-section active" id="priceForm">
      <div class="form-preview" id="pricePreview">Will ETH hit <b>$___</b> by <b>___</b>?</div>
      <div class="live-price">Current: ETH <b id="livePrice">...</b> <span style="opacity:0.5;font-size:10px">(ETH-USD only)</span></div>
      <div class="form-group">
        <label class="form-label">Target Price (USD)</label>
        <input class="form-input" id="targetPrice" type="text" inputmode="numeric" placeholder="e.g. 10000" oninput="formatTargetPrice();updatePricePreview()" onblur="formatTargetPrice()">
        <div class="date-presets">
          <button type="button" class="date-preset" onclick="setPricePreset(0)">current</button>
          <button type="button" class="date-preset" onclick="setPricePreset(5)">+5%</button>
          <button type="button" class="date-preset" onclick="setPricePreset(10)">+10%</button>
          <button type="button" class="date-preset" onclick="setPricePreset(100)">+100%</button>
          <button type="button" class="date-preset" onclick="setPricePreset(200)">+200%</button>
        </div>
        <div class="form-hint" id="priceDiffHint"></div>
      </div>
      <div class="form-group">
        <label class="form-label">Resolution Date</label>
        <input class="form-input" id="closeDate" type="datetime-local" oninput="updateLocalTimeHint('closeDate','closeDateHint');updatePricePreview()">
        <div class="date-presets">
          <button type="button" class="date-preset" onclick="setDatePreset('closeDate','day')">EOD</button>
          <button type="button" class="date-preset" onclick="setDatePreset('closeDate','week')">EOW</button>
          <button type="button" class="date-preset" onclick="setDatePreset('closeDate','month')">EOM</button>
          <button type="button" class="date-preset" onclick="setDatePreset('closeDate','year')">EOY</button>
        </div>
        <div class="form-hint" id="closeDateHint"></div>
      </div>
    </div>

    <!-- BALANCE MARKET FORM (combined ETH + Token) -->
    <div class="market-form-section" id="balanceForm">
      <div class="form-preview" id="balancePreview">Will <b>address</b> hold ≥ <b>___</b> ETH by <b>___</b>?</div>

      <!-- Asset Type Toggle -->
      <div class="form-group">
        <label class="form-label">Asset Type</label>
        <div class="balance-type-toggle">
          <button type="button" class="balance-type-btn active" id="balanceTypeEth" onclick="setBalanceAssetType('eth')">ETH</button>
          <button type="button" class="balance-type-btn" id="balanceTypeToken" onclick="setBalanceAssetType('token')">TOKEN</button>
        </div>
      </div>

      <!-- Token Contract (shown only for token) -->
      <div class="form-group" id="balanceTokenGroup" style="display:none">
        <label class="form-label">Token Contract</label>
        <input class="form-input" id="balanceTokenAddress" type="text" placeholder="0x... (ERC20 address)" oninput="loadBalanceTokenInfo()">
        <div class="form-hint" id="balanceTokenInfo"></div>
      </div>

      <div class="form-group">
        <label class="form-label">Wallet Address</label>
        <input class="form-input" id="balanceWalletAddress" type="text" placeholder="vitalik.eth or 0x..." oninput="resolveBalanceENS();updateBalancePreview()">
        <div class="form-hint" id="balanceWalletResolved"></div>
      </div>
      <div class="form-group">
        <label class="form-label">Minimum Balance <span id="currentBalanceHint" style="opacity:0.5;font-weight:normal"></span></label>
        <input class="form-input" id="balanceThreshold" type="number" placeholder="e.g. 100" step="0.01" min="0" oninput="updateBalancePreview()">
        <div class="date-presets">
          <button type="button" class="date-preset" onclick="setBalancePresetNew(0)">current</button>
          <button type="button" class="date-preset" onclick="setBalancePresetNew(5)">+5%</button>
          <button type="button" class="date-preset" onclick="setBalancePresetNew(10)">+10%</button>
          <button type="button" class="date-preset" onclick="setBalancePresetNew(100)">+100%</button>
          <button type="button" class="date-preset" onclick="setBalancePresetNew(200)">+200%</button>
        </div>
      </div>
      <div class="form-group">
        <label class="form-label">Resolution Date</label>
        <input class="form-input" id="balanceCloseDate" type="datetime-local" oninput="updateLocalTimeHint('balanceCloseDate','balanceCloseDateHint');updateBalancePreview()">
        <div class="date-presets">
          <button type="button" class="date-preset" onclick="setDatePreset('balanceCloseDate','day')">EOD</button>
          <button type="button" class="date-preset" onclick="setDatePreset('balanceCloseDate','week')">EOW</button>
          <button type="button" class="date-preset" onclick="setDatePreset('balanceCloseDate','month')">EOM</button>
          <button type="button" class="date-preset" onclick="setDatePreset('balanceCloseDate','year')">EOY</button>
        </div>
        <div class="form-hint" id="balanceCloseDateHint"></div>
      </div>
    </div>

    <!-- TOTAL SUPPLY MARKET FORM -->
    <div class="market-form-section" id="totalSupplyForm">
      <div class="form-preview" id="totalSupplyPreview">Will <b>token</b> supply be <b>___</b> by <b>___</b>?</div>
      <div class="form-group">
        <label class="form-label">Token Contract</label>
        <input class="form-input" id="totalSupplyToken" type="text" placeholder="0x... (ERC20 address)" oninput="loadTotalSupplyTokenInfo()">
        <div class="form-hint" id="totalSupplyTokenInfo"></div>
      </div>
      <div class="form-group">
        <label class="form-label">Condition</label>
        <select class="form-input" id="totalSupplyOp" onchange="updateTotalSupplyPreview()">
          <option value="gte">Greater than or equal (≥)</option>
          <option value="lte">Less than or equal (≤)</option>
          <option value="gt">Greater than (>)</option>
          <option value="lt">Less than (<)</option>
        </select>
      </div>
      <div class="form-group">
        <label class="form-label">Threshold <span id="currentTotalSupplyHint" style="opacity:0.5;font-weight:normal"></span></label>
        <input class="form-input" id="totalSupplyThreshold" type="number" placeholder="e.g. 10000" step="1" min="0" oninput="updateTotalSupplyPreview()">
        <div class="date-presets">
          <button type="button" class="date-preset" onclick="setTotalSupplyPreset(0)">current</button>
          <button type="button" class="date-preset" onclick="setTotalSupplyPreset(10)">+10%</button>
          <button type="button" class="date-preset" onclick="setTotalSupplyPreset(50)">+50%</button>
          <button type="button" class="date-preset" onclick="setTotalSupplyPreset(100)">+100%</button>
          <button type="button" class="date-preset" onclick="setTotalSupplyPreset(-10)">-10%</button>
        </div>
      </div>
      <div class="form-group">
        <label class="form-label">Resolution Date</label>
        <input class="form-input" id="totalSupplyCloseDate" type="datetime-local" oninput="updateLocalTimeHint('totalSupplyCloseDate','totalSupplyCloseDateHint');updateTotalSupplyPreview()">
        <div class="date-presets">
          <button type="button" class="date-preset" onclick="setDatePreset('totalSupplyCloseDate','day')">EOD</button>
          <button type="button" class="date-preset" onclick="setDatePreset('totalSupplyCloseDate','week')">EOW</button>
          <button type="button" class="date-preset" onclick="setDatePreset('totalSupplyCloseDate','month')">EOM</button>
          <button type="button" class="date-preset" onclick="setDatePreset('totalSupplyCloseDate','year')">EOY</button>
        </div>
        <div class="form-hint" id="totalSupplyCloseDateHint"></div>
      </div>
    </div>

    <!-- SEED LIQUIDITY -->
    <div class="form-divider">SEED LIQUIDITY (ETH)</div>

    <div class="liq-presets">
      <button type="button" class="liq-preset active" onclick="setLiqPreset(0.01)">0.01</button>
      <button type="button" class="liq-preset" onclick="setLiqPreset(0.1)">0.1</button>
      <button type="button" class="liq-preset" onclick="setLiqPreset(0.5)">0.5</button>
      <button type="button" class="liq-preset" onclick="setLiqPreset(1)">1.0</button>
    </div>

    <input class="form-input" id="totalLiquidity" type="number" placeholder="0.01" step="0.01" min="0.001" value="0.01" oninput="updateLiqSplit()" style="margin-bottom:8px">

    <div class="liq-split-bar" id="liqSplitBar"></div>
    <div class="liq-split-legend">
      <span id="liqLegAmm">AMM</span>
      <span id="liqLegVault">Vault</span>
      <span id="liqLegBids">Bids</span>
    </div>

    <div class="advanced-toggle" id="advancedToggle" onclick="toggleAdvanced()">+ advanced</div>

    <div class="advanced-section" id="advancedSection">
      <!-- Hidden inputs to hold computed values (used by existing code) -->
      <input type="hidden" id="seedAmount">
      <input type="checkbox" id="enableVault" style="display:none">
      <input type="hidden" id="vaultAmount">
      <input type="hidden" id="vaultYesPct" value="50">
      <input type="hidden" id="vaultNoPct" value="50">
      <input type="checkbox" id="enableBids" style="display:none">
      <input type="hidden" id="bidsAmount">
      <input type="hidden" id="bidSpreadPreset" value="balanced">
      <input type="checkbox" id="enableInitialBuy" style="display:none">
      <input type="hidden" id="initialBuySide" value="yes">
      <input type="hidden" id="initialBuyAmount">

      <!-- Manual AMM override -->
      <div class="form-group">
        <label class="form-label">AMM (ETH)</label>
        <input class="form-input" id="manualAmmAmount" type="number" placeholder="auto" step="0.01" min="0" oninput="onManualSplitChange()">
      </div>

      <!-- Vault config -->
      <div class="form-group">
        <label class="form-label">VAULT (ETH)</label>
        <input class="form-input" id="manualVaultAmount" type="number" placeholder="auto" step="0.01" min="0" oninput="onManualSplitChange()">
      </div>
      <div style="display:flex;gap:8px">
        <div class="form-group" style="flex:1">
          <label class="form-label">YES %</label>
          <input class="form-input" id="manualVaultYesPct" type="number" placeholder="50" step="1" min="0" max="100" value="50">
        </div>
        <div class="form-group" style="flex:1">
          <label class="form-label">NO %</label>
          <input class="form-input" id="manualVaultNoPct" type="number" placeholder="50" step="1" min="0" max="100" value="50">
        </div>
      </div>

      <!-- Orderbook config -->
      <div class="form-group">
        <label class="form-label">BIDS (ETH)</label>
        <input class="form-input" id="manualBidsAmount" type="number" placeholder="auto" step="0.01" min="0" oninput="onManualSplitChange()">
      </div>
      <div class="form-group">
        <label class="form-label">SPREAD</label>
        <select class="form-input" id="manualBidSpread">
          <option value="balanced">25-75%</option>
          <option value="tight">35-65%</option>
          <option value="wide">15-85%</option>
          <option value="yesOnly">YES 20-45%</option>
          <option value="noOnly">NO 55-80%</option>
        </select>
      </div>

      <!-- Initial buy -->
      <div class="form-group">
        <label class="form-label">
          <input type="checkbox" id="manualEnableInitialBuy" style="margin-right:6px">
          SKEW ODDS
        </label>
      </div>
      <div id="initialBuyAdvanced" style="display:none">
        <div style="display:flex;gap:8px">
          <div class="form-group" style="flex:1">
            <label class="form-label">SIDE</label>
            <select class="form-input" id="manualInitialBuySide">
              <option value="yes">YES</option>
              <option value="no">NO</option>
            </select>
          </div>
          <div class="form-group" style="flex:1">
            <label class="form-label">AMOUNT</label>
            <input class="form-input" id="manualInitialBuyAmount" type="number" placeholder="0.01" step="0.001" min="0">
          </div>
        </div>
      </div>
    </div>

    <button class="form-btn" id="createBtn" onclick="createMarket()">CREATE MARKET</button>
  </div>
</div>

<!-- LP Modal -->
<div class="modal-overlay" id="lpModal" onclick="if(event.target===this)closeLPModal()">
  <div class="modal">
    <div class="modal-header">
      <div class="modal-title">Provide Liquidity</div>
      <button class="modal-close" onclick="closeLPModal()">&times;</button>
    </div>
    <div class="lp-summary">
      <div class="lp-summary-item">
        <div class="lp-summary-label">Market</div>
        <div class="lp-summary-value" id="lpMarketName">ETH $10K</div>
      </div>
      <div class="lp-summary-item">
        <div class="lp-summary-label">TVL</div>
        <div class="lp-summary-value" id="lpTvl">0 ETH</div>
      </div>
      <div class="lp-summary-item" id="lpPriceRow" style="display:none">
        <div class="lp-summary-label">Price</div>
        <div class="lp-summary-value" id="lpCollateralPrice">--</div>
      </div>
    </div>
    <div class="form-group">
      <label class="form-label" id="lpAmountLabel">AMOUNT</label>
      <input class="form-input" id="lpAmount" type="number" placeholder="0.1" step="0.01" min="0.001" oninput="updateLPPreview()">
    </div>
    <div class="lp-allocation" id="lpAllocationSection">
      <div id="lpVaultOptions">
        <div class="lp-alloc-row">
          <span class="lp-alloc-label yes">YES Vault</span>
          <input type="range" class="lp-alloc-slider" id="lpYesSlider" min="0" max="100" value="0" oninput="updateLPAllocation('yes')">
          <span class="lp-alloc-pct" id="lpYesPct">0%</span>
        </div>
        <div class="lp-alloc-hint">Earn from YES share sells</div>
        <div class="lp-alloc-row">
          <span class="lp-alloc-label no">NO Vault</span>
          <input type="range" class="lp-alloc-slider" id="lpNoSlider" min="0" max="100" value="0" oninput="updateLPAllocation('no')">
          <span class="lp-alloc-pct" id="lpNoPct">0%</span>
        </div>
        <div class="lp-alloc-hint">Earn from NO share sells</div>
      </div>
      <div class="lp-alloc-row">
        <span class="lp-alloc-label amm">AMM LP</span>
        <input type="range" class="lp-alloc-slider" id="lpAmmSlider" min="0" max="100" value="100" oninput="updateLPAllocation('amm')">
        <span class="lp-alloc-pct" id="lpAmmPct">100%</span>
      </div>
      <div class="lp-alloc-hint">Earn swap fees from both sides</div>
    </div>
    <div class="lp-preview">
      <div class="lp-preview-title">You will receive</div>
      <div id="lpPreviewVaultRows">
        <div class="lp-preview-row">
          <span>YES Vault Shares</span>
          <span id="lpPreviewYes">0</span>
        </div>
        <div class="lp-preview-row">
          <span>NO Vault Shares</span>
          <span id="lpPreviewNo">0</span>
        </div>
      </div>
      <div class="lp-preview-row">
        <span>AMM LP Tokens</span>
        <span id="lpPreviewAmm">0</span>
      </div>
    </div>
    <button class="form-btn" id="lpBtn" onclick="provideLiquidity()">PROVIDE LIQUIDITY</button>
  </div>
</div>

<!-- Orders Modal (Limit Buy/Sell) -->
<div class="modal-overlay" id="ordersModal" onclick="if(event.target===this)closeOrdersModal()">
  <div class="modal">
    <div class="modal-header">
      <div class="modal-title">Limit Orders</div>
      <button class="modal-close" onclick="closeOrdersModal()">&times;</button>
    </div>
    <div class="lp-summary">
      <div class="lp-summary-item">
        <div class="lp-summary-label">Market</div>
        <div class="lp-summary-value" id="ordersMarketName">--</div>
      </div>
      <div class="lp-summary-item">
        <div class="lp-summary-label">Your Shares</div>
        <div class="lp-summary-value" id="ordersSharesBalance"><span style="color:#0F0">0 Y</span> / <span style="color:#F00">0 N</span></div>
      </div>
    </div>

    <!-- Order Type Toggle -->
    <div class="order-type-toggle">
      <button class="order-type-btn buy active" onclick="setOrderType('buy')">BUY</button>
      <button class="order-type-btn sell" onclick="setOrderType('sell')">SELL</button>
    </div>
    <input type="hidden" id="orderType" value="buy">

    <!-- Side Toggle -->
    <div class="order-side-label" id="orderSideLabel">Buy which side?</div>
    <div class="bid-side-toggle">
      <button class="bid-side-btn yes active" id="orderYesBtn" onclick="setOrderSide('yes')">YES</button>
      <button class="bid-side-btn no" id="orderNoBtn" onclick="setOrderSide('no')">NO</button>
    </div>
    <input type="hidden" id="orderSide" value="yes">

    <!-- Inputs -->
    <div class="bid-inputs">
      <div class="bid-input-group">
        <span class="bid-input-label" id="orderPriceLabel">Price %</span>
        <input class="form-input" id="orderPrice" type="number" placeholder="e.g. 40" min="1" max="99" step="1" oninput="updateOrderPreview()">
      </div>
      <div class="bid-input-group">
        <span class="bid-input-label" id="orderAmountLabel">Amount</span>
        <input class="form-input" id="orderAmount" type="number" placeholder="0.1" min="0.001" step="0.001" oninput="updateOrderPreview()">
      </div>
    </div>

    <!-- Preview -->
    <div class="bid-preview" id="orderPreview" style="display:none">
      <div class="bid-preview-row" id="orderPreviewDesc"></div>
      <div class="bid-preview-row bid-preview-win" id="orderPreviewWin"></div>
      <div class="bid-preview-row bid-preview-lose" id="orderPreviewLose"></div>
    </div>

    <button class="bid-add-btn" id="orderBtn" onclick="placeOrder()">PLACE ORDER</button>
  </div>
</div>

<!-- Browser Modal -->
<div class="modal-overlay" id="browserModal" onclick="if(event.target===this)closeBrowserModal()">
  <div class="modal market-browser">
    <div class="modal-header">
      <div class="modal-title">MARKETS</div>
      <button class="modal-close" onclick="closeBrowserModal()">&times;</button>
    </div>
    <div class="market-filters">
      <button class="market-filter active" onclick="setBrowserFilter('all')">ALL</button>
      <button class="market-filter" onclick="setBrowserFilter('price')">PRICE</button>
      <button class="market-filter" onclick="setBrowserFilter('balance')">BALANCE</button>
      <button class="market-filter" onclick="setBrowserFilter('supply')">SUPPLY</button>
    </div>
    <input class="market-search" id="browserSearch" type="text" placeholder="search..." oninput="onBrowserSearch(event)">
    <div class="market-list" id="browserList"></div>
  </div>
</div>

<!-- Toast notification -->
<div class="toast" id="toast"></div>

<!-- Footer -->
<div class="site-footer">built by the <a href="https://zamm.finance/dao" target="_blank" rel="noopener"><svg width="16" height="16" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" style="vertical-align:middle;margin-right:4px;image-rendering:pixelated"><rect width="16" height="16" fill="#0a0a0a"/><rect x="3" y="1" width="1" height="1" fill="#e8e8e0"/><rect x="5" y="2" width="1" height="1" fill="#e8e8e0"/><rect x="10" y="2" width="1" height="1" fill="#e8e8e0"/><rect x="12" y="1" width="1" height="1" fill="#e8e8e0"/><rect x="4" y="4" width="8" height="1" fill="#e8e8e0"/><rect x="3" y="5" width="10" height="1" fill="#e8e8e0"/><rect x="2" y="6" width="12" height="3" fill="#e8e8e0"/><rect x="3" y="9" width="10" height="1" fill="#e8e8e0"/><rect x="4" y="10" width="8" height="1" fill="#e8e8e0"/><rect x="3" y="6" width="3" height="2" fill="#0a0a0a"/><rect x="10" y="6" width="3" height="2" fill="#0a0a0a"/><rect x="5" y="11" width="2" height="1" fill="#e8e8e0"/><rect x="9" y="11" width="2" height="1" fill="#e8e8e0"/><rect x="2" y="12" width="3" height="1" fill="#e8e8e0"/><rect x="7" y="12" width="2" height="1" fill="#e8e8e0"/><rect x="11" y="12" width="3" height="1" fill="#e8e8e0"/><rect x="1" y="13" width="2" height="1" fill="#e8e8e0"/><rect x="13" y="13" width="2" height="1" fill="#e8e8e0"/></svg>zOrg</a> for <a href="https://zamm.finance" target="_blank" rel="noopener">zAMM.finance</a></div>

<script>
// ======================== CONTRACTS ========================
const CONTRACTS = {
  PAMM: '0x000000000044bfe6c2BBFeD8862973E0612f07C0',
  ZAMM: '0x000000000000040470635EB91b7CE4D132D616eD',
  MASTER_ROUTER: '0x000000000088Ec6Ab5CA97A354Ce4C57dBA5B88a',
  PM_ROUTER: '0x000000000055ff709f26efb262fba8b0ae8c35dc', // Legacy router for 30 bps fee tier markets
  RESOLVER: '0x0000000000FF0Dc62d07e220F273fe8cDd324127',
  PM_HOOK_ROUTER: '0x0000000000Ff22a7FFEf88639d95C03183c5093C',
  PM_FEE_HOOK: '0x0000000000116D81CDDC3574e26eEa7b79410E80', // ZAMM pool hook for dynamic fees
  QUOTER: '0x8F4283c327afF696789e23589c8c79306909B2Be',
  BOOTSTRAPPER: '0x51157306D13fdc57a81B4b3574E04ad2e039CC88',
  GASPM: '0x0000000000ee3d4294438093EaA34308f47Bc0b4',
  CHAINLINK_ETH_USD: '0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419',
  UNI_TOKEN: '0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984',
  // Legacy resolver for external markets
  LEGACY_RESOLVER: '0x9a70ca659D5E7eB41bB94a8eE56e254c9ec6b79c',
  LINK_TOKEN: '0x514910771AF9Ca656af840dff83E8264EcF986CA'
};

// Legacy markets (external/hardcoded) - these use PAMM with 30 bps fee
// Note: close time and description will be fetched from chain; these are fallbacks
const LEGACY_MARKETS = [
  {
    marketId: '56383978532102149659860873469210631142629299157140399402201151455176223336684',
    poolId: '17419310335243632136948884904978804426555201669398494770540125786404925384443',
    collateral: '0x0000000000000000000000000000000000000000', // ETH
    close: 1775001600, // April 1, 2026 UTC (fallback)
  }
];

// ERC20 ABI for token interactions (approve, allowance, permit)
const ERC20_ABI = [
  'function approve(address spender, uint256 amount) returns (bool)',
  'function allowance(address owner, address spender) view returns (uint256)',
  'function balanceOf(address account) view returns (uint256)',
  'function decimals() view returns (uint8)',
  'function symbol() view returns (string)',
  // EIP-2612 permit support
  'function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)',
  'function nonces(address owner) view returns (uint256)',
  'function DOMAIN_SEPARATOR() view returns (bytes32)'
];

// Known permit tokens (mainnet) - skip detection for these
const PERMIT_TOKENS = {
  // UNI - DAI-style permit (no version in domain)
  '0x1f9840a85d5af5bf1d1762f925bdaddc4201f984': { hasPermit: true, hasVersion: false },
  // DAI - DAI-style permit (no version in domain)
  '0x6b175474e89094c44da98b954eedeac495271d0f': { hasPermit: true, hasVersion: false },
  // USDC - EIP-2612 style (has version)
  '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48': { hasPermit: true, hasVersion: true },
};

// Check if token supports EIP-2612 permit
async function supportsPermit(tokenAddress, rpc) {
  // Check whitelist first (case-insensitive)
  const knownToken = PERMIT_TOKENS[tokenAddress.toLowerCase()];
  if (knownToken?.hasPermit) {
    return true;
  }

  // Try dynamic detection for unknown tokens
  try {
    const token = new ethers.Contract(tokenAddress, ERC20_ABI, rpc);
    // Check DOMAIN_SEPARATOR exists (required for EIP-2612)
    await token.DOMAIN_SEPARATOR();
    // Check nonces exists - use connected address if available
    const testAddr = connectedAddress || '0x0000000000000000000000000000000000000001';
    await token.nonces(testAddr);
    return true;
  } catch (e) {
    return false;
  }
}

// Get EIP-712 permit signature for ERC20 token
async function getPermitSignature(tokenAddress, spender, amount, deadline) {
  if (!signer || !connectedAddress) throw new Error('Wallet not connected');

  const rpc = provider || await getRpc();
  const token = new ethers.Contract(tokenAddress, [
    ...ERC20_ABI,
    'function name() view returns (string)',
    'function version() view returns (string)'
  ], rpc);

  // Check whitelist for version info first
  const knownToken = PERMIT_TOKENS[tokenAddress.toLowerCase()];
  let version = null;

  if (knownToken) {
    // Use cached version info from whitelist
    version = knownToken.hasVersion ? '1' : null; // Most EIP-2612 tokens use version "1"
  } else {
    // Try to detect version for unknown tokens
    try {
      version = await token.version();
    } catch {
      // Token doesn't have version() - use DAI/UNI style (no version in domain)
    }
  }

  const [nonce, name, chainId] = await Promise.all([
    token.nonces(connectedAddress),
    token.name().catch(() => token.symbol().catch(() => 'TOKEN')),
    rpc.getNetwork().then(n => n.chainId)
  ]);

  // EIP-712 domain - omit version for DAI/UNI style tokens
  const domain = {
    name: name,
    chainId: chainId,
    verifyingContract: tokenAddress
  };
  if (version) {
    domain.version = version;
  }

  // EIP-2612 permit types
  const types = {
    Permit: [
      { name: 'owner', type: 'address' },
      { name: 'spender', type: 'address' },
      { name: 'value', type: 'uint256' },
      { name: 'nonce', type: 'uint256' },
      { name: 'deadline', type: 'uint256' }
    ]
  };

  const message = {
    owner: connectedAddress,
    spender: spender,
    value: amount,
    nonce: nonce,
    deadline: deadline
  };

  const signature = await signer.signTypedData(domain, types, message);
  const { v, r, s } = ethers.Signature.from(signature);

  return { v, r, s, deadline, amount };
}

// ======================== EIP-5792 WALLET BATCHING ========================
// Check if wallet supports EIP-5792 atomic batching (e.g., Coinbase Smart Wallet, Safe)
let walletCapabilities = null;

async function getWalletCapabilities() {
  if (walletCapabilities !== null) return walletCapabilities;
  if (!provider || !connectedAddress) return null;

  try {
    const network = await provider.getNetwork();
    const chainId = `0x${network.chainId.toString(16)}`;
    const caps = await provider.send('wallet_getCapabilities', [connectedAddress]);
    walletCapabilities = caps?.[chainId] || null;
    return walletCapabilities;
  } catch (e) {
    walletCapabilities = {}; // Cache empty result
    return null;
  }
}

// Check if wallet supports atomic batching
async function supportsAtomicBatch() {
  const caps = await getWalletCapabilities();
  if (!caps) return false;
  const atomic = caps.atomic?.status || caps.atomicBatch?.supported;
  return atomic === 'supported' || atomic === 'ready' || atomic === true;
}

// Execute multiple calls atomically via EIP-5792 wallet_sendCalls
// Returns { success: true, hash } or { success: false, error }
async function sendBatchedCalls(calls, options = {}) {
  if (!provider || !connectedAddress) throw new Error('Wallet not connected');

  const network = await provider.getNetwork();
  const chainId = `0x${network.chainId.toString(16)}`;

  const sendCallsParams = {
    version: '1.0',
    chainId,
    from: connectedAddress,
    atomicRequired: options.atomicRequired ?? true,
    calls: calls.map(c => ({
      to: c.to,
      data: c.data || '0x',
      value: c.value ? `0x${BigInt(c.value).toString(16)}` : '0x0'
    })),
    capabilities: options.capabilities || {}
  };

  const result = await provider.send('wallet_sendCalls', [sendCallsParams]);

  // Poll for transaction hash
  const bundleId = result.id || result;
  let status;
  for (let i = 0; i < 60; i++) { // Poll for up to 60 seconds
    await new Promise(r => setTimeout(r, 1000));
    try {
      status = await provider.send('wallet_getCallsStatus', [bundleId]);
      if (status.status === 'CONFIRMED' || status.receipts?.length > 0) {
        return { success: true, hash: status.receipts?.[0]?.transactionHash || bundleId };
      }
      if (status.status === 'FAILED') {
        return { success: false, error: 'Transaction failed' };
      }
    } catch (e) {
      // Some wallets return the hash directly, not a bundle ID
      if (typeof bundleId === 'string' && bundleId.startsWith('0x') && bundleId.length === 66) {
        return { success: true, hash: bundleId };
      }
    }
  }

  return { success: false, error: 'Timeout waiting for transaction' };
}

// Reset capabilities cache on wallet change
function resetWalletCapabilities() {
  walletCapabilities = null;
}

// Ensure ERC20 approval for spender. Returns permit data if permit is used, null otherwise.
// For permit tokens: returns { permitData, usePermit: true }
// For non-permit tokens: does approve tx if needed, returns { usePermit: false }
async function ensureERC20Approval(tokenAddress, spender, amount) {
  if (!signer || !connectedAddress) throw new Error('Wallet not connected');

  const rpc = provider || await getRpc();
  const token = new ethers.Contract(tokenAddress, ERC20_ABI, rpc);
  const tokenSigner = new ethers.Contract(tokenAddress, ERC20_ABI, signer);

  // Check current allowance
  const currentAllowance = await token.allowance(connectedAddress, spender);
  if (currentAllowance >= amount) {
    return { usePermit: false }; // Already approved
  }

  // Check if token supports permit
  const hasPermit = await supportsPermit(tokenAddress, rpc);

  if (hasPermit) {
    // Use permit with max amount to avoid re-permitting for future trades
    const deadline = Math.floor(Date.now() / 1000) + 3600; // 1 hour
    showToast('Please sign the permit message to authorize token spending...', 'pending');
    const permitData = await getPermitSignature(tokenAddress, spender, ethers.MaxUint256, deadline);
    return { usePermit: true, permitData, tokenAddress };
  } else {
    // No permit support - do traditional max approve
    showToast(`Please approve ${getCollateralSymbol(tokenAddress)} token spending...`, 'pending');
    const approveTx = await tokenSigner.approve(spender, ethers.MaxUint256);
    showTxPending(approveTx.hash);
    await approveTx.wait();
    showToast('Token approved. Proceeding...', 'success');
    return { usePermit: false };
  }
}

// Check if collateral is ETH (address(0) or ZeroAddress)
function isETHCollateral(collateralAddress) {
  return !collateralAddress || collateralAddress === ethers.ZeroAddress;
}

// Get collateral symbol from address
function getCollateralSymbol(collateralAddress) {
  if (!collateralAddress || collateralAddress === ethers.ZeroAddress) return 'ETH';
  if (collateralAddress.toLowerCase() === CONTRACTS.UNI_TOKEN.toLowerCase()) return 'UNI';
  return 'ERC20'; // Generic fallback for unknown tokens
}

// Get collateral display with logo SVG (for HTML contexts)
function getCollateralDisplay(collateralAddress) {
  const sym = getCollateralSymbol(collateralAddress);
  if (sym === 'ETH') {
    return TOKEN_LOGOS['eth'] + 'ETH';
  }
  if (sym === 'UNI') {
    return getTokenLogo(collateralAddress) + 'UNI';
  }
  return sym;
}

const PAMM_ABI = [
  'function markets(uint256) view returns (address resolver, bool resolved, bool outcome, bool canClose, uint64 close, address collateral, uint256 collateralLocked)',
  'function totalSupplyId(uint256) view returns (uint256)',
  'function tradingOpen(uint256) view returns (bool)',
  'function getMarketId(string description, address resolver, address collateral) pure returns (uint256)',
  'function getNoId(uint256 marketId) pure returns (uint256)',
  'function balanceOf(address, uint256) view returns (uint256)',
  'function setOperator(address, bool)',
  'function isOperator(address, address) view returns (bool)',
  'function claim(uint256 marketId, address to) returns (uint256 shares, uint256 payout)',
  'function claimMany(uint256[] marketIds, address to) returns (uint256 totalPayout)',
  'function removeLiquidityToCollateral(uint256 marketId, uint256 feeOrHook, uint256 liquidity, uint256 amount0Min, uint256 amount1Min, uint256 minCollateralOut, address to, uint256 deadline) returns (uint256 collateralOut, uint256 leftoverYes, uint256 leftoverNo)',
  'function getMarkets(uint256 start, uint256 count) view returns (uint256[] marketIds, address[] resolvers, address[] collaterals, uint8[] states, uint64[] closes, uint256[] collateralAmounts, uint256[] yesSupplies, uint256[] noSupplies, string[] descs, uint256 next)',
  'function getPoolState(uint256 marketId, uint256 feeOrHook) view returns (uint256 rYes, uint256 rNo, uint256 pYesNum, uint256 pYesDen)',
  'function poolKey(uint256 marketId, uint256 feeOrHook) view returns (tuple(uint256 id0, uint256 id1, address token0, address token1, uint256 feeOrHook))',
  'function splitAndAddLiquidity(uint256 marketId, uint256 collateralIn, uint256 feeOrHook, uint256 amount0Min, uint256 amount1Min, uint256 minLiquidity, address to, uint256 deadline) payable returns (uint256 shares, uint256 liquidity)',
  'function getMarket(uint256 marketId) view returns (address resolver, address collateral, bool resolved, bool outcome, bool canClose, uint64 close, uint256 collateralLocked, uint256 yesSupply, uint256 noSupply, string description)'
];

const ZAMM_ABI = [
  'function balanceOf(address, uint256) view returns (uint256)',
  'function pools(uint256) view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast, uint256 price0CumulativeLast, uint256 price1CumulativeLast, uint256 kLast, uint256 supply)',
  'function setOperator(address, bool)',
  'function isOperator(address, address) view returns (bool)',
  'function swapExactIn(tuple(uint256 id0, uint256 id1, address token0, address token1, uint256 feeOrHook) poolKey, uint256 amountIn, uint256 amountOutMin, bool zeroForOne, address to, uint256 deadline) returns (uint256 amountOut)',
  'event Swap(uint256 indexed poolId, address indexed sender, uint256 amount0In, uint256 amount1In, uint256 amount0Out, uint256 amount1Out, address indexed to)'
];

// Legacy PM Router for 30 bps fee tier markets (atomic split+swap)
const PM_ROUTER_ABI = [
  'function buy(uint256 marketId, bool isYes, uint256 collateralIn, uint256 minSharesOut, uint256 feeOrHook, address to, uint256 deadline) payable returns (uint256)',
  'function sell(uint256 marketId, bool isYes, uint256 sharesIn, uint256 minCollateralOut, uint256 feeOrHook, address to, uint256 deadline) returns (uint256)',
  'function claim(uint256 marketId, address to) returns (uint256 payout)',
  'function split(uint256 marketId, uint256 amount, address to) payable'
];

const QUOTER_ABI = [
  'function getTWAPPrice(uint256 marketId) view returns (uint256 twapBps)',
  'function getMarketSummary(uint256 marketId) view returns (uint112 ammYesReserve, uint112 ammNoReserve, uint256 ammPriceYesBps, uint256 feeBps, uint112 vaultYesShares, uint112 vaultNoShares, uint256 totalYesVaultLP, uint256 totalNoVaultLP, uint256 vaultBudget, uint256 twapPriceYesBps, uint64 closeTime, bool resolved, bool inCloseWindow)',
  'function getUserFullPosition(uint256 marketId, address user) view returns (uint256 yesShareBalance, uint256 noShareBalance, uint112 yesVaultLP, uint112 noVaultLP, uint256 pendingYesCollateral, uint256 pendingNoCollateral)',
  'function quoteBootstrapBuy(uint256 marketId, bool buyYes, uint256 collateralIn, uint256 minSharesOut) view returns (uint256 totalSharesOut, bool usesVault, bytes4 source, uint256 vaultSharesMinted)',
  'function quoteSellWithBootstrap(uint256 marketId, bool sellYes, uint256 sharesIn) view returns (uint256 collateralOut, bytes4 source)',
  'function getLiquidityBreakdown(uint256 marketId, bool buyYes) view returns (uint256 vaultOtcShares, uint256 vaultOtcPriceBps, bool vaultOtcAvailable, uint112 ammYesReserve, uint112 ammNoReserve, uint256 ammSpotPriceBps, uint256 ammMaxImpactBps, uint256 poolAskDepth, uint256 poolBestAskBps, uint256 poolBidDepth, uint256 poolBestBidBps)',
  'function quoteBuyWithSweep(uint256 marketId, bool buyYes, uint256 collateralIn, uint256 maxPriceBps) view returns (uint256 totalSharesOut, uint256 poolSharesOut, uint256 poolLevelsFilled, uint256 pmSharesOut, bytes4 pmSource)',
  'function quoteSellWithSweep(uint256 marketId, bool sellYes, uint256 sharesIn, uint256 minPriceBps) view returns (uint256 totalCollateralOut, uint256 poolCollateralOut, uint256 poolLevelsFilled, uint256 pmCollateralOut, bytes4 pmSource)',
  'function getActiveLevels(uint256 marketId, bool isYes, uint256 maxLevels) view returns (uint256[] askPrices, uint256[] askDepths, uint256[] bidPrices, uint256[] bidDepths)',
  'function getUserActivePositions(uint256 marketId, bool isYes, address user) view returns (uint256[] askPrices, uint256[] askShares, uint256[] askPendingColl, uint256[] bidPrices, uint256[] bidCollateral, uint256[] bidPendingShares)'
];

const PM_HOOK_ROUTER_ABI = [
  'function vaultPositions(uint256, address) view returns (uint112 yesVaultShares, uint112 noVaultShares, uint32 lastDepositTime, uint256 yesRewardDebt, uint256 noRewardDebt)',
  'function withdrawFromVault(uint256 marketId, bool isYes, uint256 vaultSharesToRedeem, address receiver, uint256 deadline) returns (uint256 sharesReturned, uint256 feesEarned)',
  'function harvestVaultFees(uint256 marketId, bool isYes) returns (uint256 feesEarned)',
  'function totalYesVaultShares(uint256) view returns (uint256)',
  'function totalNoVaultShares(uint256) view returns (uint256)',
  'function rebalanceCollateralBudget(uint256) view returns (uint256)',
  'function accYesCollateralPerShare(uint256) view returns (uint256)',
  'function accNoCollateralPerShare(uint256) view returns (uint256)',
  'function bootstrapVaults(uint256) view returns (uint112 yesShares, uint112 noShares, uint32 lastActivity)',
  'function bootstrapMarket(string description, address resolver, address collateral, uint64 close, bool canClose, address hook, uint256 collateralForLP, bool buyYes, uint256 collateralForBuy, uint256 minSharesOut, address to, uint256 deadline) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares, uint256 sharesOut)'
];

const MASTER_ROUTER_ABI = [
  // Market orders with sweep
  'function buyWithSweep(uint256 marketId, bool buyYes, uint256 collateralIn, uint256 minSharesOut, uint256 maxPriceBps, address to, uint256 deadline) payable returns (uint256 totalSharesOut, uint256 poolSharesOut, uint256 poolLevelsFilled, bytes4[] sources)',
  'function sellWithSweep(uint256 marketId, bool sellYes, uint256 sharesIn, uint256 minCollateralOut, uint256 minPriceBps, address to, uint256 deadline) returns (uint256 totalCollateralOut, uint256 poolCollateralOut, uint256 poolLevelsFilled, bytes4[] sources)',
  // Limit order fallbacks
  'function buyWithBidFallback(uint256 marketId, bool buyYes, uint256 collateralIn, uint256 maxSweepPriceBps, uint256 bidPriceBps, address to, uint256 deadline) payable returns (uint256 sharesOut, bytes32 bidPoolId)',
  'function sellWithAskFallback(uint256 marketId, bool sellYes, uint256 sharesIn, uint256 minPriceBps, uint256 askPriceBps, address to, uint256 deadline) returns (uint256 collOut, bytes32 askPoolId)',
  // Sweep + mint + pool
  'function sweepMintAndPool(uint256 marketId, bool buyYes, uint256 collateralIn, uint256 maxSweepPriceBps, uint256 askPriceBps, address to, uint256 deadline) payable returns (uint256 sharesOut, bytes32 poolId)',
  // Mint operations
  'function mintAndPool(uint256 marketId, uint256 collateralIn, bool keepYes, uint256 priceInBps, address to) payable returns (bytes32 poolId)',
  'function mintAndVault(uint256 marketId, uint256 collateralIn, bool keepYes, address to) payable returns (uint256 sharesKept, uint256 vaultShares)',
  'function mintAndSellOther(uint256 marketId, uint256 collateralIn, bool keepYes, uint256 minPriceBps, address to, uint256 deadline) payable returns (uint256 sharesKept, uint256 collateralRecovered)',
  // Pool operations
  'function depositToPool(uint256 marketId, bool isYes, uint256 priceInBps, uint256 sharesIn, address to) returns (bytes32 poolId)',
  'function withdrawFromPool(uint256 marketId, bool isYes, uint256 priceInBps, uint256 sharesToWithdraw, address to) returns (uint256 sharesWithdrawn, uint256 collateralClaimed)',
  'function claimProceeds(uint256 marketId, bool isYes, uint256 priceInBps, address to) returns (uint256 collateralClaimed)',
  'function fillFromPool(uint256 marketId, bool isYes, uint256 priceInBps, uint256 sharesWanted, uint256 maxCollateral, address to, uint256 deadline) payable returns (uint256 sharesBought, uint256 collateralPaid)',
  // Bid pool operations
  'function depositToBidPool(uint256 marketId, bool buyYes, uint256 priceInBps, uint256 collateralIn, address to) payable returns (bytes32 bidPoolId)',
  'function withdrawFromBidPool(uint256 marketId, bool buyYes, uint256 priceInBps, uint256 collateralToWithdraw, address to) returns (uint256 collateralWithdrawn, uint256 sharesClaimed)',
  'function claimBidShares(uint256 marketId, bool buyYes, uint256 priceInBps, address to) returns (uint256 sharesClaimed)',
  'function fillBidPool(uint256 marketId, bool buyYes, uint256 priceInBps, uint256 sharesWanted, uint256 minCollateral, address to, uint256 deadline) returns (uint256 sharesSold, uint256 collateralReceived)',
  // View functions
  'function getPoolId(uint256 marketId, bool isYes, uint256 priceInBps) view returns (bytes32)',
  'function getBidPoolId(uint256 marketId, bool buyYes, uint256 priceInBps) view returns (bytes32)',
  'function pools(bytes32 poolId) view returns (uint256 totalShares, uint256 totalScaled, uint256 accCollPerScaled, uint256 collateralEarned)',
  'function bidPools(bytes32 poolId) view returns (uint256 totalCollateral, uint256 totalScaled, uint256 accSharesPerScaled, uint256 sharesAcquired)',
  'function getUserPosition(uint256 marketId, bool isYes, uint256 priceInBps, address user) view returns (uint256 userScaled, uint256 userWithdrawableShares, uint256 userPendingCollateral, uint256 userCollateralDebt)',
  'function getBidUserPosition(uint256 marketId, bool buyYes, uint256 priceInBps, address user) view returns (uint256 userScaled, uint256 userWithdrawableCollateral, uint256 userPendingShares, uint256 userSharesDebt)',
  'function getBestAsk(uint256 marketId, bool isYes) view returns (uint256 bestPrice)',
  'function getBestBid(uint256 marketId, bool isYes) view returns (uint256 bestPrice)',
  // Vault integration
  'function provideLiquidity(uint256 marketId, uint256 collateralAmount, uint256 vaultYesShares, uint256 vaultNoShares, uint256 ammLPShares, uint256 minAmount0, uint256 minAmount1, address receiver, uint256 deadline) payable returns (uint256 yesVaultSharesMinted, uint256 noVaultSharesMinted, uint256 ammLiquidity)',
  // ERC20 permit (for gasless approval in multicall)
  'function permit(address token, address owner, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)',
  // Multicall
  'function multicall(bytes[] data) payable returns (bytes[] results)'
];

const RESOLVER_ABI = [
  'function createNumericMarketAndSeed(string observable, address collateral, address target, bytes callData, uint8 op, uint256 threshold, uint64 close, bool canClose, tuple(uint256 collateralIn, uint256 feeOrHook, uint256 amount0Min, uint256 amount1Min, uint256 minLiquidity, address lpRecipient, uint256 deadline) seed) payable returns (uint256 marketId, uint256 noId, uint256 shares, uint256 liquidity)',
  'function createNumericMarket(string observable, address collateral, address target, bytes callData, uint8 op, uint256 threshold, uint64 close, bool canClose) returns (uint256 marketId, uint256 noId)',
  'function createBetweenMarket(string observable, address collateral, address target, bytes callData, uint256 lower, uint256 upper, uint64 close, bool canClose) returns (uint256 marketId, uint256 noId)',
  'function registerConditionForExistingMarket(uint256 marketId, address target, bytes callData, uint8 op, uint256 threshold)',
  'function registerBetweenConditionForExistingMarket(uint256 marketId, address target, bytes callData, uint256 lower, uint256 upper)',
  'function resolveMarket(uint256 marketId)',
  'function preview(uint256 marketId) view returns (uint256 value, bool condTrue, bool ready)',
  'function conditions(uint256) view returns (address targetA, address targetB, uint8 op, bool isRatio, uint256 threshold, uint256 threshold2, bytes callDataA, bytes callDataB)'
];

// Legacy resolver ABI (different conditions return format - no threshold2)
const LEGACY_RESOLVER_ABI = [
  'function preview(uint256 marketId) view returns (uint256 value, bool condTrue, bool ready)',
  'function conditions(uint256) view returns (address targetA, address targetB, uint8 op, bool isRatio, uint256 threshold, bytes callDataA, bytes callDataB)',
  'function resolveMarket(uint256 marketId)'
];

const BOOTSTRAPPER_ABI = [
  // Open resolver markets (UMA, Reality.eth, EOA, etc.)
  'function bootstrapMarket(string description, address resolverAddr, address collateral, uint64 close, bool canClose, address hook, uint256 collateralForLP, bool buyYes, uint256 collateralForBuy, uint256 minSharesOut, address to, uint256 deadline) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares, uint256 sharesOut)',
  'function bootstrapMarketWithBids(string description, address resolverAddr, address collateral, uint64 close, bool canClose, address hook, uint256 collateralForLP, address to, uint256 deadline, tuple(bool buyYes, uint256 priceInBps, uint256 amount, uint256 minShares)[] bids) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares)',
  'function bootstrapMarketWithVault(string description, address resolverAddr, address collateral, uint64 close, bool canClose, address hook, uint256 collateralForLP, address to, uint256 deadline, tuple(uint256 collateralForVault, uint256 vaultYesShares, uint256 vaultNoShares) vault, tuple(bool buyYes, uint256 collateralForBuy) buy) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares, uint256 sharesOut, uint256 yesVaultShares, uint256 noVaultShares)',
  'function bootstrapMarketWithVaultAndBids(string description, address resolverAddr, address collateral, uint64 close, bool canClose, address hook, uint256 collateralForLP, address to, uint256 deadline, tuple(uint256 collateralForVault, uint256 vaultYesShares, uint256 vaultNoShares) vault, tuple(bool buyYes, uint256 collateralForBuy) buy, tuple(bool buyYes, uint256 priceInBps, uint256 amount, uint256 minShares)[] bids) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares, uint256 sharesOut, uint256 yesVaultShares, uint256 noVaultShares)',
  // Resolver.sol - generic condition
  'function bootstrapWithCondition(string description, address collateral, uint64 close, bool canClose, address hook, uint256 collateralForLP, bool buyYes, uint256 collateralForBuy, uint256 minSharesOut, address to, uint256 deadline, address target, bytes callData, uint8 op, uint256 threshold) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares, uint256 sharesOut)',
  'function bootstrapWithConditionAndBids(string description, address collateral, uint64 close, bool canClose, address hook, uint256 collateralForLP, address to, uint256 deadline, address target, bytes callData, uint8 op, uint256 threshold, tuple(bool buyYes, uint256 priceInBps, uint256 amount, uint256 minShares)[] bids) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares)',
  'function bootstrapWithConditionAndVault(string description, address collateral, uint64 close, bool canClose, address hook, uint256 collateralForLP, address to, uint256 deadline, address target, bytes callData, uint8 op, uint256 threshold, tuple(uint256 collateralForVault, uint256 vaultYesShares, uint256 vaultNoShares) vault, tuple(bool buyYes, uint256 collateralForBuy) buy) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares, uint256 sharesOut, uint256 yesVaultShares, uint256 noVaultShares)',
  'function bootstrapWithConditionAndVaultAndBids(string description, address collateral, uint64 close, bool canClose, address hook, uint256 collateralForLP, address to, uint256 deadline, address target, bytes callData, uint8 op, uint256 threshold, tuple(uint256 collateralForVault, uint256 vaultYesShares, uint256 vaultNoShares) vault, tuple(bool buyYes, uint256 collateralForBuy) buy, tuple(bool buyYes, uint256 priceInBps, uint256 amount, uint256 minShares)[] bids) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares, uint256 sharesOut, uint256 yesVaultShares, uint256 noVaultShares)',
  // Resolver.sol - price feed markets (Chainlink)
  'function bootstrapPriceMarket(string description, address collateral, uint64 close, address hook, uint256 collateralForLP, address to, uint256 deadline, address priceFeed, uint8 op, uint256 priceThreshold) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares)',
  'function bootstrapPriceMarketWithBids(string description, address collateral, uint64 close, address hook, uint256 collateralForLP, address to, uint256 deadline, address priceFeed, uint8 op, uint256 priceThreshold, tuple(bool buyYes, uint256 priceInBps, uint256 amount, uint256 minShares)[] bids) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares)',
  'function bootstrapPriceMarketWithVault(string description, address collateral, uint64 close, address hook, uint256 collateralForLP, address to, uint256 deadline, address priceFeed, uint8 op, uint256 priceThreshold, tuple(uint256 collateralForVault, uint256 vaultYesShares, uint256 vaultNoShares) vault, tuple(bool buyYes, uint256 collateralForBuy) buy) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares, uint256 sharesOut, uint256 yesVaultShares, uint256 noVaultShares)',
  'function bootstrapPriceMarketWithVaultAndBids(string description, address collateral, uint64 close, address hook, uint256 collateralForLP, address to, uint256 deadline, address priceFeed, uint8 op, uint256 priceThreshold, tuple(uint256 collateralForVault, uint256 vaultYesShares, uint256 vaultNoShares) vault, tuple(bool buyYes, uint256 collateralForBuy) buy, tuple(bool buyYes, uint256 priceInBps, uint256 amount, uint256 minShares)[] bids) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares, uint256 sharesOut, uint256 yesVaultShares, uint256 noVaultShares)',
  // Resolver.sol - ETH balance markets
  'function bootstrapETHBalanceMarket(string description, address collateral, uint64 close, address hook, uint256 collateralForLP, address to, uint256 deadline, address account, uint8 op, uint256 balanceThreshold) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares)',
  'function bootstrapETHBalanceMarketWithBids(string description, address collateral, uint64 close, address hook, uint256 collateralForLP, address to, uint256 deadline, address account, uint8 op, uint256 balanceThreshold, tuple(bool buyYes, uint256 priceInBps, uint256 amount, uint256 minShares)[] bids) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares)',
  'function bootstrapETHBalanceMarketWithVault(string description, address collateral, uint64 close, address hook, uint256 collateralForLP, address to, uint256 deadline, address account, uint8 op, uint256 balanceThreshold, tuple(uint256 collateralForVault, uint256 vaultYesShares, uint256 vaultNoShares) vault, tuple(bool buyYes, uint256 collateralForBuy) buy) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares, uint256 sharesOut, uint256 yesVaultShares, uint256 noVaultShares)',
  'function bootstrapETHBalanceMarketWithVaultAndBids(string description, address collateral, uint64 close, address hook, uint256 collateralForLP, address to, uint256 deadline, address account, uint8 op, uint256 balanceThreshold, tuple(uint256 collateralForVault, uint256 vaultYesShares, uint256 vaultNoShares) vault, tuple(bool buyYes, uint256 collateralForBuy) buy, tuple(bool buyYes, uint256 priceInBps, uint256 amount, uint256 minShares)[] bids) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares, uint256 sharesOut, uint256 yesVaultShares, uint256 noVaultShares)',
  // Resolver.sol - ERC20 token balance markets
  'function bootstrapTokenBalanceMarket(string description, address collateral, uint64 close, address hook, uint256 collateralForLP, address to, uint256 deadline, address token, address account, uint8 op, uint256 balanceThreshold) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares)',
  'function bootstrapTokenBalanceMarketWithVault(string description, address collateral, uint64 close, address hook, uint256 collateralForLP, address to, uint256 deadline, address token, address account, uint8 op, uint256 balanceThreshold, tuple(uint256 collateralForVault, uint256 vaultYesShares, uint256 vaultNoShares) vault, tuple(bool buyYes, uint256 collateralForBuy) buy) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares, uint256 sharesOut, uint256 yesVaultShares, uint256 noVaultShares)',
  'function bootstrapTokenBalanceMarketWithBids(string description, address collateral, uint64 close, address hook, uint256 collateralForLP, address to, uint256 deadline, address token, address account, uint8 op, uint256 balanceThreshold, tuple(bool buyYes, uint256 priceInBps, uint256 amount, uint256 minShares)[] bids) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares)',
  'function bootstrapTokenBalanceMarketWithVaultAndBids(string description, address collateral, uint64 close, address hook, uint256 collateralForLP, address to, uint256 deadline, address token, address account, uint8 op, uint256 balanceThreshold, tuple(uint256 collateralForVault, uint256 vaultYesShares, uint256 vaultNoShares) vault, tuple(bool buyYes, uint256 collateralForBuy) buy, tuple(bool buyYes, uint256 priceInBps, uint256 amount, uint256 minShares)[] bids) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares, uint256 sharesOut, uint256 yesVaultShares, uint256 noVaultShares)',
  // GasPM-style gas markets (via HookRouter + Resolver)
  'function bootstrapGasTWAPMarketWithBids(string description, address collateral, uint64 close, bool canClose, address hook, uint256 collateralForLP, address to, uint256 deadline, uint8 op, uint256 threshold, tuple(bool buyYes, uint256 priceInBps, uint256 amount, uint256 minShares)[] bids) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares)',
  'function bootstrapGasTWAPMarketWithVault(string description, address collateral, uint64 close, bool canClose, address hook, uint256 collateralForLP, address to, uint256 deadline, uint8 op, uint256 threshold, tuple(uint256 collateralForVault, uint256 vaultYesShares, uint256 vaultNoShares) vault, tuple(bool buyYes, uint256 collateralForBuy) buy) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares, uint256 sharesOut, uint256 yesVaultShares, uint256 noVaultShares)',
  'function bootstrapGasRangeMarketWithBids(string description, address collateral, uint64 close, bool canClose, address hook, uint256 collateralForLP, address to, uint256 deadline, uint256 lower, uint256 upper, tuple(bool buyYes, uint256 priceInBps, uint256 amount, uint256 minShares)[] bids) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares)',
  'function bootstrapGasVolatilityMarketWithBids(string description, address collateral, uint64 close, bool canClose, address hook, uint256 collateralForLP, address to, uint256 deadline, uint256 threshold, tuple(bool buyYes, uint256 priceInBps, uint256 amount, uint256 minShares)[] bids) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares)',
  'function bootstrapGasPeakMarketWithBids(string description, address collateral, uint64 close, bool canClose, address hook, uint256 collateralForLP, address to, uint256 deadline, uint256 threshold, tuple(bool buyYes, uint256 priceInBps, uint256 amount, uint256 minShares)[] bids) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares)',
  'function bootstrapGasTroughMarketWithBids(string description, address collateral, uint64 close, bool canClose, address hook, uint256 collateralForLP, address to, uint256 deadline, uint256 threshold, tuple(bool buyYes, uint256 priceInBps, uint256 amount, uint256 minShares)[] bids) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares)',
  // Gas markets (no bids variants)
  'function bootstrapGasTWAPMarket(string description, address collateral, uint64 close, bool canClose, address hook, uint256 collateralForLP, address to, uint256 deadline, uint8 op, uint256 threshold) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares)',
  'function bootstrapGasRangeMarket(string description, address collateral, uint64 close, bool canClose, address hook, uint256 collateralForLP, address to, uint256 deadline, uint256 lower, uint256 upper) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares)',
  'function bootstrapGasVolatilityMarket(string description, address collateral, uint64 close, bool canClose, address hook, uint256 collateralForLP, address to, uint256 deadline, uint256 threshold) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares)',
  'function bootstrapGasPeakMarket(string description, address collateral, uint64 close, bool canClose, address hook, uint256 collateralForLP, address to, uint256 deadline, uint256 threshold) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares)',
  'function bootstrapGasTroughMarket(string description, address collateral, uint64 close, bool canClose, address hook, uint256 collateralForLP, address to, uint256 deadline, uint256 threshold) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares)',
  // Spot gas markets (checks block.basefee at resolution)
  'function bootstrapGasSpotMarket(string description, address collateral, uint64 close, bool canClose, address hook, uint256 collateralForLP, address to, uint256 deadline, uint8 op, uint256 threshold) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares)',
  'function bootstrapGasSpotMarketWithBids(string description, address collateral, uint64 close, bool canClose, address hook, uint256 collateralForLP, address to, uint256 deadline, uint8 op, uint256 threshold, tuple(bool buyYes, uint256 priceInBps, uint256 amount, uint256 minShares)[] bids) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares)',
  // Orderbook liquidity
  'function addOrderbookBids(uint256 marketId, address collateral, tuple(bool buyYes, uint256 priceInBps, uint256 amount, uint256 minShares)[] bids, address to) payable',
  // View helpers
  'function computeMarketId(string description, address resolverAddr, address collateral) view returns (uint256)',
  'function computeMarketIdResolver(string description, address collateral) view returns (uint256)',
  // Multicall & permit
  'function multicall(bytes[] data) payable returns (bytes[] results)',
  'function permit(address token, address owner, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)',
  'function permitDAI(address token, address owner, uint256 nonce, uint256 deadline, bool allowed, uint8 v, bytes32 r, bytes32 s)'
];

const CHAINLINK_ABI = [
  'function latestAnswer() view returns (int256)',
  'function decimals() view returns (uint8)'
];


// Op enum: 0=LT, 1=GT, 2=LTE, 3=GTE, 4=EQ, 5=NEQ
const OP = { LT: 0, GT: 1, LTE: 2, GTE: 3, EQ: 4, NEQ: 5 };

// ======================== STATE ========================
let markets = [];      // Active markets only (for main navigation)
let allMarkets = [];   // All markets including resolved (for gallery)
let currentIndex = 0;
let dir = null;
let dark = localStorage.theme === 'dark' || (!localStorage.theme && matchMedia('(prefers-color-scheme:dark)').matches);
let isTrading = false;
let tradeMode = 'buy'; // 'buy' or 'sell'
let userPositions = { yes: 0n, no: 0n };
let lpPositions = { yesVault: 0n, noVault: 0n, ammLP: 0n, yesFees: 0n, noFees: 0n };
let orderPositions = {
  // User's listed orders in the order book
  yesAskShares: 0, yesAskPrices: [], // YES shares listed for sale
  noAskShares: 0, noAskPrices: [],   // NO shares listed for sale
  yesBidColl: 0, yesBidPrices: [],   // Collateral bidding for YES
  noBidColl: 0, noBidPrices: []      // Collateral bidding for NO
};
let marketLiquidity = {
  total: 0,           // Total available liquidity (AMM + vault + orders)
  threshold: 0.05,    // Book building threshold in ETH
  hitsAmm: false      // Whether trades will hit AMM
};
let vaultStats = {
  yesTotalShares: 0n, noTotalShares: 0n,       // Total vault shares (LP tokens)
  yesUnderlying: 0n, noUnderlying: 0n,         // Underlying Y/N shares in vault
  yesTotalFees: 0n, noTotalFees: 0n            // Total fees distributed
};
let poolStats = {
  reserve0: 0n, reserve1: 0n,                  // Pool reserves (YES/NO)
  totalSupply: 0n,                             // Total LP tokens
  userShare: 0,                                // User's % of pool
  yesReserve: 0n, noReserve: 0n,              // Mapped reserves
  impliedYesPrice: 50                          // Implied YES price %
};
let resolutionStatus = {
  value: 0n,        // Current oracle value
  threshold: 0n,    // Target threshold
  condTrue: false,  // Is condition met
  ready: false,     // Can be resolved
  op: 0             // Operator (0=LT, 1=GT, 2=LTE, 3=GTE)
};
let priceChart = {
  spotBps: 0,       // Current spot price in bps
  twapBps: 0,       // Current TWAP in bps
  poolId: null      // ZAMM pool ID for link
};
let liquiditySources = {
  hasVault: false,      // Has OTC vault liquidity
  hasBidPool: false,    // Has bid pool liquidity
  hasAmm: false         // Has AMM liquidity
};
let liquidityDepths = {
  amm: 0,               // AMM depth (average of reserves)
  vault: 0,             // Vault OTC depth
  bids: 0               // Bid pool depth
};
let resolveDetailsOpen = false;

// ENS reverse lookup cache (max 50 entries)
const ensCache = new Map();
const MAX_ENS_CACHE = 50;

// Market data cache with LRU eviction (max 30 markets)
const marketDataCache = new Map(); // marketId -> { noId, lastLoaded, summary, breakdown }
const MAX_MARKET_CACHE = 30;

// Contract instance cache (keyed by address + provider type)
const contractCache = new Map();

// Get or create cached contract instance
function getContract(address, abi, providerOrSigner) {
  const isSigner = !!providerOrSigner?.signTransaction;
  const key = `${address}-${isSigner ? 'signer' : 'provider'}`;
  let cached = contractCache.get(key);
  if (!cached || (isSigner && cached.runner !== providerOrSigner)) {
    cached = new ethers.Contract(address, abi, providerOrSigner);
    contractCache.set(key, cached);
  }
  return cached;
}

// Pool ID cache (poolId calculation is expensive due to keccak256)
const poolIdCache = new Map(); // marketId-hooked -> poolId

// LRU cache helper - adds to Map and evicts oldest if over limit
function cacheSet(cache, key, value, maxSize) {
  // Delete and re-add to move to end (most recently used)
  if (cache.has(key)) cache.delete(key);
  cache.set(key, value);
  // Evict oldest entries if over limit
  while (cache.size > maxSize) {
    const oldestKey = cache.keys().next().value;
    cache.delete(oldestKey);
  }
}

// Token names - mapping address (lowercase) to symbol for display
const TOKEN_NAMES = {
  '0x00000000008835cef3e0d2333695f288ee6b63a6': 'zOrgz',
  '0x514910771af9ca656af840dff83e8264ecf986ca': 'LINK',
};

// Account names - mapping address (lowercase) to friendly name for display
const ACCOUNT_NAMES = {
  '0x5e58ba0e06ed0f5558f83be732a4b899a674053e': 'zOrg DAO',
  '0xbc10f2e862ed4502144c7d632a3459f49dfcdb5e': 'Chainlink Reserve',
  '0x9a709b7b69ea42d5eeb1cebc48674c69e1569ec6': 'RBACTimelock',
};

// Token logos - extensible registry mapping address (lowercase) to SVG
// Add new tokens here as needed
const ZORGZ_LOGO = `<svg width="16" height="16" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" style="vertical-align:middle;margin-right:4px;image-rendering:pixelated"><rect width="16" height="16" fill="#0a0a0a"/><rect x="3" y="1" width="1" height="1" fill="#e8e8e0"/><rect x="5" y="2" width="1" height="1" fill="#e8e8e0"/><rect x="10" y="2" width="1" height="1" fill="#e8e8e0"/><rect x="12" y="1" width="1" height="1" fill="#e8e8e0"/><rect x="4" y="4" width="8" height="1" fill="#e8e8e0"/><rect x="3" y="5" width="10" height="1" fill="#e8e8e0"/><rect x="2" y="6" width="12" height="3" fill="#e8e8e0"/><rect x="3" y="9" width="10" height="1" fill="#e8e8e0"/><rect x="4" y="10" width="8" height="1" fill="#e8e8e0"/><rect x="3" y="6" width="3" height="2" fill="#0a0a0a"/><rect x="10" y="6" width="3" height="2" fill="#0a0a0a"/><rect x="5" y="11" width="2" height="1" fill="#e8e8e0"/><rect x="9" y="11" width="2" height="1" fill="#e8e8e0"/><rect x="2" y="12" width="3" height="1" fill="#e8e8e0"/><rect x="7" y="12" width="2" height="1" fill="#e8e8e0"/><rect x="11" y="12" width="3" height="1" fill="#e8e8e0"/><rect x="1" y="13" width="2" height="1" fill="#e8e8e0"/><rect x="13" y="13" width="2" height="1" fill="#e8e8e0"/></svg>`;
const TOKEN_LOGOS = {
  // zOrgz - pixel art creature (by name and address)
  'zorgz': ZORGZ_LOGO,
  '0x00000000008835cef3e0d2333695f288ee6b63a6': ZORGZ_LOGO,
  // Chainlink (LINK)
  '0x514910771af9ca656af840dff83e8264ecf986ca': `<svg width="16" height="16" viewBox="0 0 24 24" role="img" xmlns="http://www.w3.org/2000/svg" style="vertical-align:middle;margin-right:4px"><path fill="currentColor" d="M12 0 9.798 1.266l-6 3.468L1.596 6v12l2.202 1.266 6.055 3.468L12.055 24l2.202-1.266 5.945-3.468L22.404 18V6l-2.202-1.266-6-3.468zM6 15.468V8.532l6-3.468 6 3.468v6.936l-6 3.468z"/></svg>`,
  // ETH - official colored logo
  'eth': `<svg width="16" height="16" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg" style="vertical-align:middle;margin-right:4px"><circle cx="16" cy="16" r="16" fill="#627EEA"/><g fill="#FFF" fill-rule="nonzero"><path fill-opacity=".602" d="M16.498 4v8.87l7.497 3.35z"/><path d="M16.498 4L9 16.22l7.498-3.35z"/><path fill-opacity=".602" d="M16.498 21.968v6.027L24 17.616z"/><path d="M16.498 27.995v-6.028L9 17.616z"/><path fill-opacity=".2" d="M16.498 20.573l7.497-4.353-7.497-3.348z"/><path fill-opacity=".602" d="M9 16.22l7.498 4.353v-7.701z"/></g></svg>`,
  // Uniswap (UNI) - official unicorn logo
  '0x1f9840a85d5af5bf1d1762f925bdaddc4201f984': `<svg width="16" height="16" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg" style="vertical-align:middle;margin-right:4px"><circle fill="#FF007A" cx="16" cy="16" r="16"/><g fill="#FFF"><path d="M12.261 5.767c-.285-.044-.297-.05-.163-.07.257-.04.865.015 1.284.114.977.233 1.866.828 2.816 1.885l.252.28.36-.057c1.52-.245 3.067-.05 4.36.547.356.164.917.491.987.576.023.026.064.199.091.383.096.637.048 1.125-.146 1.49-.106.198-.112.26-.041.43a.416.416 0 00.372.236c.322 0 .668-.52.828-1.243l.064-.287.126.143c.692.784 1.235 1.853 1.328 2.613l.025.199-.117-.18c-.2-.31-.4-.522-.658-.693-.464-.307-.955-.411-2.255-.48-1.174-.062-1.839-.162-2.497-.377-1.121-.365-1.686-.852-3.018-2.599-.591-.776-.957-1.205-1.32-1.55-.827-.786-1.639-1.198-2.678-1.36z"/><path d="M22.422 7.5c.03-.52.1-.863.242-1.176.056-.124.109-.226.117-.226a.773.773 0 01-.055.204c-.103.304-.12.72-.049 1.203.09.614.142.702.79 1.365.305.311.659.703.787.872l.233.306-.233-.219c-.285-.267-.941-.79-1.086-.864-.097-.05-.112-.049-.172.01-.055.056-.067.138-.074.529-.012.608-.095 1-.296 1.39-.108.21-.125.166-.027-.073.073-.178.08-.256.08-.845 0-1.184-.141-1.468-.966-1.956a9.046 9.046 0 00-.764-.396 2.916 2.916 0 01-.374-.182c.023-.023.827.211 1.15.336.482.185.561.209.62.186.039-.015.058-.129.077-.464zm-9.607 2.025c-.579-.797-.937-2.02-.86-2.934l.024-.283.132.024c.248.045.675.204.875.326.548.333.786.772 1.027 1.898.071.33.164.703.207.83.068.203.328.678.54.987.152.222.05.327-.286.297-.514-.047-1.21-.527-1.659-1.145zm8.905 5.935c-2.707-1.09-3.66-2.036-3.66-3.632 0-.235.008-.427.017-.427.01 0 .115.077.233.172.549.44 1.164.628 2.865.876 1.001.147 1.565.265 2.085.437 1.652.548 2.674 1.66 2.918 3.174.07.44.029 1.265-.086 1.7-.09.344-.367.963-.44.987-.02.006-.04-.071-.046-.178-.028-.568-.315-1.122-.798-1.537-.549-.471-1.286-.847-3.089-1.572zm-1.9.452a4.808 4.808 0 00-.131-.572l-.07-.206.129.144c.177.2.318.454.436.794.091.259.101.336.1.757 0 .414-.011.5-.095.734a2.32 2.32 0 01-.571.908c-.495.504-1.13.782-2.048.898-.16.02-.624.054-1.033.075-1.03.054-1.707.164-2.316.378a.488.488 0 01-.174.042c-.024-.025.39-.272.733-.437.483-.233.963-.36 2.04-.539.532-.089 1.082-.196 1.221-.239 1.318-.404 1.995-1.446 1.778-2.737z"/><path d="M21.06 18.116c-.36-.773-.442-1.52-.245-2.216.021-.074.055-.135.075-.135a.73.73 0 01.189.102c.166.112.498.3 1.383.782 1.105.603 1.735 1.07 2.164 1.602.375.467.607.999.719 1.647.063.367.026 1.25-.068 1.62-.297 1.166-.988 2.082-1.972 2.616a2.53 2.53 0 01-.288.143c-.014 0 .038-.133.117-.297.33-.692.369-1.366.118-2.116-.153-.459-.466-1.02-1.097-1.966-.734-1.1-.914-1.394-1.095-1.782zm-10.167 4.171c1.005-.848 2.254-1.45 3.393-1.635.49-.08 1.308-.048 1.762.068.728.186 1.38.604 1.719 1.101.33.486.473.91.62 1.852.06.372.123.745.142.83.11.488.327.879.595 1.075.425.311 1.158.33 1.878.05a.981.981 0 01.236-.074c.026.026-.336.269-.592.397a2.014 2.014 0 01-.983.238c-.66 0-1.208-.335-1.665-1.02-.09-.135-.292-.538-.45-.897-.482-1.1-.72-1.436-1.28-1.803-.489-.32-1.118-.377-1.591-.145-.622.305-.795 1.1-.35 1.603.177.2.507.373.777.406a.83.83 0 00.939-.83c0-.332-.128-.52-.448-.665-.437-.197-.907.033-.905.444.001.175.077.285.253.365.113.05.115.055.023.036-.401-.084-.495-.567-.172-.888.387-.386 1.188-.216 1.463.31.116.221.129.662.028.928-.225.595-.883.907-1.55.737-.454-.116-.639-.241-1.186-.805-.951-.98-1.32-1.17-2.692-1.384l-.263-.041.3-.253z"/><path d="M6.196 3.35l.096.117c3.708 4.54 5.624 6.896 5.746 7.064.2.278.125.527-.219.723-.191.109-.585.219-.781.219-.223 0-.474-.107-.657-.28-.129-.123-.65-.901-1.853-2.768a188.53 188.53 0 00-1.712-2.633c-.049-.046-.048-.045 1.618 2.936 1.046 1.872 1.4 2.533 1.4 2.622 0 .18-.05.274-.272.522-.37.413-.535.877-.655 1.837-.134 1.077-.51 1.837-1.554 3.138-.61.762-.71.902-.865 1.209-.194.386-.247.603-.269 1.091-.023.516.022.85.18 1.343.138.432.282.718.65 1.288.318.493.501.859.501 1.002 0 .114.022.114.515.003 1.179-.266 2.136-.735 2.675-1.309.333-.355.411-.551.414-1.038.001-.318-.01-.385-.096-.568-.14-.298-.395-.546-.957-.93-.737-.504-1.051-.91-1.138-1.467-.072-.457.011-.78.419-1.634.421-.884.526-1.26.597-2.151.045-.576.108-.803.274-.985.172-.19.328-.255.755-.313.696-.095 1.139-.275 1.503-.61.316-.292.448-.573.468-.995l.016-.32-.177-.206c-.254-.296-2.355-2.614-6.304-6.956l-.106-.115-.212.165zM7.91 19.732a.566.566 0 00-.174-.746c-.228-.152-.583-.08-.583.118 0 .06.033.104.108.143.127.065.136.139.037.288-.101.152-.093.286.023.377.186.146.45.065.59-.18zm5.524-7.176c-.327.1-.644.447-.743.81-.06.221-.026.61.064.73.145.194.286.245.666.242.744-.005 1.39-.324 1.466-.723.062-.327-.223-.78-.614-.98-.202-.102-.631-.143-.839-.079zm.87.68c.115-.163.064-.34-.13-.458-.372-.227-.934-.04-.934.312 0 .174.293.365.561.365.18 0 .424-.107.503-.219z"/></g></svg>`,
};

// Chainlink price feed addresses (for displaying logo next to price feeds)
const CHAINLINK_FEEDS = new Set([
  '0x5f4ec3df9cbd43714fe2740f5e3616155c5b8419', // ETH/USD
  '0xf4030086522a5beea4988f8ca5b36dbc97bee88c', // BTC/USD
  '0x2c1d072e956affc0d435cb7ac38ef18d24d9127c', // LINK/USD
  // Add more feeds as needed
].map(a => a.toLowerCase()));

// Chainlink price feeds for collateral tokens (token/ETH pairs)
const COLLATERAL_PRICE_FEEDS = {
  // UNI/ETH - returns UNI price in ETH (18 decimals)
  '0x1f9840a85d5af5bf1d1762f925bdaddc4201f984': '0xD6aA3D25116d8dA79Ea0246c4826EB951872e02e',
};

// Cache for collateral prices (token address -> { price, timestamp })
const collateralPriceCache = new Map();

// Get collateral price in ETH from Chainlink oracle
async function getCollateralPriceInETH(collateralAddress) {
  if (!collateralAddress || collateralAddress === ethers.ZeroAddress) return 1; // ETH = 1 ETH

  const feedAddress = COLLATERAL_PRICE_FEEDS[collateralAddress.toLowerCase()];
  if (!feedAddress) return null; // No oracle available

  // Check cache (5 minute TTL)
  const cached = collateralPriceCache.get(collateralAddress.toLowerCase());
  if (cached && Date.now() - cached.timestamp < 300000) {
    return cached.price;
  }

  try {
    const rpc = provider || await getRpc();
    const feed = new ethers.Contract(feedAddress, [
      'function latestRoundData() view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)',
      'function decimals() view returns (uint8)'
    ], rpc);

    const [roundData, decimals] = await Promise.all([
      feed.latestRoundData(),
      feed.decimals()
    ]);

    const price = Number(roundData.answer) / Math.pow(10, Number(decimals));
    collateralPriceCache.set(collateralAddress.toLowerCase(), { price, timestamp: Date.now() });
    return price;
  } catch (e) {
    console.warn('Failed to fetch collateral price:', e);
    return null;
  }
}

// Minimum amounts in ETH terms (converted to collateral equivalent)
const MIN_ETH = {
  LIQUIDITY: 0.01,      // Min total liquidity for market creation
  ORDER: 0.005,         // Min order size
  LP_ADD: 0.01,         // Min LP addition
  DUST: 0.0001          // Dust threshold
};

// Liquidity presets in ETH terms
const LIQUIDITY_PRESETS_ETH = [0.01, 0.1, 0.5, 1];

// Get cached collateral price (sync, returns null if not cached)
function getCachedCollateralPrice(collateralAddress) {
  if (!collateralAddress || collateralAddress === ethers.ZeroAddress) return 1;
  const cached = collateralPriceCache.get(collateralAddress.toLowerCase());
  return cached?.price ?? null;
}

// Convert ETH amount to collateral equivalent (uses cached price, falls back to 1:1)
function ethToCollateral(ethAmount, collateralAddress) {
  const priceInETH = getCachedCollateralPrice(collateralAddress);
  if (!priceInETH || priceInETH <= 0) return ethAmount; // 1:1 fallback
  return ethAmount / priceInETH;
}

// Convert collateral amount to ETH equivalent
function collateralToETH(collateralAmount, collateralAddress) {
  const priceInETH = getCachedCollateralPrice(collateralAddress);
  if (!priceInETH || priceInETH <= 0) return collateralAmount; // 1:1 fallback
  return collateralAmount * priceInETH;
}

// Format collateral amount with appropriate precision
function formatCollateralAmount(amount, decimals = 4) {
  if (amount < 0.0001) return amount.toFixed(6);
  if (amount < 0.01) return amount.toFixed(4);
  if (amount < 1) return amount.toFixed(decimals);
  return amount.toFixed(2);
}

// Get token logo SVG by address, returns empty string if not found
function getTokenLogo(address) {
  if (!address) return '';
  return TOKEN_LOGOS[address.toLowerCase()] || '';
}

// Get collateral logo SVG - handles ETH (zero address) specially
function getCollateralLogo(collateralAddress) {
  if (!collateralAddress || collateralAddress === ethers.ZeroAddress) {
    return TOKEN_LOGOS['eth'] || '';
  }
  return getTokenLogo(collateralAddress);
}

// Known contract addresses - maps address (lowercase) to human-readable name and optional color
// UNI logo SVG (official unicorn) for Uniswap-related contracts
const UNI_LOGO_SMALL = `<svg width="14" height="14" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg" style="vertical-align:middle;margin-right:3px"><circle fill="#FF007A" cx="16" cy="16" r="16"/><g fill="#FFF"><path d="M12.261 5.767c-.285-.044-.297-.05-.163-.07.257-.04.865.015 1.284.114.977.233 1.866.828 2.816 1.885l.252.28.36-.057c1.52-.245 3.067-.05 4.36.547.356.164.917.491.987.576.023.026.064.199.091.383.096.637.048 1.125-.146 1.49-.106.198-.112.26-.041.43a.416.416 0 00.372.236c.322 0 .668-.52.828-1.243l.064-.287.126.143c.692.784 1.235 1.853 1.328 2.613l.025.199-.117-.18c-.2-.31-.4-.522-.658-.693-.464-.307-.955-.411-2.255-.48-1.174-.062-1.839-.162-2.497-.377-1.121-.365-1.686-.852-3.018-2.599-.591-.776-.957-1.205-1.32-1.55-.827-.786-1.639-1.198-2.678-1.36z"/><path d="M22.422 7.5c.03-.52.1-.863.242-1.176.056-.124.109-.226.117-.226a.773.773 0 01-.055.204c-.103.304-.12.72-.049 1.203.09.614.142.702.79 1.365.305.311.659.703.787.872l.233.306-.233-.219c-.285-.267-.941-.79-1.086-.864-.097-.05-.112-.049-.172.01-.055.056-.067.138-.074.529-.012.608-.095 1-.296 1.39-.108.21-.125.166-.027-.073.073-.178.08-.256.08-.845 0-1.184-.141-1.468-.966-1.956a9.046 9.046 0 00-.764-.396 2.916 2.916 0 01-.374-.182c.023-.023.827.211 1.15.336.482.185.561.209.62.186.039-.015.058-.129.077-.464zm-9.607 2.025c-.579-.797-.937-2.02-.86-2.934l.024-.283.132.024c.248.045.675.204.875.326.548.333.786.772 1.027 1.898.071.33.164.703.207.83.068.203.328.678.54.987.152.222.05.327-.286.297-.514-.047-1.21-.527-1.659-1.145zm8.905 5.935c-2.707-1.09-3.66-2.036-3.66-3.632 0-.235.008-.427.017-.427.01 0 .115.077.233.172.549.44 1.164.628 2.865.876 1.001.147 1.565.265 2.085.437 1.652.548 2.674 1.66 2.918 3.174.07.44.029 1.265-.086 1.7-.09.344-.367.963-.44.987-.02.006-.04-.071-.046-.178-.028-.568-.315-1.122-.798-1.537-.549-.471-1.286-.847-3.089-1.572zm-1.9.452a4.808 4.808 0 00-.131-.572l-.07-.206.129.144c.177.2.318.454.436.794.091.259.101.336.1.757 0 .414-.011.5-.095.734a2.32 2.32 0 01-.571.908c-.495.504-1.13.782-2.048.898-.16.02-.624.054-1.033.075-1.03.054-1.707.164-2.316.378a.488.488 0 01-.174.042c-.024-.025.39-.272.733-.437.483-.233.963-.36 2.04-.539.532-.089 1.082-.196 1.221-.239 1.318-.404 1.995-1.446 1.778-2.737z"/><path d="M21.06 18.116c-.36-.773-.442-1.52-.245-2.216.021-.074.055-.135.075-.135a.73.73 0 01.189.102c.166.112.498.3 1.383.782 1.105.603 1.735 1.07 2.164 1.602.375.467.607.999.719 1.647.063.367.026 1.25-.068 1.62-.297 1.166-.988 2.082-1.972 2.616a2.53 2.53 0 01-.288.143c-.014 0 .038-.133.117-.297.33-.692.369-1.366.118-2.116-.153-.459-.466-1.02-1.097-1.966-.734-1.1-.914-1.394-1.095-1.782zm-10.167 4.171c1.005-.848 2.254-1.45 3.393-1.635.49-.08 1.308-.048 1.762.068.728.186 1.38.604 1.719 1.101.33.486.473.91.62 1.852.06.372.123.745.142.83.11.488.327.879.595 1.075.425.311 1.158.33 1.878.05a.981.981 0 01.236-.074c.026.026-.336.269-.592.397a2.014 2.014 0 01-.983.238c-.66 0-1.208-.335-1.665-1.02-.09-.135-.292-.538-.45-.897-.482-1.1-.72-1.436-1.28-1.803-.489-.32-1.118-.377-1.591-.145-.622.305-.795 1.1-.35 1.603.177.2.507.373.777.406a.83.83 0 00.939-.83c0-.332-.128-.52-.448-.665-.437-.197-.907.033-.905.444.001.175.077.285.253.365.113.05.115.055.023.036-.401-.084-.495-.567-.172-.888.387-.386 1.188-.216 1.463.31.116.221.129.662.028.928-.225.595-.883.907-1.55.737-.454-.116-.639-.241-1.186-.805-.951-.98-1.32-1.17-2.692-1.384l-.263-.041.3-.253z"/><path d="M6.196 3.35l.096.117c3.708 4.54 5.624 6.896 5.746 7.064.2.278.125.527-.219.723-.191.109-.585.219-.781.219-.223 0-.474-.107-.657-.28-.129-.123-.65-.901-1.853-2.768a188.53 188.53 0 00-1.712-2.633c-.049-.046-.048-.045 1.618 2.936 1.046 1.872 1.4 2.533 1.4 2.622 0 .18-.05.274-.272.522-.37.413-.535.877-.655 1.837-.134 1.077-.51 1.837-1.554 3.138-.61.762-.71.902-.865 1.209-.194.386-.247.603-.269 1.091-.023.516.022.85.18 1.343.138.432.282.718.65 1.288.318.493.501.859.501 1.002 0 .114.022.114.515.003 1.179-.266 2.136-.735 2.675-1.309.333-.355.411-.551.414-1.038.001-.318-.01-.385-.096-.568-.14-.298-.395-.546-.957-.93-.737-.504-1.051-.91-1.138-1.467-.072-.457.011-.78.419-1.634.421-.884.526-1.26.597-2.151.045-.576.108-.803.274-.985.172-.19.328-.255.755-.313.696-.095 1.139-.275 1.503-.61.316-.292.448-.573.468-.995l.016-.32-.177-.206c-.254-.296-2.355-2.614-6.304-6.956l-.106-.115-.212.165zM7.91 19.732a.566.566 0 00-.174-.746c-.228-.152-.583-.08-.583.118 0 .06.033.104.108.143.127.065.136.139.037.288-.101.152-.093.286.023.377.186.146.45.065.59-.18zm5.524-7.176c-.327.1-.644.447-.743.81-.06.221-.026.61.064.73.145.194.286.245.666.242.744-.005 1.39-.324 1.466-.723.062-.327-.223-.78-.614-.98-.202-.102-.631-.143-.839-.079zm.87.68c.115-.163.064-.34-.13-.458-.372-.227-.934-.04-.934.312 0 .174.293.365.561.365.18 0 .424-.107.503-.219z"/></g></svg>`;

const KNOWN_CONTRACTS = {
  // Uniswap V4
  '0x000000000004444c5dc75cb358380d2e3de08a90': { name: 'Uniswap V4 Pool Manager', color: '#FF007A', logo: UNI_LOGO_SMALL },
  // Our contracts
  '0x000000000044bfe6c2bbfed8862973e0612f07c0': { name: 'PAMM', color: '#0FF' },
  '0x000000000000040470635eb91b7ce4d132d616ed': { name: 'ZAMM', color: '#0FF' },
  '0x000000000088ec6ab5ca97a354ce4c57dba5b88a': { name: 'Master Router', color: '#0FF' },
};

// Helper to create clickable Etherscan links for addresses
// type: 'address' (default), 'token' for token contracts
function etherscanLink(addr, opts = {}) {
  const { color = '#627EEA', type = 'address', forceShort = false } = opts;
  const lowerAddr = addr.toLowerCase();

  // Look up friendly name from various registries
  let displayName = null;
  if (!forceShort) {
    displayName = ACCOUNT_NAMES[lowerAddr] || TOKEN_NAMES[lowerAddr] || KNOWN_CONTRACTS[lowerAddr]?.name;
  }

  // Fallback to shortened address
  if (!displayName) {
    displayName = `${addr.slice(0,6)}...${addr.slice(-4)}`;
  }

  // Get logo if available
  const logo = TOKEN_LOGOS[lowerAddr] || KNOWN_CONTRACTS[lowerAddr]?.logo || '';

  // Build URL based on type
  const baseUrl = 'https://etherscan.io';
  const url = type === 'token' ? `${baseUrl}/token/${addr}` : `${baseUrl}/address/${addr}`;

  return `<a href="${url}" target="_blank" rel="noopener" style="color:inherit;text-decoration:underline;text-decoration-color:${color}" title="${addr}">${logo}${displayName}</a>`;
}

// Get known contract info by address
function getKnownContract(address) {
  if (!address) return null;
  return KNOWN_CONTRACTS[address.toLowerCase()] || null;
}

// Check if address is a known Chainlink feed
function isChainlinkFeed(address) {
  if (!address) return false;
  return CHAINLINK_FEEDS.has(address.toLowerCase());
}

// Check if market uses our labeling convention (PRICE|, GAS|, TOKBAL|, NFTBAL|, ETHBAL|)
// or uniPM market patterns (V4 Protocol, UNI balance, UNI voting power, etc.)
// Markets with our labels have the full infrastructure (vault, bid pools, etc)
// Legacy/external markets only have PAMM AMM liquidity with 30 bps fee
function isOurLabeledMarket(description) {
  if (!description) return false;
  // ethPM patterns
  if (description.startsWith('PRICE|') ||
      description.startsWith('GAS|') ||
      description.startsWith('TOKBAL|') ||
      description.startsWith('NFTBAL|') ||
      description.startsWith('ETHBAL|')) {
    return true;
  }
  // uniPM patterns (use PM_FEE_HOOK infrastructure)
  if (description.startsWith('V4 Protocol') ||
      description.startsWith('UNI balance') ||
      description.startsWith('UNI voting power') ||
      description.startsWith('UNI totalSupply') ||
      description.startsWith('UNI price')) {
    return true;
  }
  // zOrgz mint market
  if (description.startsWith('zOrgz')) return true;
  return false;
}

// ======================== LOCAL AMM QUOTE FUNCTIONS ========================
// Constant product AMM math for direct PAMM/ZAMM trading fallback
// Used for legacy/external markets without vault infrastructure

const LEGACY_FEE_BPS = 30; // 0.3% fee for legacy markets

// Constants for poolId calculation
const MAX_UINT256 = (1n << 256n) - 1n;
const FLAG_BEFORE = 1n << 255n;
const FLAG_AFTER = 1n << 254n;

// Calculate ZAMM poolId from marketId for hooked pools
// PoolKey = {id0, id1, token0, token1, feeOrHook} where:
// - id0/id1 = ordered(marketId, noId) where noId = keccak256("PMARKET:NO", marketId)
// - token0 = token1 = PAMM address
// - feeOrHook = hookAddress | FLAG_BEFORE | FLAG_AFTER
function calculatePoolId(marketId, isHooked = true) {
  // Check cache first (poolId is deterministic and expensive to compute)
  const cacheKey = `${marketId}-${isHooked}`;
  if (poolIdCache.has(cacheKey)) {
    return poolIdCache.get(cacheKey);
  }

  const marketIdBig = BigInt(marketId);
  // noId = keccak256(abi.encodePacked("PMARKET:NO", marketId)) - matches PAMM.getNoId()
  const noId = BigInt(ethers.keccak256(ethers.solidityPacked(['string', 'uint256'], ['PMARKET:NO', marketIdBig])));
  const [id0, id1] = marketIdBig < noId ? [marketIdBig, noId] : [noId, marketIdBig];

  let feeOrHook;
  if (isHooked) {
    feeOrHook = BigInt(CONTRACTS.PM_FEE_HOOK) | FLAG_BEFORE | FLAG_AFTER;
  } else {
    feeOrHook = BigInt(LEGACY_FEE_BPS);
  }

  // Manual ABI encoding (5 x 32 bytes)
  const toBytes32 = (val) => {
    let hex = BigInt(val).toString(16);
    if (hex.length > 64) hex = hex.slice(-64);
    return hex.padStart(64, '0');
  };
  const addrToBytes32 = (addr) => addr.slice(2).toLowerCase().padStart(64, '0');

  const encoded = '0x' +
    toBytes32(id0) +
    toBytes32(id1) +
    addrToBytes32(CONTRACTS.PAMM) +
    addrToBytes32(CONTRACTS.PAMM) +
    toBytes32(feeOrHook);

  const poolId = ethers.keccak256(encoded);
  poolIdCache.set(cacheKey, poolId);
  return poolId;
}

// Quote buying YES shares with ETH (constant product formula)
// collateralIn → YES shares out
// Process: mint YES+NO with collateral (1:1, no fee), sell NO to pool for more YES (fee on swap)
function quoteBuyYes(collateralInWei, rYes, rNo, feeBps = LEGACY_FEE_BPS) {
  if (rYes === 0n || rNo === 0n) return 0n;
  // 1. Mint: collateralIn YES + collateralIn NO (1:1, no fee on mint)
  const mintedShares = collateralInWei;
  // 2. Swap NO for YES (fee applied to swap input)
  const feeMultiplier = 10000n - BigInt(feeBps);
  const swapInputWithFee = collateralInWei * feeMultiplier / 10000n;
  const swappedYes = (swapInputWithFee * rYes) / (rNo + swapInputWithFee);
  // 3. Total YES = minted + swapped
  return mintedShares + swappedYes;
}

// Quote buying NO shares with ETH
// Process: mint YES+NO with collateral (1:1, no fee), sell YES to pool for more NO (fee on swap)
function quoteBuyNo(collateralInWei, rYes, rNo, feeBps = LEGACY_FEE_BPS) {
  if (rYes === 0n || rNo === 0n) return 0n;
  // 1. Mint: collateralIn YES + collateralIn NO (1:1, no fee on mint)
  const mintedShares = collateralInWei;
  // 2. Swap YES for NO (fee applied to swap input)
  const feeMultiplier = 10000n - BigInt(feeBps);
  const swapInputWithFee = collateralInWei * feeMultiplier / 10000n;
  const swappedNo = (swapInputWithFee * rNo) / (rYes + swapInputWithFee);
  // 3. Total NO = minted + swapped
  return mintedShares + swappedNo;
}

// Quote selling YES shares for ETH
function quoteSellYes(sharesInWei, rYes, rNo, feeBps = LEGACY_FEE_BPS) {
  if (rYes === 0n || rNo === 0n) return 0n;
  // Sell YES to pool for NO, merge NO+YES → collateral
  const feeMultiplier = 10000n - BigInt(feeBps);
  // noOut = rNo - (rYes * rNo) / (rYes + sharesIn * feeMultiplier)
  const amountInWithFee = sharesInWei * feeMultiplier / 10000n;
  const numerator = amountInWithFee * rNo;
  const denominator = rYes + amountInWithFee;
  const noOut = numerator / denominator;
  // Can redeem min(sharesIn, noOut) for collateral
  return noOut < sharesInWei ? noOut : sharesInWei;
}

// Quote selling NO shares for ETH
function quoteSellNo(sharesInWei, rYes, rNo, feeBps = LEGACY_FEE_BPS) {
  if (rYes === 0n || rNo === 0n) return 0n;
  const feeMultiplier = 10000n - BigInt(feeBps);
  const amountInWithFee = sharesInWei * feeMultiplier / 10000n;
  const numerator = amountInWithFee * rYes;
  const denominator = rNo + amountInWithFee;
  const yesOut = numerator / denominator;
  return yesOut < sharesInWei ? yesOut : sharesInWei;
}

// Get effective price impact for a given trade size
function getAmmPriceImpact(inputWei, rIn, rOut, feeBps = LEGACY_FEE_BPS) {
  if (rIn === 0n || rOut === 0n) return 0;
  const feeMultiplier = 10000n - BigInt(feeBps);
  const amountInWithFee = inputWei * feeMultiplier / 10000n;
  // spotPrice before = rOut / rIn
  // effective price = output / input
  const output = amountInWithFee * rOut / (rIn + amountInWithFee);
  const spotBefore = Number(rOut) / Number(rIn);
  const effectivePrice = Number(output) / Number(inputWei);
  const impact = ((spotBefore - effectivePrice) / spotBefore) * 100;
  return Math.max(0, impact);
}

// Wallet state
let provider = null;
let signer = null;
let connectedAddress = null;
let connectedWalletProvider = null;
let walletConnectProvider = null;
let isConnecting = false;
const eip6963Providers = new Map();

// Set up EIP-6963 listener immediately to catch early wallet announcements
if (typeof window !== 'undefined') {
  window.addEventListener('eip6963:announceProvider', (event) => {
    try {
      const { info, provider } = event.detail || {};
      if (info?.uuid && provider) {
        eip6963Providers.set(info.uuid, { info, provider });
      }
    } catch (e) {
      console.warn('EIP-6963 announce error:', e);
    }
  });
  // Request providers now (wallets that already announced will re-announce)
  window.dispatchEvent(new Event('eip6963:requestProvider'));
}

// WNS reverse resolution
const WEINS = "0x0000000000696760E15f265e828DB644A0c242EB";
const WEINS_ABI = ["function reverseResolve(address) view returns (string)"];

function resolveWeiName(addr) {
  getRpc().then(rpc => {
    const ns = new ethers.Contract(WEINS, WEINS_ABI, rpc);
    ns.reverseResolve(addr).then(name => {
      if (name && connectedAddress === addr) $('wallet').textContent = name.toLowerCase();
    }).catch(() => {});
  }).catch(() => {});
}

// RPC provider for read-only calls with fallbacks
const RPC_ENDPOINTS = [
  'https://eth.llamarpc.com',
  'https://ethereum.publicnode.com',
  'https://1rpc.io/eth',
  'https://eth.drpc.org'
];
let rpcProvider = null;

// Mainnet network config - pass explicitly to skip auto-detection (prevents hanging)
const MAINNET = ethers.Network.from(1);

// Helper: wrap promise with timeout
function withTimeout(promise, ms, errorMsg = 'Timeout') {
  return Promise.race([
    promise,
    new Promise((_, reject) => setTimeout(() => reject(new Error(errorMsg)), ms))
  ]);
}

// Race all RPCs in parallel - first successful response wins
async function getRpc() {
  if (rpcProvider) return rpcProvider;

  // Race all RPCs - first to respond with valid block number wins
  // Pass network explicitly + staticNetwork to skip auto-detection (prevents "retry in 1s" hangs)
  // 5 second timeout per RPC to prevent indefinite hangs
  const racePromises = RPC_ENDPOINTS.map(async (rpc) => {
    const p = new ethers.JsonRpcProvider(rpc, MAINNET, { staticNetwork: true });
    await withTimeout(p.getBlockNumber(), 5000, `RPC timeout: ${rpc}`);
    return { provider: p, rpc };
  });

  try {
    // Promise.any resolves with first successful promise
    const winner = await Promise.any(racePromises);
    rpcProvider = winner.provider;
    return rpcProvider;
  } catch (e) {
    // All failed - try sequential as fallback with longer timeout
    for (const rpc of RPC_ENDPOINTS) {
      try {
        const p = new ethers.JsonRpcProvider(rpc, MAINNET, { staticNetwork: true });
        await withTimeout(p.getBlockNumber(), 8000, `RPC timeout: ${rpc}`);
        rpcProvider = p;
        return rpcProvider;
      } catch (e2) {
        console.warn(`RPC ${rpc} failed:`, e2.message);
      }
    }
    throw new Error('All RPC endpoints failed');
  }
}

// Multicall3 for batching read calls
const MULTICALL3_ADDRESS = '0xcA11bde05977b3631167028862bE2a173976CA11';
const MULTICALL3_ABI = [
  'function aggregate3(tuple(address target, bool allowFailure, bytes callData)[] calls) view returns (tuple(bool success, bytes returnData)[])'
];

// Batch multiple contract calls into single RPC request
async function multicall(calls, rpc) {
  if (!calls.length) return [];
  const multicall3 = new ethers.Contract(MULTICALL3_ADDRESS, MULTICALL3_ABI, rpc);
  const callData = calls.map(c => ({
    target: c.target,
    allowFailure: true,
    callData: c.callData
  }));
  const results = await multicall3.aggregate3(callData);
  return results.map((r, i) => ({
    success: r.success,
    data: r.returnData,
    decode: () => calls[i].decode(r.returnData)
  }));
}

const WALLET_CONFIG = {
  metamask: { name: 'MetaMask', icon: '🦊', detect: () => window.ethereum?.isMetaMask, getProvider: () => window.ethereum },
  coinbase: { name: 'Coinbase', icon: '🔵', detect: () => window.ethereum?.isCoinbaseWallet, getProvider: () => window.ethereum },
  rabby: { name: 'Rabby', icon: '🐰', detect: () => window.ethereum?.isRabby, getProvider: () => window.ethereum },
  rainbow: { name: 'Rainbow', icon: '🌈', detect: () => window.ethereum?.isRainbow, getProvider: () => window.ethereum },
  walletconnect: { name: 'WalletConnect', icon: '📱' }
};

const $ = id => document.getElementById(id);

// ======================== TOAST NOTIFICATIONS ========================
let toastTimeout = null;

function showToast(message, type = '', duration = 5000, link = null) {
  const toast = $('toast');
  if (!toast) return;

  // Clear any existing timeout
  if (toastTimeout) clearTimeout(toastTimeout);

  // Build toast content
  let html = `<span>${message}</span>`;
  if (link) {
    html += ` <a href="${link}" target="_blank" rel="noopener">View on Etherscan →</a>`;
  }
  html += `<span class="toast-close" onclick="hideToast()">×</span>`;

  toast.innerHTML = html;

  // Update type class while preserving 'show' state
  toast.classList.remove('pending', 'success', 'error');
  if (type) toast.classList.add(type);

  // Ensure toast is visible
  if (!toast.classList.contains('show')) {
    requestAnimationFrame(() => {
      toast.classList.add('show');
    });
  }

  // Auto-hide after duration (0 = don't auto-hide)
  if (duration > 0) {
    toastTimeout = setTimeout(hideToast, duration);
  }
}

function hideToast() {
  const toast = $('toast');
  if (toast) {
    toast.classList.remove('show');
  }
  if (toastTimeout) {
    clearTimeout(toastTimeout);
    toastTimeout = null;
  }
}

function showTxPending(hash) {
  const etherscanUrl = `https://etherscan.io/tx/${hash}`;
  showToast('Transaction pending...', 'pending', 0, etherscanUrl);
}

function showTxSuccess(message, hash) {
  const etherscanUrl = `https://etherscan.io/tx/${hash}`;
  showToast(message, 'success', 8000, etherscanUrl);
}

function showTxError(message) {
  showToast(message, 'error', 6000);
}

// ======================== INIT ========================
async function init() {
  if (dark) { document.documentElement.dataset.theme = 'dark'; $('theme').textContent = 'light'; }
  initEIP6963();
  handleDeepLink();

  // Show loading state
  $('q').innerHTML = 'Loading markets...';
  $('meta').textContent = 'scanning blockchain for prediction markets';

  // Auto-reconnect wallet
  const savedWallet = localStorage.getItem('ethpm_wallet');
  if (savedWallet) {
    setTimeout(() => connectWithWallet(savedWallet).catch(() => localStorage.removeItem('ethpm_wallet')), 100);
  }

  // Load markets and render
  await loadMarkets();
  render();
  startCountdownTimer();
  startAutoRefresh();
  loadAllMarketData(); // Combined loader for positions, resolution, and price chart

  // Handle gallery deep link after markets load
  if (window.deepLinkGallery) {
    const filter = window.deepLinkGallery;
    window.deepLinkGallery = null;
    showGallery();
    if (filter !== 'open') {
      setGalleryStatus(filter);
    }
  }
}

// ======================== DEEP LINKING ========================
function handleDeepLink() {
  const path = window.location.pathname;
  const hash = window.location.hash;

  // Support #MARKET_ID (preferred) or /MARKET_ID
  let hashValue = null;
  // Check hash first (canonical format from getMarketUrl)
  if (hash && hash.length > 1) {
    hashValue = hash.slice(1);
  } else if (path && path.length > 1) {
    // Path-based deep link (e.g., /81821321)
    hashValue = path.slice(1);
  }

  if (!hashValue) return;

  // Gallery deep links: #browse, #browse/resolved, #browse/all, #browse/open
  if (hashValue === 'browse' || hashValue === 'gallery') {
    window.deepLinkGallery = 'open';
  } else if (hashValue.startsWith('browse/') || hashValue.startsWith('gallery/')) {
    const filter = hashValue.split('/')[1];
    if (['open', 'resolved', 'all'].includes(filter)) {
      window.deepLinkGallery = filter;
    } else {
      window.deepLinkGallery = 'open';
    }
  } else if (/^[0-9]+$/.test(hashValue)) {
    // Market ID deep link
    window.deepLinkMarketId = hashValue;
  }
}

function getMarketUrl(marketId) {
  // Use current URL without hash, then append market ID hash
  return `${window.location.href.split('#')[0]}#${marketId}`;
}

function getGalleryUrl(filter = 'open') {
  const base = window.location.href.split('#')[0];
  return filter === 'open' ? `${base}#browse` : `${base}#browse/${filter}`;
}

// Handle browser back/forward navigation
window.addEventListener('hashchange', async () => {
  const hash = window.location.hash;
  if (!hash || hash.length <= 1) {
    // No hash - close gallery if open
    if ($('marketGallery').classList.contains('active')) {
      closeGallery();
    }
    return;
  }

  const hashValue = hash.slice(1);

  // Gallery links: #browse, #browse/resolved, etc.
  if (hashValue === 'browse' || hashValue === 'gallery') {
    showGallery();
    return;
  }
  if (hashValue.startsWith('browse/') || hashValue.startsWith('gallery/')) {
    const filter = hashValue.split('/')[1];
    showGallery();
    if (['open', 'resolved', 'all'].includes(filter)) {
      setGalleryStatus(filter);
    }
    return;
  }

  // Market ID links
  if (/^[0-9]+$/.test(hashValue)) {
    const idx = markets.findIndex(m => m.marketId === hashValue);
    if (idx >= 0) {
      currentIndex = idx;
      closeGallery();
      closeDrop();
      resetResolvePanel();
      render();
      await loadAllMarketData();
    } else {
      // Market not in list, try to load it
      closeGallery();
      await loadMarketById(hashValue);
      await loadAllMarketData();
    }
  }
});

function shareMarket() {
  const m = markets[currentIndex];
  if (!m?.marketId) return;
  const url = getMarketUrl(m.marketId);
  navigator.clipboard.writeText(url).then(() => {
    const btn = document.getElementById('shareBtn');
    if (btn) {
      btn.textContent = '\u2713';
      setTimeout(() => btn.innerHTML = '&#128279;', 1500);
    }
  });
}

function shareGallery() {
  const url = getGalleryUrl(galleryStatus);
  navigator.clipboard.writeText(url).then(() => {
    showToast('Gallery link copied!', 'success', 2000);
  });
}

// ENS reverse lookup with caching
async function lookupENS(address) {
  if (!address) return null;
  const key = address.toLowerCase();

  // Check cache first
  if (ensCache.has(key)) return ensCache.get(key);

  // Mark as pending to avoid duplicate lookups
  cacheSet(ensCache, key, null, MAX_ENS_CACHE);

  try {
    const rpc = provider || await getRpc();
    const name = await rpc.lookupAddress(address);
    cacheSet(ensCache, key, name, MAX_ENS_CACHE);
    return name;
  } catch (e) {
    // ENS lookup failed, leave as null
    return null;
  }
}

// Format address with optional ENS and Etherscan link
function formatAddressLink(address, ensName = null) {
  const short = `${address.slice(0,6)}...${address.slice(-4)}`;
  const display = ensName || short;
  return `<a href="https://etherscan.io/address/${address}" target="_blank" rel="noopener" style="opacity:0.6">${display}</a>`;
}

// ======================== MARKET LOADING ========================
function formatQuestion(threshold, close) {
  const price = threshold >= 1000 ? `$${(threshold/1000).toFixed(0)}K` : `$${threshold}`;
  const date = new Date(close * 1000);
  const dateStr = date.toLocaleDateString('en-US', { year: 'numeric', month: 'short' });
  return `WILL <u style="text-decoration-color:#627EEA">ETH</u> HIT <u style="text-decoration-color:#0F0">${price}</u> BY <u style="text-decoration-color:#F50">${dateStr}</u>?`;
}

// localStorage cache keys
const CACHE_MARKETS_KEY = 'ethpm_markets';
const CACHE_VERSION = 13; // Bump to invalidate cache (v13: cleanup debug logs)

// Load cached markets from localStorage
function loadCachedMarkets() {
  try {
    const cached = localStorage.getItem(CACHE_MARKETS_KEY);
    if (!cached) return { markets: [], timestamp: 0 };
    const data = JSON.parse(cached);
    if (data.version !== CACHE_VERSION) return { markets: [], timestamp: 0 };
    return { markets: data.markets || [], timestamp: data.timestamp || 0 };
  } catch (e) {
    return { markets: [], timestamp: 0 };
  }
}

// Save markets to localStorage
function cacheMarkets(marketList) {
  try {
    localStorage.setItem(CACHE_MARKETS_KEY, JSON.stringify({
      version: CACHE_VERSION,
      markets: marketList,
      timestamp: Date.now()
    }));
  } catch (e) {
    console.warn('Failed to cache markets:', e);
  }
}

async function loadMarkets() {
  try {
    const rpc = await getRpc();
    const pamm = new ethers.Contract(CONTRACTS.PAMM, PAMM_ABI, rpc);

    // 1. Load from cache first for instant display
    const { markets: cachedMarkets, timestamp: cacheTime } = loadCachedMarkets();

    // Sort cached markets same way as fresh: active first, then by ETH-equivalent TVL
    const now = Math.floor(Date.now() / 1000);
    cachedMarkets.sort((a, b) => {
      const aActive = !a.resolved && a.close > now;
      const bActive = !b.resolved && b.close > now;
      if (aActive && !bActive) return -1;
      if (!aActive && bActive) return 1;
      // Then by ETH-equivalent TVL (highest first), falling back to raw TVL
      return (b.ethTvl || b.tvl || 0) - (a.ethTvl || a.tvl || 0);
    });

    // Restore oddsLoaded flag from cached odds (v7+)
    for (const m of cachedMarkets) {
      if (typeof m.y === 'number' && m.y !== 50) {
        m.oddsLoaded = true; // Has real cached odds
      }
    }

    // Store all markets for gallery (including resolved)
    allMarkets = cachedMarkets;
    // Filter to active markets for main navigation
    markets = cachedMarkets.filter(m => !m.resolved && m.close > now);

    // If we have cached markets, show them immediately
    if (cachedMarkets.length > 0) {
      render();
    }

    // Handle deep link with cached markets
    if (window.deepLinkMarketId && cachedMarkets.length > 0) {
      const idx = markets.findIndex(m => m.marketId === window.deepLinkMarketId);
      if (idx > 0) {
        // Found in cache - move to front
        const [market] = markets.splice(idx, 1);
        markets.unshift(market);
        currentIndex = 0;
        render(); // Re-render with deep linked market
      } else if (idx === -1) {
        // Not in cache - load directly (loadMarketById handles render)
        await loadMarketById(window.deepLinkMarketId);
      } else if (idx === 0) {
        // Already at front, just ensure currentIndex is 0 and render
        currentIndex = 0;
        render();
      }
      window.deepLinkMarketId = null; // Clear after handling
    }

    // 2. Skip refresh if cache is less than 1 minute old (unless no cache)
    const cacheAge = Date.now() - cacheTime;
    if (cachedMarkets.length > 0 && cacheAge < 60000) {
      return;
    }

    // 3. Try to fetch all markets in one batch call
    let allFetched = [];
    let fetchSuccess = false;

    try {
      const PAGE_SIZE = 50;
      let start = 0;

      // Paginate through all markets from PAMM.getMarkets
      while (true) {
        let result;
        try {
          result = await pamm.getMarkets(start, PAGE_SIZE, { gasLimit: 5000000 });
        } catch (pageErr) {
          // Pagination complete - contract reverted (no more data)
          break;
        }

        const batchSize = result.marketIds.length;

        // Empty batch means we've reached the end
        if (batchSize === 0) break;

        // Process this batch
        for (let i = 0; i < batchSize; i++) {
          const resolver = result.resolvers[i];
          // Filter for our Resolver only
          if (resolver.toLowerCase() !== CONTRACTS.RESOLVER.toLowerCase()) continue;

          const marketId = result.marketIds[i].toString();
          const description = result.descs[i];
          const close = Number(result.closes[i]);
          const yesSupply = result.yesSupplies[i];
          const noSupply = result.noSupplies[i];
          const tvl = Number(result.collateralAmounts[i]) / 1e18;
          const states = Number(result.states[i]);
          const resolved = (states & 1) !== 0;
          const outcome = (states & 2) !== 0;

          const parsed = parseMarketDescription(description);
          // Note: yesSupply/noSupply are share supplies, NOT AMM reserves.
          // For constant-product AMM, supplies stay balanced - price comes from reserves.
          // Don't calculate odds here; mark oddsLoaded=false so gallery fetches real AMM price.

          allFetched.push({
            id: marketId.slice(-6),
            marketId: marketId,
            q: parsed.question,
            c: parsed.color,
            logo: parsed.logo,
            y: 50, // Placeholder - real odds loaded via getMarketSummary
            oddsLoaded: false, // Will be set true after fetching AMM spot price
            close: close,
            resolved: resolved,
            outcome: outcome,
            threshold: parsed.threshold,
            tvl: tvl,
            description: description,
            resolver: resolver,
            collateral: result.collaterals[i]
          });
        }

        // Check if more pages - stop if partial batch (definitely last page)
        // or if next is 0 (contract signals no more data)
        if (batchSize < PAGE_SIZE) break;
        const next = Number(result.next);
        if (next === 0) break;
        start = next;
      }

      fetchSuccess = true;

      // Inject legacy markets (external markets with different resolvers)
      for (const legacy of LEGACY_MARKETS) {
        // Skip if already in list
        if (allFetched.find(m => m.marketId === legacy.marketId)) continue;

        try {
          // Fetch pool state for legacy market to get TVL
          const poolState = await pamm.getPoolState(BigInt(legacy.marketId), LEGACY_FEE_BPS);
          const rYes = Number(poolState.rYes) / 1e18;
          const rNo = Number(poolState.rNo) / 1e18;
          const tvl = rYes + rNo; // Total liquidity in pool
          const total = rYes + rNo;
          const yPct = total > 0 ? Math.round((rNo / total) * 100) : 50;

          // Fetch market state (includes on-chain description)
          const marketData = await pamm.getMarket(BigInt(legacy.marketId));
          const onChainDesc = marketData.description || '';

          // Try to query resolver for condition info to build better question
          let parsed = { question: onChainDesc, color: '#888', logo: '?', threshold: 0, raw: onChainDesc };
          try {
            // Use legacy resolver ABI (different conditions return format)
            const resolverContract = new ethers.Contract(marketData.resolver, LEGACY_RESOLVER_ABI, rpc);
            const [previewResult, condData] = await Promise.all([
              resolverContract.preview(BigInt(legacy.marketId)),
              resolverContract.conditions(BigInt(legacy.marketId))
            ]);
            const [value, condTrue, ready] = previewResult;
            const oracleAddr = condData.targetA;
            // Normalize callData to hex string (ethers v6 may return different types)
            let callData = condData.callDataA;
            if (callData && typeof callData !== 'string') {
              callData = ethers.hexlify(callData);
            }
            callData = callData || '';
            const opNames = ['<', '>', '≤', '≥', '=', '≠'];
            const opName = opNames[Number(condData.op)] || '?';

            // Detect market type from condition data
            // Standard ERC20 balance: targetA = token, callDataA = balanceOf(account)
            // Legacy ERC20 balance: targetA = token, targetB = account, callDataA = balanceOf(account) OR empty
            // ETH balance: targetA = account, callDataA = empty
            const callDataLower = callData.toLowerCase();
            const isBalanceOfCall = callData.length >= 74 && callDataLower.slice(0, 10) === '0x70a08231';

            let tokenSymbol = '';
            let decimals = 18;
            let accountAddr = '';
            let tokenAddr = '';

            // Check if oracleAddr is a token contract by trying to get its symbol
            let oracleIsToken = false;
            try {
              const testContract = new ethers.Contract(oracleAddr, ['function symbol() view returns (string)'], rpc);
              const sym = await testContract.symbol().catch(() => null);
              if (sym && sym.length > 0 && sym.length <= 10) {
                oracleIsToken = true;
                tokenSymbol = sym;
                tokenAddr = oracleAddr;
              }
            } catch (e) {}

            if (isBalanceOfCall) {
              // Standard ERC20: account is in callData (balanceOf(account))
              accountAddr = '0x' + callDataLower.slice(34, 74);
              if (!tokenAddr) tokenAddr = oracleAddr;
            } else if (oracleIsToken && condData.targetB && condData.targetB !== ethers.ZeroAddress) {
              // Legacy format: targetA = token, targetB = account
              accountAddr = condData.targetB;
            } else if (!oracleIsToken) {
              // ETH balance: oracleAddr is the account
              accountAddr = oracleAddr;
              tokenSymbol = 'ETH';
            } else {
              // Token but no account found - try to parse description for known entities

              // Try to create a formatted question from the description
              // Pattern: "Will the [account] accumulate X million [token] tokens by [date]?"
              const descMatch = onChainDesc.match(/Will the (.+?) accumulate ([\d,]+(?:\.\d+)?)\s*(million\s+)?(\w+) tokens? by (.+?)\?/i);
              if (descMatch && tokenSymbol) {
                const [, accountName, amountNum, millionStr, tokenName, dateStr] = descMatch;
                const color = COLORS[tokenSymbol.toUpperCase()] || '#375BD2';
                const tokenLogo = getTokenLogo(tokenAddr);

                // Look up account address from known names
                const accountNameLower = accountName.toLowerCase();
                let accountAddress = '';
                for (const [addr, name] of Object.entries(ACCOUNT_NAMES)) {
                  if (name.toLowerCase() === accountNameLower || name.toLowerCase().includes(accountNameLower)) {
                    accountAddress = addr;
                    break;
                  }
                }

                // Format amount - check if "million" was in the original text
                const amount = millionStr ? `${amountNum}M` : amountNum;

                // Build linked display
                const accountLink = accountAddress
                  ? `<a href="https://etherscan.io/address/${accountAddress}" target="_blank" rel="noopener" style="color:inherit;text-decoration:underline;text-decoration-color:${color}" title="${accountAddress}">${accountName}</a>`
                  : `<span style="text-decoration:underline;text-decoration-color:${color}">${accountName}</span>`;
                const tokenLink = `<a href="https://etherscan.io/token/${tokenAddr}" target="_blank" rel="noopener" style="color:inherit;text-decoration:underline;text-decoration-color:${color}" title="${tokenAddr}">${tokenLogo}${tokenSymbol}</a>`;

                parsed = {
                  question: `${accountLink} accumulate <u style="text-decoration-color:#0F0">${amount}</u> ${tokenLink} by <u style="text-decoration-color:#F50">${dateStr}</u>?`,
                  color: color,
                  logo: tokenSymbol.toLowerCase(),
                  threshold: 0,
                  raw: onChainDesc
                };
              } else {
                parsed = parseMarketDescription(onChainDesc);
              }
            }

            // Get token decimals if we have a token address
            if (tokenAddr) {
              try {
                const tokenContract = new ethers.Contract(tokenAddr, ['function decimals() view returns (uint8)'], rpc);
                decimals = Number(await tokenContract.decimals().catch(() => 18));
              } catch (e) {
                decimals = 18;
              }
            }

            if (tokenSymbol && accountAddr) {
              const accountAddrLower = accountAddr.toLowerCase();
              const accountName = ACCOUNT_NAMES[accountAddrLower] || `${accountAddr.slice(0,6)}...${accountAddr.slice(-4)}`;
              const thresholdFormatted = Number(condData.threshold) / Math.pow(10, decimals);
              const valueFormatted = Number(value) / Math.pow(10, decimals);
              const formatVal = (v) => v >= 1e6 ? (v/1e6).toFixed(2)+'M' : v >= 1e3 ? (v/1e3).toFixed(2)+'K' : v.toFixed(2);

              const color = COLORS[tokenSymbol.toUpperCase()] || '#375BD2';
              const tokenLogo = tokenAddr ? getTokenLogo(tokenAddr) : TOKEN_LOGOS['eth'];
              const conditionVerb = Number(condData.op) >= 2 ? 'reaches' : 'falls below';

              // Calculate progress
              const progressPct = thresholdFormatted > 0 ? Math.min(100, (valueFormatted / thresholdFormatted) * 100) : 0;
              const progressBlocks = Math.round(progressPct / 5);
              const progressBar = '█'.repeat(progressBlocks) + '░'.repeat(20 - progressBlocks);

              // Build linked account and token displays
              const accountLink = `<a href="https://etherscan.io/address/${accountAddr}" target="_blank" rel="noopener" style="color:inherit;text-decoration:underline;text-decoration-color:${color}" title="${accountAddr}">${accountName}</a>`;
              const tokenLink = `<a href="https://etherscan.io/token/${tokenAddr}" target="_blank" rel="noopener" style="color:inherit;text-decoration:underline;text-decoration-color:${color}" title="${tokenAddr}">${tokenLogo}${tokenSymbol}</a>`;

              parsed = {
                question: `${accountLink} <span style="opacity:0.5">bal on</span> ${tokenLink}<br>${conditionVerb} ${opName} <u style="text-decoration-color:#0F0">${formatVal(thresholdFormatted)} ${tokenSymbol}</u>`,
                color: color,
                logo: tokenSymbol.toLowerCase(),
                threshold: thresholdFormatted,
                raw: onChainDesc,
                currentValue: valueFormatted,
                progressPct: progressPct,
                progressBar: progressBar,
                condTrue: condTrue,
                ready: ready
              };
            }
          } catch (e) {
            console.warn('Failed to query legacy resolver for market display:', e.message);
            parsed = parseMarketDescription(onChainDesc);
          }
          allFetched.push({
            id: legacy.marketId.slice(-6),
            marketId: legacy.marketId,
            q: parsed.question,
            c: parsed.color,
            logo: parsed.logo,
            y: yPct,
            oddsLoaded: true,
            close: Number(marketData.close) || legacy.close,
            resolved: marketData.resolved,
            outcome: marketData.outcome,
            threshold: parsed.threshold,
            tvl: tvl,
            description: onChainDesc,
            resolver: marketData.resolver,
            collateral: marketData.collateral,
            isLegacy: true,
            legacyPoolId: legacy.poolId
          });
        } catch (e) {
          console.warn('Failed to inject legacy market:', legacy.marketId.slice(0,8), e.message);
        }
      }
    } catch (fetchErr) {
      console.warn('getMarkets failed, using cache:', fetchErr.message);
      // Keep using cached markets, don't update
    }

    if (fetchSuccess) {
      // Compute ETH-equivalent TVL for sorting
      // Get unique collateral addresses
      const uniqueCollaterals = [...new Set(allFetched.map(m => m.collateral?.toLowerCase()).filter(Boolean))];

      // Fetch prices for all collaterals (in parallel)
      const pricePromises = uniqueCollaterals.map(async addr => {
        const price = await getCollateralPriceInETH(addr);
        return [addr, price];
      });
      const priceResults = await Promise.all(pricePromises);
      const priceMap = new Map(priceResults);

      // Helper to compute ethTvl
      const computeEthTvl = (m) => {
        const collateralAddr = m.collateral?.toLowerCase();
        const price = collateralAddr ? (priceMap.get(collateralAddr) ?? 1) : 1;
        const totalCollateral = (m.tvl || 0) + (m.bidPoolCollateral || 0);
        return totalCollateral * price;
      };

      // Helper to sort markets
      const sortMarkets = (list) => {
        const now = Math.floor(Date.now() / 1000);
        list.sort((a, b) => {
          const aActive = !a.resolved && a.close > now;
          const bActive = !b.resolved && b.close > now;
          if (aActive && !bActive) return -1;
          if (!aActive && bActive) return 1;
          return (b.ethTvl || 0) - (a.ethTvl || 0);
        });
      };

      // Phase 1: Quick initial sort with AMM TVL only
      for (const m of allFetched) {
        m.ethTvl = computeEthTvl(m);
      }
      sortMarkets(allFetched);

      // Update markets lists
      const nowTs = Math.floor(Date.now() / 1000);
      allMarkets = allFetched; // All markets for gallery
      markets = allFetched.filter(m => !m.resolved && m.close > nowTs); // Active only for navigation
      cacheMarkets(allMarkets); // Cache all markets including resolved
      render();

      // Phase 2: Background fetch bid pool data for labeled markets, then re-sort
      const labeledMarkets = allFetched.filter(m => isOurLabeledMarket(m.description) && !m.resolved);
      if (labeledMarkets.length > 0) {
        (async () => {
          try {
            const rpc = provider || await getRpc();
            const quoter = new ethers.Contract(CONTRACTS.QUOTER, QUOTER_ABI, rpc);

            // Batch fetch bid pool depths for all labeled markets (both sides)
            const bidPoolPromises = labeledMarkets.map(async (m) => {
              try {
                const [yesBreakdown, noBreakdown] = await Promise.all([
                  quoter.getLiquidityBreakdown(m.marketId, true, { gasLimit: 5000000 }).catch(() => null),
                  quoter.getLiquidityBreakdown(m.marketId, false, { gasLimit: 5000000 }).catch(() => null)
                ]);
                const yesBid = yesBreakdown ? Number(yesBreakdown.poolBidDepth) / 1e18 : 0;
                const noBid = noBreakdown ? Number(noBreakdown.poolBidDepth) / 1e18 : 0;
                m.bidPoolCollateral = yesBid + noBid;
                m.ethTvl = computeEthTvl(m);
              } catch (e) {
                // Ignore individual failures
              }
            });

            await Promise.all(bidPoolPromises);

            // Re-sort with updated bid pool data
            sortMarkets(allFetched);
            allMarkets = allFetched;
            markets = allFetched.filter(m => !m.resolved && m.close > nowTs);
            cacheMarkets(allMarkets);

            // Only re-render if still on first market (don't disrupt user navigation)
            if (currentIndex === 0) {
              render();
            }
          } catch (e) {
            console.warn('Bid pool fetch for sorting failed:', e);
          }
        })();
      }

      // Phase 3: Batch fetch odds for all markets using multicall
      batchFetchOdds(markets, rpc).catch(e => console.warn('Batch odds fetch failed:', e));
    }

    // Handle deep link - find and move to front (if not already handled from cache)
    if (window.deepLinkMarketId) {
      const idx = markets.findIndex(m => m.marketId === window.deepLinkMarketId);
      if (idx > 0) {
        const [market] = markets.splice(idx, 1);
        markets.unshift(market);
        currentIndex = 0;
        render();
      } else if (idx === -1) {
        // Market not in discovered list, try to load directly
        const loaded = await loadMarketById(window.deepLinkMarketId);
        // loadMarketById already sets currentIndex=0 and renders if successful
        if (!loaded && markets.length > 0) {
          // Failed to load deep link market, stay on current
          console.warn('Deep link market not found:', window.deepLinkMarketId);
        }
      }
      // idx === 0 means already at front, no action needed
      window.deepLinkMarketId = null; // Clear after handling
    }
  } catch (e) {
    console.warn('Failed to load markets:', e);
  }
}

// Batch fetch odds for multiple markets using multicall
async function batchFetchOdds(marketList, rpc) {
  if (!marketList.length) return;

  // Filter to markets that need odds loaded
  const needsOdds = marketList.filter(m => !m.oddsLoaded && !m.resolved);
  if (!needsOdds.length) {
    return;
  }

  const quoterInterface = new ethers.Interface(QUOTER_ABI);
  const pammInterface = new ethers.Interface(PAMM_ABI);

  // Build multicall batch - getMarketSummary for labeled markets, getPoolState for legacy
  const calls = needsOdds.map(m => {
    const isLabeled = isOurLabeledMarket(m.description);
    if (isLabeled) {
      return {
        target: CONTRACTS.QUOTER,
        callData: quoterInterface.encodeFunctionData('getMarketSummary', [m.marketId]),
        decode: (data) => quoterInterface.decodeFunctionResult('getMarketSummary', data),
        market: m,
        isLabeled: true
      };
    } else {
      return {
        target: CONTRACTS.PAMM,
        callData: pammInterface.encodeFunctionData('getPoolState', [BigInt(m.marketId), LEGACY_FEE_BPS]),
        decode: (data) => pammInterface.decodeFunctionResult('getPoolState', data),
        market: m,
        isLabeled: false
      };
    }
  });

  try {
    const results = await multicall(calls, rpc);
    let updated = 0;

    for (let i = 0; i < results.length; i++) {
      const result = results[i];
      const call = calls[i];
      const m = call.market;

      if (!result.success) continue;

      try {
        const decoded = result.decode();
        let odds;

        if (call.isLabeled) {
          // getMarketSummary returns ammPriceYesBps
          const spotBps = Number(decoded.ammPriceYesBps);
          odds = spotBps / 100;
        } else {
          // getPoolState returns reserves
          const rYes = Number(decoded.rYes);
          const rNo = Number(decoded.rNo);
          const total = rYes + rNo;
          odds = total > 0 ? (rNo / total) * 100 : 50;
        }

        m.y = odds;
        m.oddsLoaded = true;
        updated++;
      } catch (e) {
        // Decode failed, skip
      }
    }

    // Update cache with new odds and re-render
    if (updated > 0) {
      cacheMarkets(markets);
      render();
    }
  } catch (e) {
    console.warn('Multicall failed, falling back to individual fetches:', e.message);
    // Fallback: fetch individually for first few markets
    const first5 = needsOdds.slice(0, 5);
    await Promise.all(first5.map(async m => {
      try {
        m.y = await loadMarketOdds(m.marketId);
      } catch (e) {}
    }));
    cacheMarkets(markets);
    render();
  }
}

// Load a single market by ID and add to the list
async function loadMarketById(marketIdStr) {
  try {
    const rpc = await getRpc();
    const pamm = new ethers.Contract(CONTRACTS.PAMM, PAMM_ABI, rpc);
    const marketId = BigInt(marketIdStr);
    const market = await pamm.markets(marketId);

    if (market.resolver === ethers.ZeroAddress) {
      console.warn('Market not found:', marketIdStr);
      return null;
    }

    const yesSupply = await pamm.totalSupplyId(marketId);
    const noId = await pamm.getNoId(marketId);
    const noSupply = await pamm.totalSupplyId(noId);
    const total = yesSupply + noSupply;
    // Supply-based estimate (will be corrected to AMM spot price on view)
    const yPct = total > 0n ? Number(yesSupply * 10000n / total) / 100 : 50;

    // Try to get description from Quoter or use generic
    let description = '';
    let question = `Market #${marketIdStr.slice(0,8)}...`;
    let color = '#627EEA';
    let logo = 'eth';

    const newMarket = {
      id: marketIdStr.slice(-6),
      marketId: marketIdStr,
      q: question,
      c: color,
      logo: logo,
      y: yPct,
      close: Number(market.close),
      resolved: market.resolved,
      outcome: market.outcome,
      description: description,
      collateral: market.collateral
    };

    // Add to front of list (or move existing to front)
    const existing = markets.findIndex(m => m.marketId === marketIdStr);
    if (existing === -1) {
      markets.unshift(newMarket);
    } else if (existing > 0) {
      // Move to front
      markets.splice(existing, 1);
      markets.unshift(newMarket);
    } else {
      // Already at front, just update
      markets[0] = newMarket;
    }
    currentIndex = 0;

    render();
    return newMarket;
  } catch (e) {
    console.warn('Failed to load market by ID:', e);
    return null;
  }
}

// Parse market description to extract display info
// Format: TYPE|...fields...|CLOSE
// PRICE|ASSET|QUOTE|OP|THRESHOLD|CLOSE  (e.g., PRICE|ETH|USD|3|5000|1800048311)
// ETHBAL|ADDRESS|OP|THRESHOLD|CLOSE
// TOKBAL|TOKEN|ADDRESS|OP|THRESHOLD|CLOSE
// GAS|RANGE|LOWER|UPPER|CLOSE
// GAS|TWAP|THRESHOLD|CLOSE  (also: VOLATILITY, PEAK, TROUGH)
const COLORS = {
  ETH: '#627EEA', BTC: '#F7931A', SOL: '#14F195', LINK: '#375BD2',
  UNI: '#FF007A', AAVE: '#B6509E', MKR: '#1AAB9B', SNX: '#00D1FF',
  COMP: '#00D395', YFI: '#006AE3', CRV: '#FF4C4C', BAL: '#1E1E1E',
  SUSHI: '#FA52A0', MATIC: '#8247E5', ARB: '#28A0F0', OP: '#FF0420'
};
const OPS = ['<', '>', '≤', '≥', '=', '≠'];

// Format close date - show year if not current year
function formatCloseDate(timestamp) {
  const d = new Date(timestamp * 1000);
  const now = new Date();
  const sameYear = d.getFullYear() === now.getFullYear();
  if (sameYear) {
    return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
  }
  return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
}

// Format price for display
function formatPrice(val) {
  if (val >= 1e6) return `$${(val/1e6).toFixed(val % 1e6 === 0 ? 0 : 1)}M`;
  if (val >= 1000) return `$${(val/1000).toFixed(val % 1000 === 0 ? 0 : 1)}K`;
  return `$${val}`;
}

// Format balance for display
function formatBalance(val, decimals = 1) {
  if (val >= 1e9) return `${(val/1e9).toFixed(1)}B`;
  if (val >= 1e6) return `${(val/1e6).toFixed(1)}M`;
  if (val >= 1000) return `${(val/1000).toFixed(1)}K`;
  return val.toFixed(decimals);
}

function parseMarketDescription(description) {
  if (!description) return { question: 'Unknown market', color: '#627EEA', logo: 'eth', threshold: 0, raw: '' };

  // For non-standard (legacy/external) descriptions, extract just the question part
  let displayDesc = description;
  let threshold = 0;

  // Extract question up to first '?' for cleaner display
  const qMatch = description.match(/^(.+?\?)/);
  if (qMatch) {
    displayDesc = qMatch[1];
  } else if (description.length > 100) {
    displayDesc = description.slice(0, 97) + '...';
  }

  const defaults = { question: displayDesc, color: '#888', logo: '?', threshold, raw: description };
  try {
    const p = description.split('|');
    const type = p[0];

    // PRICE markets: PRICE|ASSET|QUOTE|OP|THRESHOLD|CLOSE
    if (type === 'PRICE' && p.length >= 6) {
      const [, asset, quote, op, thresh, close] = p;
      const t = parseInt(thresh);
      const price = formatPrice(t);
      const date = formatCloseDate(parseInt(close));
      const opNum = parseInt(op);
      // Op: 0=LT, 1=GT, 2=LTE, 3=GTE, 4=EQ, 5=NEQ
      const verb = opNum >= 2 ? 'hit' : 'drop to';
      const color = COLORS[asset] || '#627EEA';
      return {
        question: `<u style="text-decoration-color:${color}">${asset}</u> ${verb} <u style="text-decoration-color:#0F0">${price}</u> by <u style="text-decoration-color:#F50">${date}</u>?`,
        color, logo: asset.toLowerCase(), threshold: t, raw: description
      };
    }

    // ETH Balance markets: ETHBAL|ADDRESS|OP|THRESHOLD|CLOSE
    if (type === 'ETHBAL' && p.length >= 5) {
      const [, addr, op, thresh, close] = p;
      const t = parseFloat(thresh);
      const bal = formatBalance(t);
      const date = formatCloseDate(parseInt(close));
      const opNum = parseInt(op);
      const verb = opNum >= 2 ? 'hold' : 'have under';
      const addrLink = etherscanLink(addr, { color: '#627EEA' });
      return {
        question: `${addrLink} ${verb} <u style="text-decoration-color:#0F0">${bal} ETH</u> by <u style="text-decoration-color:#F50">${date}</u>?`,
        color: '#627EEA', logo: 'eth', threshold: t, raw: description
      };
    }

    // Token Balance markets: TOKBAL|TOKEN|ADDRESS|OP|THRESHOLD|CLOSE
    if (type === 'TOKBAL' && p.length >= 6) {
      const [, token, addr, op, thresh, close] = p;
      const t = parseFloat(thresh);
      const bal = formatBalance(t, 0);
      const date = formatCloseDate(parseInt(close));
      const opNum = parseInt(op);
      const verb = opNum >= 2 ? 'hold' : 'have under';
      const addrLink = etherscanLink(addr, { color: '#8247E5' });
      const tokenLink = etherscanLink(token, { color: '#FF007A', type: 'token' });
      return {
        question: `${addrLink} ${verb} <u style="text-decoration-color:#0F0">${bal}</u> ${tokenLink} by <u style="text-decoration-color:#F50">${date}</u>?`,
        color: '#8247E5', logo: 'tok', threshold: t, raw: description
      };
    }

    // NFT Balance markets: NFTBAL|TOKEN|ADDRESS|OP|THRESHOLD|CLOSE
    if (type === 'NFTBAL' && p.length >= 6) {
      const [, token, addr, op, thresh, close] = p;
      const t = parseInt(thresh);
      const date = formatCloseDate(parseInt(close));
      const opNum = parseInt(op);
      const verb = opNum >= 2 ? 'hold' : 'have under';
      const addrLink = etherscanLink(addr, { color: '#8247E5' });
      const tokenLink = etherscanLink(token, { color: '#e8e8e0', type: 'token' });
      return {
        question: `${addrLink} ${verb} <u style="text-decoration-color:#0F0">${t}</u> ${tokenLink} NFTs by <u style="text-decoration-color:#F50">${date}</u>?`,
        color: '#8247E5', logo: 'nft', threshold: t, raw: description
      };
    }

    // Gas markets: GAS|SUBTYPE|...params...|CLOSE
    if (type === 'GAS' && p.length >= 4) {
      const [, subtype, ...rest] = p;
      const close = rest[rest.length - 1];
      const date = formatCloseDate(parseInt(close));
      let q, thresh = parseFloat(rest[0]);

      if (subtype === 'RANGE') {
        const [lower, upper] = rest;
        q = `<u style="text-decoration-color:#FF6B6B">GAS</u> stay in <u style="text-decoration-color:#0F0">${lower}-${upper} gwei</u> by <u style="text-decoration-color:#F50">${date}</u>?`;
        thresh = parseFloat(lower);
      } else {
        const labels = { TWAP: 'avg', PEAK: 'spike to', TROUGH: 'dip to', VOL: 'swing', VOLATILITY: 'swing' };
        const label = labels[subtype] || subtype.toLowerCase();
        q = `<u style="text-decoration-color:#FF6B6B">GAS</u> ${label} <u style="text-decoration-color:#0F0">${rest[0]} gwei</u> by <u style="text-decoration-color:#F50">${date}</u>?`;
      }
      return { question: q, color: '#FF6B6B', logo: 'gas', threshold: thresh, raw: description };
    }

    // Legacy markets: LEGACY|TOKEN_SYMBOL|TARGET|OP|THRESHOLD|CLOSE
    // Example: LEGACY|LINK|0x9a70...|3|4000000|1743465600
    if (type === 'LEGACY' && p.length >= 6) {
      const [, tokenSym, target, op, thresh, close] = p;
      const t = parseFloat(thresh);
      const bal = formatBalance(t, 0);
      const date = formatCloseDate(parseInt(close));
      const opNum = parseInt(op);
      const opText = OPS[opNum] || '≥';
      const shortTarget = `${target.slice(0,6)}...${target.slice(-4)}`;
      const color = COLORS[tokenSym] || '#375BD2'; // Default to LINK blue
      return {
        question: `<u style="text-decoration-color:${color}">${shortTarget}</u> bal on <u style="text-decoration-color:${color}">${tokenSym}</u><br>reaches ${opText} <u style="text-decoration-color:#0F0">${bal} ${tokenSym}</u><br>by <u style="text-decoration-color:#F50">${date}</u>`,
        color: color,
        logo: tokenSym.toLowerCase(),
        threshold: t,
        raw: description,
        isLegacy: true
      };
    }

    // NFT/Token totalSupply markets: "[Name] totalSupply [OP] [VALUE] by [TIMESTAMP] Unix time"
    // Example: "zOrgz totalSupply >= 10000 by 1769288092 Unix time. Note: market may close..."
    const totalSupplyMatch = description.match(/^(\w+)\s+totalSupply\s*(>=|<=|>|<|=|!=)\s*(\d+)\s*by\s*(\d+)\s*Unix time/i);
    if (totalSupplyMatch) {
      const [, name, op, value, timestamp] = totalSupplyMatch;
      const val = parseInt(value);
      const ts = parseInt(timestamp);

      // Determine logo and color based on contract name
      const lowerName = name.toLowerCase();
      let color = '#9945FF'; // default purple for NFTs
      let logo = 'nft';

      if (lowerName === 'zorgz') {
        color = '#e8e8e0'; // bone color
        logo = 'zorgz';
      }

      // Format operator
      const opMap = { '>=': '≥', '<=': '≤', '!=': '≠', '>': '>', '<': '<', '=': '=' };
      const opText = opMap[op] || op;

      // Format threshold
      const valText = val >= 1e6 ? `${(val/1e6).toFixed(1)}M` : val >= 1000 ? `${(val/1000).toFixed(1)}K` : val.toString();

      // Format date from Unix timestamp
      const d = new Date(ts * 1000);
      const dateText = d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });

      // Build question with highlights
      const nftLogo = TOKEN_LOGOS[logo] || '';
      const rawTooltip = description.replace(/"/g, '&quot;');
      const q = `${nftLogo}<u style="text-decoration-color:${color}">${name}</u> mint ${opText} <u style="text-decoration-color:#0F0">${valText}</u> by <u style="text-decoration-color:#F50">${dateText}</u>? <span class="raw-hint" onclick="event.stopPropagation();showRawTooltip(this,'${rawTooltip}')" title="${rawTooltip}" style="opacity:0.4;cursor:help;font-size:9px">...</span>`;

      return { question: q, color, logo, threshold: val, raw: description };
    }

    // uniPM-style markets: "Subject OP VALUE by DATE" or "Subject OP VALUE, CLOSE"
    // Examples: "V4 Protocol Fee Controller != 0 by Dec 31, 2026", "UNI balance > 1000"
    const uniPMPatterns = [
      { prefix: 'V4 Protocol', label: 'V4 FEE SWITCH', color: '#FF007A', logo: 'uni' },
      { prefix: 'UNI balance', label: 'UNI BALANCE', color: '#FF007A', logo: 'uni' },
      { prefix: 'UNI voting power', label: 'UNI VOTING POWER', color: '#FF007A', logo: 'uni' },
      { prefix: 'UNI totalSupply', label: 'UNI SUPPLY', color: '#FF007A', logo: 'uni' },
      { prefix: 'UNI price', label: 'UNI PRICE', color: '#FF007A', logo: 'uni' }
    ];

    for (const pattern of uniPMPatterns) {
      if (description.startsWith(pattern.prefix)) {
        // Try to parse the condition: "Subject OP VALUE by DATE" or just "Subject OP VALUE"
        // Match: subject, operator (!=, >=, <=, >, <, =), value, optional "by DATE"
        const condMatch = description.match(/(.+?)\s*(!=|>=|<=|>|<|=)\s*(\d+(?:\.\d+)?)\s*(?:by\s+(.+))?$/i);

        if (condMatch) {
          const [, subject, op, value, dateStr] = condMatch;
          const val = parseFloat(value);

          // For binary on/off conditions (comparing to 0), use simpler language
          let conditionHtml;
          if (val === 0 && (op === '!=' || op === '=')) {
            // "!= 0" means "on/enabled", "= 0" means "off/disabled"
            const state = op === '!=' ? 'on' : 'off';
            conditionHtml = `<u style="text-decoration-color:#0F0">${state}</u>`;
          } else {
            // Standard comparison - show operator and value
            let opText;
            switch (op) {
              case '!=': opText = '≠'; break;
              case '>=': opText = '≥'; break;
              case '<=': opText = '≤'; break;
              case '>': opText = '>'; break;
              case '<': opText = '<'; break;
              case '=': opText = '='; break;
              default: opText = op;
            }
            const valText = formatBalance(val, val < 1 ? 2 : 0);
            conditionHtml = `${opText} <u style="text-decoration-color:#0F0">${valText}</u>`;
          }

          // Format date if present
          let dateHtml = '';
          if (dateStr) {
            // Try to parse the date string
            const d = new Date(dateStr);
            if (!isNaN(d)) {
              // If date is at end of month (day >= 28), show next month
              // e.g., Dec 31, 2026 → "Jan 2027" since resolution happens after
              let displayDate = d;
              if (d.getDate() >= 28) {
                displayDate = new Date(d.getFullYear(), d.getMonth() + 1, 1);
              }
              const formatted = displayDate.toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
              dateHtml = ` by <u style="text-decoration-color:#F50">${formatted}</u>`;
            } else {
              dateHtml = ` by <u style="text-decoration-color:#F50">${dateStr}</u>`;
            }
          }

          // Build the question with highlights, include "..." to reveal raw description
          const rawTooltip = description.replace(/"/g, '&quot;');
          const q = `<u style="text-decoration-color:${pattern.color}">${pattern.label}</u> ${conditionHtml}${dateHtml}? <span class="raw-hint" onclick="event.stopPropagation();showRawTooltip(this,'${rawTooltip}')" title="${rawTooltip}" style="opacity:0.4;cursor:help;font-size:9px">...</span>`;

          return { question: q, color: pattern.color, logo: pattern.logo, threshold: val, raw: description };
        }

        // Fallback: just highlight the prefix with raw description
        const rest = description.slice(pattern.prefix.length).trim();
        const q = `<u style="text-decoration-color:${pattern.color}">${pattern.label}</u> ${rest}`;
        return { question: q, color: pattern.color, logo: pattern.logo, threshold: 0, raw: description };
      }
    }
  } catch (e) { console.warn('Parse error:', e); }
  return defaults;
}

async function loadMarketOdds(marketId, forceRefresh = false) {
  const m = markets.find(x => x.marketId === marketId.toString() || x.marketId === marketId);

  // Return cached odds if available (unless force refresh)
  if (!forceRefresh && m?.oddsLoaded && typeof m.y === 'number') {
    return m.y;
  }

  try {
    const rpc = provider || await getRpc();
    const isLabeled = m && isOurLabeledMarket(m.description);

    let odds;
    if (isLabeled) {
      // Use AMM spot price for labeled markets
      const quoter = new ethers.Contract(CONTRACTS.QUOTER, QUOTER_ABI, rpc);
      const summary = await quoter.getMarketSummary(marketId, { gasLimit: 5000000 });
      const spotBps = Number(summary.ammPriceYesBps);
      // spotBps of 0 is valid (0% YES), don't fall back to 50
      odds = spotBps / 100;
    } else {
      // Legacy markets: use pool state
      const pamm = new ethers.Contract(CONTRACTS.PAMM, PAMM_ABI, rpc);
      const poolState = await pamm.getPoolState(BigInt(marketId), LEGACY_FEE_BPS);
      const rYes = Number(poolState.rYes);
      const rNo = Number(poolState.rNo);
      const total = rYes + rNo;
      // AMM spot price = rNo / (rYes + rNo) for YES price
      odds = total > 0 ? (rNo / total) * 100 : 50;
    }

    // Update market and cache
    if (m) {
      m.y = odds;
      m.oddsLoaded = true;
      cacheMarkets(markets); // Persist odds to cache
    }
    return odds;
  } catch (e) {
    console.warn('Failed to load odds:', e);
    if (m) m.oddsLoaded = true; // Mark as loaded even on error to stop loading animation
    return m?.y ?? 50;
  }
}

// ======================== RENDER ========================

// Helper to update odds bar with tooltip showing full precision
function setOddsBar(yPct) {
  const yWidth = Math.max(5, Math.min(95, yPct));
  const nPct = 100 - yPct;
  const nWidth = 100 - yWidth;
  // Display: 2 decimals, Tooltip: 6 decimals for debugging
  $('yBar').textContent = `Y ${yPct.toFixed(2)}%`;
  $('yBar').title = `YES: ${yPct.toFixed(6)}%`;
  $('yBar').style.width = yWidth + '%';
  $('nBar').textContent = `N ${nPct.toFixed(2)}%`;
  $('nBar').title = `NO: ${nPct.toFixed(6)}%`;
  $('nBar').style.width = nWidth + '%';
  document.querySelector('.odds')?.classList.remove('loading');
}

function render() {
  const m = markets[currentIndex];
  if (!m) return;

  // Show resolved badge if market is resolved
  let questionHtml = m.q;
  if (m.resolved) {
    const winner = m.outcome ? 'YES' : 'NO';
    const badgeClass = m.outcome ? 'yes' : 'no';
    questionHtml += `<span class="resolved-badge ${badgeClass}">${winner} WINS</span>`;
  }
  $('q').innerHTML = questionHtml;

  const oddsEl = document.querySelector('.odds');
  const oddsLoading = !m.oddsLoaded && !m.resolved;

  // Show loading state if odds haven't been fetched yet
  if (oddsLoading) {
    $('yBar').textContent = 'Y ...';
    $('yBar').title = '';
    $('yBar').style.width = '50%';
    $('nBar').textContent = 'N ...';
    $('nBar').title = '';
    $('nBar').style.width = '50%';
    if (oddsEl) oddsEl.classList.add('loading');
  } else {
    const yPct = typeof m.y === 'number' ? m.y : 50;
    setOddsBar(yPct);
  }

  // Keep "eth" text, just change underline color based on market type
  $('logo').style.textDecorationColor = m.c;

  // Add resolved class to odds container
  if (oddsEl) oddsEl.classList.toggle('resolved', !!m.resolved);

  // Meta info with market count
  const marketCount = markets.length;
  const countText = marketCount > 0 ? ` | ${currentIndex + 1}/${markets.length} markets` : '';

  if (m.marketId) {
    const status = m.resolved ? 'resolved' : `<span id="countdown">${formatCountdown(m.close)}</span>`;
    const collateralDisplay = getCollateralDisplay(m.collateral);
    const collateralSym = getCollateralSymbol(m.collateral);
    // Total liquidity = locked collateral + bid pool collateral (both sides)
    // Show "--" until bid pool data is loaded to avoid jarring updates
    let tvlText = '';
    if (m.bidPoolCollateral !== undefined) {
      const totalLiquidity = (m.tvl || 0) + (m.bidPoolCollateral || 0);
      tvlText = totalLiquidity > 0 ? ` | ${totalLiquidity < 1 ? totalLiquidity.toFixed(4) : totalLiquidity.toFixed(2)} ${collateralDisplay}` : '';
    } else if (isOurLabeledMarket(m.description)) {
      // Still loading bid pool data for labeled markets
      tvlText = ` | <span style="opacity:0.5">-- ${collateralDisplay}</span>`;
    } else {
      // Legacy markets don't have bid pools, show tvl directly
      tvlText = m.tvl ? ` | ${m.tvl < 1 ? m.tvl.toFixed(4) : m.tvl.toFixed(2)} ${collateralDisplay}` : '';
    }
    const shareBtn = `<span id="shareBtn" onclick="shareMarket()" style="cursor:pointer;margin-left:4px" title="Share market">&#128279;</span>`;
    // Add subtle raw description button for legacy/external markets AND uniPM markets (to inspect on-chain description)
    // Hide for pipe-separated formats (PRICE|, GAS|, etc.) where the parsed format is just a nicer version of the same data
    const isUniPM = m.description && (m.description.startsWith('V4 Protocol') || m.description.startsWith('UNI '));
    const showRawBtn = m.description && (!isOurLabeledMarket(m.description) || isUniPM);
    const rawBtn = showRawBtn ? `<span class="raw-desc-btn" onclick="showRawDescription(event)" title="View raw description">&#x22EF;</span>` : '';
    const lpLink = ` | <a href="#" onclick="event.preventDefault();showLPModal()" style="opacity:0.7" title="Add liquidity">💧LP</a>`;
    const isLabeled = isOurLabeledMarket(m.description);
    const ordersLink = isLabeled ? `<a href="#" onclick="event.preventDefault();showOrdersModal()" style="opacity:0.7;margin-left:6px" title="Limit orders">📊</a>` : '';
    $('meta').innerHTML = `<a href="${getMarketUrl(m.marketId)}" onclick="event.preventDefault();shareMarket()">#${m.marketId.slice(0,8)}...</a>${shareBtn}${rawBtn} | ${status}${tvlText}${countText}${lpLink}${ordersLink}`;

    // Resolver info now shown in resolution panel, hide separate display
    $('resolverInfo').style.display = 'none';
  } else {
    $('meta').innerHTML = countText || 'No markets found';
    $('resolverInfo').style.display = 'none';
  }

  // Update navigation chevrons
  const hasMultipleMarkets = markets.length > 1;
  $('navPrev')?.classList.toggle('disabled', !hasMultipleMarkets);
  $('navNext')?.classList.toggle('disabled', !hasMultipleMarkets);

  // Update mobile nav label
  const mobileNavLabel = $('mobileNavLabel');
  if (mobileNavLabel) {
    mobileNavLabel.textContent = markets.length > 0 ? `${currentIndex + 1} / ${markets.length}` : '0 / 0';
  }
  const mobileNav = $('mobileNav');
  if (mobileNav) {
    mobileNav.classList.toggle('hidden', !hasMultipleMarkets);
  }

  // Note: depth bar state is managed by updateLiquidityDepthBar(), not here
}

// Update resolver display with ENS lookup
async function updateResolverDisplay(m) {
  const el = $('resolverInfo');
  if (!m?.resolver) {
    el.style.display = 'none';
    return;
  }

  const etherscanUrl = `https://etherscan.io/address/${m.resolver}`;
  const resolverLower = m.resolver.toLowerCase();

  // Check if this is one of our known onchain resolvers or a legacy market
  const isOurResolver = resolverLower === CONTRACTS.RESOLVER.toLowerCase();
  const isKnownResolver = isOurResolver || m.isLegacy === true;

  if (isKnownResolver) {
    // Show "Onchain Resolver" for our canonical resolver and legacy markets
    el.innerHTML = `resolver: <a href="${etherscanUrl}" target="_blank" rel="noopener">Onchain Resolver</a><span id="liqSourcesIndicator"></span>`;
    el.style.display = 'block';
    return;
  }

  const short = `${m.resolver.slice(0,6)}...${m.resolver.slice(-4)}`;

  // Show immediately with short address
  el.innerHTML = `resolver: <a href="${etherscanUrl}" target="_blank" rel="noopener">${short}</a><span id="liqSourcesIndicator"></span>`;
  el.style.display = 'block';

  // Async ENS lookup
  const ensName = await lookupENS(m.resolver);
  if (ensName && markets[currentIndex]?.marketId === m.marketId) {
    // Still on same market, update with ENS name
    el.innerHTML = `resolver: <a href="${etherscanUrl}" target="_blank" rel="noopener">${ensName}</a><span id="liqSourcesIndicator"></span>`;
  }
}

// Update liquidity source indicators
function updateLiquidityIndicator() {
  const el = $('liqSourcesIndicator');
  if (!el) return;

  const { hasVault, hasBidPool, hasAmm } = liquiditySources;

  // Build indicator dots with tooltips
  let html = '';
  if (hasVault) {
    html += '<span class="liq-indicator vault" title="OTC vault active"></span>';
  }
  if (hasBidPool) {
    html += '<span class="liq-indicator bid" title="Bid pool active"></span>';
  }
  if (hasAmm) {
    html += '<span class="liq-indicator amm" title="AMM pool active"></span>';
  }
  if (!hasVault && !hasBidPool && !hasAmm) {
    html += '<span class="liq-indicator none" title="No liquidity"></span>';
  }

  el.innerHTML = html;
}

// Show raw description tooltip
let rawDescHideHandler = null;
function showRawDescription(event) {
  event.stopPropagation();
  const m = markets[currentIndex];
  if (!m?.description) return;

  // Create or get tooltip
  let tooltip = document.getElementById('rawDescTooltip');
  const metaEl = $('meta');
  if (!tooltip && metaEl) {
    tooltip = document.createElement('div');
    tooltip.id = 'rawDescTooltip';
    tooltip.className = 'raw-desc-tooltip';
    metaEl.appendChild(tooltip);
  }
  if (!tooltip) return;

  // Clean up any existing handler
  if (rawDescHideHandler) {
    document.removeEventListener('click', rawDescHideHandler);
    rawDescHideHandler = null;
  }

  // Toggle visibility
  if (tooltip.style.display === 'block') {
    tooltip.style.display = 'none';
  } else {
    tooltip.textContent = m.description;
    tooltip.style.display = 'block';

    // Auto-hide after 5 seconds
    setTimeout(() => { tooltip.style.display = 'none'; }, 5000);

    // Hide on click elsewhere (delayed to avoid immediate trigger)
    setTimeout(() => {
      rawDescHideHandler = (e) => {
        if (!e.target.classList.contains('raw-desc-btn')) {
          tooltip.style.display = 'none';
          document.removeEventListener('click', rawDescHideHandler);
          rawDescHideHandler = null;
        }
      };
      document.addEventListener('click', rawDescHideHandler);
    }, 10);
  }
}

// Show raw description tooltip near an element (for inline "..." hints)
function showRawTooltip(el, text) {
  // Create or get tooltip
  let tooltip = document.getElementById('rawHintTooltip');
  if (!tooltip) {
    tooltip = document.createElement('div');
    tooltip.id = 'rawHintTooltip';
    tooltip.style.cssText = 'position:fixed;background:#111;border:1px solid #333;color:#888;padding:8px 12px;font-size:10px;max-width:400px;word-break:break-word;z-index:9999;border-radius:4px;box-shadow:0 2px 8px rgba(0,0,0,0.5)';
    document.body.appendChild(tooltip);
  }

  // Toggle if clicking same element
  if (tooltip.style.display === 'block' && tooltip._sourceEl === el) {
    tooltip.style.display = 'none';
    return;
  }

  // Position near the element
  const rect = el.getBoundingClientRect();
  tooltip.textContent = text.replace(/&quot;/g, '"');
  tooltip.style.display = 'block';
  tooltip._sourceEl = el;

  // Position below the element
  tooltip.style.left = Math.min(rect.left, window.innerWidth - 420) + 'px';
  tooltip.style.top = (rect.bottom + 8) + 'px';

  // Auto-hide after 5 seconds
  setTimeout(() => { if (tooltip._sourceEl === el) tooltip.style.display = 'none'; }, 5000);

  // Hide on click elsewhere
  const hideHandler = (e) => {
    if (!el.contains(e.target) && !tooltip.contains(e.target)) {
      tooltip.style.display = 'none';
      document.removeEventListener('click', hideHandler);
    }
  };
  setTimeout(() => document.addEventListener('click', hideHandler), 10);
}

function prev() {
  if (markets.length === 0) return;
  currentIndex = (currentIndex - 1 + markets.length) % markets.length;
  closeDrop();
  resetMarketState();
  resetResolvePanel();
  render();
  loadAllMarketData();
  prefetchAdjacentOdds(); // Prefetch next/prev market odds
}

function next() {
  if (markets.length === 0) return;
  currentIndex = (currentIndex + 1) % markets.length;
  closeDrop();
  resetMarketState();
  resetResolvePanel();
  render();
  loadAllMarketData();
  prefetchAdjacentOdds(); // Prefetch next/prev market odds
}

// Prefetch odds for markets adjacent to current (for smooth navigation)
async function prefetchAdjacentOdds() {
  if (markets.length < 2) return;

  const adjacent = [
    markets[(currentIndex - 1 + markets.length) % markets.length],
    markets[(currentIndex + 1) % markets.length]
  ].filter(m => m && !m.oddsLoaded && !m.resolved);

  if (!adjacent.length) return;

  try {
    const rpc = provider || await getRpc();
    await batchFetchOdds(adjacent, rpc);
  } catch (e) {
    // Ignore prefetch failures
  }
}

function resetResolvePanel() {
  resolveDetailsOpen = false;
  $('resolveToggle')?.classList.remove('expanded');
  $('resolveDetails')?.classList.remove('expanded');
  // Reset toggle label and status to prevent stale data from previous market
  const toggleLabel = $('resolveToggleLabel');
  if (toggleLabel) toggleLabel.textContent = '⚙ Resolution';
  const toggleStatus = $('resolveToggleStatus');
  if (toggleStatus) {
    toggleStatus.textContent = '';
    toggleStatus.className = 'resolve-toggle-status';
  }
  $('resolveSection').style.display = 'none';
}

function vote(d) {
  const m = markets[currentIndex];
  if (!m) return;
  // Don't allow trading on resolved markets
  if (m.resolved) return;

  if (dir === d) return closeDrop();
  dir = d;
  $('drop').className = 'drop open ' + (d === 'Y' ? 'yes' : 'no') + (tradeMode === 'sell' ? ' sell-mode' : '');
  $('side').textContent = d;
  $('yBar').classList.toggle('dim', d !== 'Y');
  $('nBar').classList.toggle('dim', d !== 'N');
  $('amt').focus();
  updateTradeUI();
  calc();
}

function closeDrop() {
  dir = null;
  lastQuote = null; // Clear stale quote to prevent wrong-market execution
  $('drop').className = 'drop';
  $('yBar').classList.remove('dim');
  $('nBar').classList.remove('dim');
  tradeMode = 'buy';
  $('buyToggle').classList.add('active');
  $('sellToggle').classList.remove('active');
}

// Reset all market-specific state when switching markets
function resetMarketState() {
  // Clear quote and positions
  lastQuote = null;
  userPositions = { yes: 0n, no: 0n };
  lpPositions = { yesVault: 0n, noVault: 0n, ammLP: 0n, yesFees: 0n, noFees: 0n };

  // Reset liquidity info
  liquiditySources = { hasVault: false, hasBidPool: false, hasAmm: false };
  liquidityDepths = { amm: 0, vault: 0, bids: 0 };
  marketLiquidity = { total: 0, threshold: 0.05, hitsAmm: false };

  // Reset pool/vault stats
  vaultStats = { yesTotalShares: 0n, noTotalShares: 0n, yesUnderlying: 0n, noUnderlying: 0n, yesTotalFees: 0n, noTotalFees: 0n };
  poolStats = { reserve0: 0n, reserve1: 0n, totalSupply: 0n, userShare: 0, yesReserve: 0n, noReserve: 0n, impliedYesPrice: 50 };

  // Reset resolution status
  resolutionStatus = { value: 0n, threshold: 0n, condTrue: false, ready: false, op: 0 };

  // Reset price chart data
  priceChart = { spotBps: 0, twapBps: 0, poolId: null };
}

let liqPanelOpen = false;

function toggleLiquidityPanel() {
  liqPanelOpen = !liqPanelOpen;
  const toggle = $('liqToggle');
  if (toggle) toggle.classList.toggle('active', liqPanelOpen);

  if (liqPanelOpen) {
    // Re-render positions and load chart (respects liqPanelOpen state)
    renderPositions();
    loadPriceChart();
  } else {
    // Hide LP section and chart
    const lpSection = $('lpPositions');
    const lpBtn = $('lpBtnPos');
    const chartSection = $('chartSection');
    if (lpSection) lpSection.style.display = 'none';
    if (lpBtn) lpBtn.style.display = 'none';
    if (chartSection) chartSection.style.display = 'none';
  }
}

function setTradeMode(mode) {
  tradeMode = mode;
  $('buyToggle').classList.toggle('active', mode === 'buy');
  $('sellToggle').classList.toggle('active', mode === 'sell');
  $('drop').classList.toggle('sell-mode', mode === 'sell');
  updateTradeUI();
  calc();
}

// Set max amount for trade input
async function setMaxTradeAmount() {
  if (!connectedAddress) {
    toggleWallet();
    return;
  }

  const m = markets[currentIndex];
  const useETH = isETHCollateral(m?.collateral);

  if (tradeMode === 'buy') {
    try {
      const rpc = provider || await getRpc();
      let balance;

      if (useETH) {
        // Get ETH balance and reserve some for gas
        balance = await rpc.getBalance(connectedAddress);
        // Reserve 0.002 ETH for gas (covers approval + trade at higher gas prices)
        const gasReserve = ethers.parseEther('0.002');
        balance = balance > gasReserve ? balance - gasReserve : 0n;
      } else {
        // Get ERC20 token balance
        const token = new ethers.Contract(m.collateral, ERC20_ABI, rpc);
        balance = await token.balanceOf(connectedAddress);
      }

      if (balance > 0n) {
        const maxStr = ethers.formatEther(balance);
        // Round down to 4 decimals for cleaner display
        const rounded = Math.floor(parseFloat(maxStr) * 10000) / 10000;
        $('amt').value = rounded.toString();
        calc();
      } else {
        $('amt').value = '0';
      }
    } catch (e) {
      console.warn('Failed to get balance:', e);
    }
  } else {
    // Sell mode: use full share balance
    const bal = dir === 'Y' ? userPositions.yes : userPositions.no;
    if (bal && bal > 0n) {
      $('amt').value = ethers.formatEther(bal);
      calc();
    } else {
      $('amt').value = '0';
    }
  }
}

function updateTradeUI() {
  const m = markets[currentIndex];
  const collateralSym = getCollateralSymbol(m?.collateral);
  const isBuy = tradeMode === 'buy';
  $('tradeBtn').textContent = isBuy ? 'BUY' : 'SELL';
  $('amt').placeholder = isBuy ? `0.00 ${collateralSym}` : 'shares';

  if (isBuy) {
    $('tradeInfo').innerHTML = `${collateralSym} &rarr; <b id="out">0.00</b> <b id="side">${dir || 'Y'}</b>`;
  } else {
    const bal = dir === 'Y' ? userPositions.yes : userPositions.no;
    const balStr = formatShares(bal);
    $('tradeInfo').innerHTML = `<b id="side">${dir || 'Y'}</b> &rarr; <b id="out">0.00</b> ${collateralSym}<br><span style="opacity:0.5;font-size:10px;">bal: ${balStr}</span>`;
  }
}

let quoteTimeout = null;

function calc() {
  const v = parseFloat($('amt').value) || 0;
  const m = markets[currentIndex];
  if (!m) return;
  const odds = dir === 'Y' ? m.y : 100 - m.y;

  // Show instant linear estimate while quote loads
  if (tradeMode === 'buy') {
    const sharesEst = odds > 0 ? (v * 100 / odds) : 0;
    $('out').textContent = formatQuoteOutput(sharesEst);
  } else {
    const ethOut = (v * odds / 100);
    $('out').textContent = formatQuoteOutput(ethOut, true);
  }

  // Clear stale quote info
  const slipEl = document.getElementById('slippageInfo');
  if (slipEl) slipEl.textContent = '';

  // Debounced quote fetch for accurate preview
  if (quoteTimeout) clearTimeout(quoteTimeout);
  if (v > 0 && m.marketId) {
    const capturedMarketId = m.marketId;
    quoteTimeout = setTimeout(() => {
      // Verify market hasn't changed during debounce
      const currentMarket = markets[currentIndex];
      if (currentMarket?.marketId === capturedMarketId) {
        fetchQuote(v, m);
      }
    }, 300);
  }
}

let lastQuote = null; // Store quote for execution

async function fetchQuote(amount, m) {
  const capturedMarketId = m.marketId; // Capture market ID for stale check
  try {
    const rpc = provider || await getRpc();
    const buyYes = dir === 'Y';
    const isLabeled = isOurLabeledMarket(m.description);

    // For legacy/external markets, use local AMM quote
    if (!isLabeled) {
      return await fetchLegacyQuote(amount, m, buyYes, rpc, capturedMarketId);
    }

    const quoter = new ethers.Contract(CONTRACTS.QUOTER, QUOTER_ABI, rpc);

    if (tradeMode === 'buy') {
      const collateralIn = ethers.parseEther(amount.toString());
      // Use sweep quote to check orderbook + vault/amm routing
      const quote = await quoter.quoteBuyWithSweep(m.marketId, buyYes, collateralIn, 9999, { gasLimit: 5000000 }); // maxPrice 99.99% (10000 would skip pools)
      // Abort if user switched markets during async call
      if (markets[currentIndex]?.marketId !== capturedMarketId) return;
      const sharesOut = Number(quote.totalSharesOut) / 1e18;
      const poolShares = Number(quote.poolSharesOut) / 1e18;
      const poolLevels = Number(quote.poolLevelsFilled);
      const pmShares = Number(quote.pmSharesOut) / 1e18;
      const pmSource = decodeSource(quote.pmSource);

      // Fetch liquidity breakdown once for both display and routing
      let ammSpotPriceBps = 5000; // Default 50%
      let totalAvailableLiquidity = 0n;
      let useBookBuilding = false;
      let liq = null;
      try {
        liq = await quoter.getLiquidityBreakdown(m.marketId, buyYes, { gasLimit: 5000000 });
        ammSpotPriceBps = Number(liq.ammSpotPriceBps);
        const ammTotal = liq.ammYesReserve + liq.ammNoReserve;
        totalAvailableLiquidity = ammTotal + liq.vaultOtcShares + liq.poolAskDepth;
        const BOOK_BUILDING_THRESHOLD = ethers.parseEther('0.05'); // 0.05 ETH - low threshold so small markets hit AMM
        useBookBuilding = totalAvailableLiquidity < BOOK_BUILDING_THRESHOLD;
      } catch (e) {
        // Breakdown unavailable, use defaults
      }

      // Get detailed breakdown if PM portion exists
      let breakdown = null;
      if (quote.pmSharesOut > 0n) {
        let vaultAmount = 0, ammAmount = 0;
        if ((pmSource === 'multi' || pmSource === 'pm') && liq) {
          const vaultOtcShares = Number(liq.vaultOtcShares) / 1e18;
          if (liq.vaultOtcAvailable && vaultOtcShares > 0) {
            vaultAmount = Math.min(pmShares, vaultOtcShares);
            ammAmount = Math.max(0, pmShares - vaultOtcShares);
          } else {
            ammAmount = pmShares;
          }
        } else if (pmSource === 'vault') {
          vaultAmount = pmShares;
        } else if (pmSource === 'amm') {
          ammAmount = pmShares;
        } else {
          // Fallback estimate
          vaultAmount = pmShares * 0.5;
          ammAmount = pmShares * 0.5;
        }

        breakdown = {
          poolAmount: poolShares,
          vaultAmount,
          ammAmount,
          mintAmount: isMintSource(quote.pmSource) ? pmShares : 0,
          pmAmount: 0,
          vaultSide: buyYes ? 'NO' : 'YES',
          isBuy: true
        };
      } else if (poolShares > 0) {
        breakdown = { poolAmount: poolShares, vaultAmount: 0, ammAmount: 0, mintAmount: 0, pmAmount: 0, isBuy: true };
      }

      // Store quote for execution (include expected output for slippage protection)
      lastQuote = {
        marketId: capturedMarketId, // For wrong-market prevention
        useSweep: poolLevels > 0,
        poolLevels,
        amount,
        expectedOut: quote.totalSharesOut, // For minSharesOut
        isBuy: true,
        isLegacy: false,
        breakdown,
        // Routing info
        ammSpotPriceBps,
        useBookBuilding,
        timestamp: Date.now() // For freshness check
      };

      // Build source description
      let sourceName = '';
      if (poolLevels > 0 && quote.pmSharesOut > 0) {
        sourceName = `pool(${poolLevels})+${pmSource}`;
      } else if (poolLevels > 0) {
        sourceName = `pool(${poolLevels})`;
      } else {
        sourceName = pmSource;
      }
      if (useBookBuilding) sourceName += ' → list';

      // Calculate effective price vs spot
      const effectivePrice = sharesOut > 0 ? amount / sharesOut * 100 : 0;
      const spotPrice = dir === 'Y' ? m.y : (100 - m.y);
      const slippage = effectivePrice - spotPrice;

      $('out').textContent = formatQuoteOutput(sharesOut);
      updateQuoteInfo(sourceName, slippage, null, breakdown);
    } else {
      const sharesIn = ethers.parseEther(amount.toString());
      // Use sweep quote to check bid pools + vault/amm routing
      const quote = await quoter.quoteSellWithSweep(m.marketId, buyYes, sharesIn, 1, { gasLimit: 5000000 }); // minPrice 0.01% (0 would skip pools)
      // Abort if user switched markets during async call
      if (markets[currentIndex]?.marketId !== capturedMarketId) return;
      const collateralOut = Number(quote.totalCollateralOut) / 1e18;
      const poolCollateral = Number(quote.poolCollateralOut) / 1e18;
      const poolLevels = Number(quote.poolLevelsFilled);
      const pmCollateral = Number(quote.pmCollateralOut) / 1e18;
      const pmSource = decodeSource(quote.pmSource);

      // Fetch liquidity breakdown once for both display and routing
      let ammSpotPriceBps = 5000; // Default 50%
      let totalAvailableLiquidity = 0n;
      let useBookBuilding = false;
      let liq = null;
      try {
        liq = await quoter.getLiquidityBreakdown(m.marketId, buyYes, { gasLimit: 5000000 });
        ammSpotPriceBps = Number(liq.ammSpotPriceBps);
        const ammTotal = liq.ammYesReserve + liq.ammNoReserve;
        totalAvailableLiquidity = ammTotal + liq.vaultOtcShares + liq.poolBidDepth;
        const BOOK_BUILDING_THRESHOLD = ethers.parseEther('0.05'); // 0.05 ETH - low threshold so small markets hit AMM
        useBookBuilding = totalAvailableLiquidity < BOOK_BUILDING_THRESHOLD;
      } catch (e) {
        // Breakdown unavailable, use defaults
      }

      // Build breakdown for display
      let breakdown = null;
      if (pmCollateral > 0 || poolCollateral > 0) {
        let vaultAmount = 0, ammAmount = 0;
        if ((pmSource === 'multi' || pmSource === 'pm') && pmCollateral > 0 && liq) {
          const vaultOtcShares = Number(liq.vaultOtcShares) / 1e18;
          if (liq.vaultOtcAvailable && vaultOtcShares > 0) {
            const estVaultPct = Math.min(1, vaultOtcShares / (pmCollateral * 2));
            vaultAmount = pmCollateral * estVaultPct;
            ammAmount = pmCollateral * (1 - estVaultPct);
          } else {
            ammAmount = pmCollateral;
          }
        } else if (pmSource === 'vault') {
          vaultAmount = pmCollateral;
        } else if (pmSource === 'amm') {
          ammAmount = pmCollateral;
        } else if (pmCollateral > 0) {
          vaultAmount = pmCollateral * 0.5;
          ammAmount = pmCollateral * 0.5;
        }

        breakdown = {
          poolAmount: poolCollateral,
          vaultAmount,
          ammAmount,
          mintAmount: 0,
          pmAmount: 0,
          isBuy: false
        };
      }

      // Store quote for execution (include expected output for slippage protection)
      lastQuote = {
        marketId: capturedMarketId, // For wrong-market prevention
        useSweep: poolLevels > 0,
        poolLevels,
        amount,
        expectedOut: quote.totalCollateralOut, // For minCollateralOut
        isBuy: false,
        isLegacy: false,
        breakdown,
        // Routing info
        ammSpotPriceBps,
        useBookBuilding,
        timestamp: Date.now() // For freshness check
      };

      // Build source description
      let sourceName = '';
      if (poolLevels > 0 && quote.pmCollateralOut > 0) {
        sourceName = `bids+${pmSource}`;
      } else if (poolLevels > 0) {
        sourceName = 'bids';
      } else {
        sourceName = pmSource;
      }
      if (useBookBuilding) sourceName += ' → list';

      // Calculate effective price vs spot
      const effectivePrice = collateralOut / amount * 100;
      const spotPrice = dir === 'Y' ? m.y : (100 - m.y);
      const slippage = spotPrice - effectivePrice;

      $('out').textContent = formatQuoteOutput(collateralOut, true);
      updateQuoteInfo(sourceName, slippage, null, breakdown);
    }
  } catch (e) {
    console.log('Quote error:', e.message);
    // For labeled markets that failed quoter, try legacy fallback
    if (isOurLabeledMarket(m.description)) {
      try {
        const rpc = provider || await getRpc();
        return await fetchLegacyQuote(amount, m, dir === 'Y', rpc);
      } catch (e2) {
        console.log('Legacy fallback also failed:', e2.message);
      }
    }
    lastQuote = null;
  }
}

// Fetch quote for legacy/external markets using local AMM math
async function fetchLegacyQuote(amount, m, buyYes, rpc, capturedMarketId) {
  const pamm = new ethers.Contract(CONTRACTS.PAMM, PAMM_ABI, rpc);

  // Get pool state with 30 bps fee tier (legacy markets)
  const poolState = await pamm.getPoolState(BigInt(m.marketId), LEGACY_FEE_BPS);
  // Abort if user switched markets during async call
  if (markets[currentIndex]?.marketId !== capturedMarketId) return;
  const rYes = poolState.rYes;
  const rNo = poolState.rNo;

  if (rYes === 0n || rNo === 0n) {
    $('out').textContent = '0.00';
    updateQuoteInfo('no liq', 0, null);
    lastQuote = null;
    return;
  }

  if (tradeMode === 'buy') {
    const collateralIn = ethers.parseEther(amount.toString());
    const sharesOut = buyYes
      ? quoteBuyYes(collateralIn, rYes, rNo, LEGACY_FEE_BPS)
      : quoteBuyNo(collateralIn, rYes, rNo, LEGACY_FEE_BPS);
    const sharesOutNum = Number(sharesOut) / 1e18;

    // Store quote for execution
    lastQuote = {
      marketId: capturedMarketId, // For wrong-market prevention
      useSweep: false,
      poolLevels: 0,
      amount,
      expectedOut: sharesOut,
      isBuy: true,
      isLegacy: true,
      timestamp: Date.now(),
      rYes,
      rNo
    };

    // Calculate effective price vs spot
    const effectivePrice = sharesOutNum > 0 ? amount / sharesOutNum * 100 : 0;
    const spotPrice = dir === 'Y' ? m.y : (100 - m.y);
    const slippage = effectivePrice - spotPrice;

    $('out').textContent = formatQuoteOutput(sharesOutNum);
    updateQuoteInfo('amm↯', slippage, null); // ↯ indicates legacy PM_ROUTER
  } else {
    const sharesIn = ethers.parseEther(amount.toString());
    const collateralOut = buyYes
      ? quoteSellYes(sharesIn, rYes, rNo, LEGACY_FEE_BPS)
      : quoteSellNo(sharesIn, rYes, rNo, LEGACY_FEE_BPS);
    const collateralOutNum = Number(collateralOut) / 1e18;

    // Store quote for execution
    lastQuote = {
      marketId: capturedMarketId, // For wrong-market prevention
      useSweep: false,
      poolLevels: 0,
      amount,
      expectedOut: collateralOut,
      isBuy: false,
      isLegacy: true,
      timestamp: Date.now(),
      rYes,
      rNo
    };

    // Calculate effective price vs spot
    const effectivePrice = collateralOutNum / amount * 100;
    const spotPrice = dir === 'Y' ? m.y : (100 - m.y);
    const slippage = spotPrice - effectivePrice;

    $('out').textContent = formatQuoteOutput(collateralOutNum, true);
    updateQuoteInfo('amm↯', slippage, null);
  }
}

function decodeSource(source) {
  if (!source || source === '0x00000000') return 'amm';
  // Common sources: otc, amm, mint, mult
  const hex = source.toLowerCase();
  if (hex === '0x6f746300' || hex.includes('otc')) return 'vault';
  if (hex === '0x616d6d00' || hex.includes('amm')) return 'amm';
  if (hex === '0x6d696e74' || hex.includes('mint')) return 'mint';
  if (hex === '0x6d756c74' || hex.includes('mult')) return 'multi';
  return 'pm';
}

function isMintSource(source) {
  if (!source) return false;
  const hex = source.toLowerCase();
  return hex === '0x6d696e74' || hex.includes('mint');
}

function updateQuoteInfo(source, slippage, poolFill, breakdown = null) {
  let el = document.getElementById('slippageInfo');
  if (!el) {
    const tradeInfo = $('tradeInfo');
    if (!tradeInfo) return;
    el = document.createElement('span');
    el.id = 'slippageInfo';
    el.style.cssText = 'font-size:10px;margin-left:6px;';
    tradeInfo.appendChild(el);
  }

  // Slippage: positive = worse than spot (bad), negative = better than spot (good)
  let slipStr = '';
  let color = '';
  if (Math.abs(slippage) > 0.01) {
    if (slippage > 0) {
      // Worse than spot
      slipStr = `−${slippage.toFixed(1)}%`;
      color = slippage > 1 ? '#f66' : slippage > 0.5 ? '#fa0' : '#fff';
    } else {
      // Better than spot
      slipStr = `+${Math.abs(slippage).toFixed(1)}%`;
      color = '#0f0';
    }
  }
  const poolStr = poolFill ? ` <span style="color:#0f0">${poolFill.toFixed(4)} pool</span>` : '';

  let html = slipStr ? `<span style="color:${color}">${slipStr}</span> ${source}${poolStr}` : `${source}${poolStr}`;

  // Show breakdown if available
  if (breakdown) {
    const unit = breakdown.isBuy ? '' : 'Ξ'; // ETH symbol for sells, blank for shares
    const parts = [];
    if (breakdown.poolAmount >= 0.00005) parts.push(`${breakdown.poolAmount.toFixed(4)}${unit} pool`);
    if (breakdown.vaultAmount >= 0.00005) parts.push(`${breakdown.vaultAmount.toFixed(4)}${unit} vault`);
    if (breakdown.ammAmount >= 0.00005) parts.push(`${breakdown.ammAmount.toFixed(4)}${unit} amm`);
    if (breakdown.mintAmount > 0) parts.push(`<span style="color:#fa0">${breakdown.mintAmount.toFixed(4)} mint</span>`);
    if (parts.length > 0) {
      html += `<br><span style="font-size:9px;opacity:0.6">${parts.join(' + ')}</span>`;
    }
  }

  el.innerHTML = html;

  // Update waterfall visualization
  updateWaterfall(breakdown);
}

function updateWaterfall(breakdown) {
  const el = $('waterfall');
  if (!el) return;

  if (!breakdown) {
    el.classList.remove('active');
    el.innerHTML = '';
    return;
  }

  const total = (breakdown.poolAmount || 0) + (breakdown.vaultAmount || 0) +
                (breakdown.ammAmount || 0) + (breakdown.mintAmount || 0);

  if (total <= 0) {
    el.classList.remove('active');
    el.innerHTML = '';
    return;
  }

  // Calculate block counts (20 blocks total like main depth bar)
  const TOTAL_BLOCKS = 20;
  const poolPct = (breakdown.poolAmount || 0) / total;
  const vaultPct = (breakdown.vaultAmount || 0) / total;
  const ammPct = (breakdown.ammAmount || 0) / total;
  const mintPct = (breakdown.mintAmount || 0) / total;

  const poolBlocks = Math.round(poolPct * TOTAL_BLOCKS);
  const vaultBlocks = Math.round(vaultPct * TOTAL_BLOCKS);
  const ammBlocks = Math.round(ammPct * TOTAL_BLOCKS);
  const mintBlocks = TOTAL_BLOCKS - poolBlocks - vaultBlocks - ammBlocks;

  // Build ASCII bar with colored blocks
  const barHtml = `<div class="waterfall-bar">` +
    (poolBlocks > 0 ? `<span class="pool">${'█'.repeat(poolBlocks)}</span>` : '') +
    (vaultBlocks > 0 ? `<span class="vault">${'█'.repeat(vaultBlocks)}</span>` : '') +
    (ammBlocks > 0 ? `<span class="amm">${'█'.repeat(ammBlocks)}</span>` : '') +
    (mintBlocks > 0 ? `<span class="mint">${'█'.repeat(mintBlocks)}</span>` : '') +
    `</div>`;

  // Build legend with amounts
  const unit = breakdown.isBuy ? '' : 'Ξ';
  const legendParts = [];
  if (breakdown.poolAmount > 0) legendParts.push(`<span class="pool" title="Orderbook bids">BIDS ${breakdown.poolAmount.toFixed(4)}${unit}</span>`);
  if (breakdown.vaultAmount > 0) legendParts.push(`<span class="vault" title="OTC vault shares">VAULT ${breakdown.vaultAmount.toFixed(4)}${unit}</span>`);
  if (breakdown.ammAmount > 0) legendParts.push(`<span class="amm" title="AMM liquidity pool">AMM ${breakdown.ammAmount.toFixed(4)}${unit}</span>`);
  if (breakdown.mintAmount > 0) legendParts.push(`<span class="mint" title="Freshly minted shares">MINT ${breakdown.mintAmount.toFixed(4)}${unit}</span>`);

  const legendHtml = legendParts.length > 0 ? `<div class="waterfall-legend">${legendParts.join('')}</div>` : '';

  el.innerHTML = barHtml + legendHtml;
  el.classList.add('active');
}

// Update the persistent liquidity depth visualization
function updateLiquidityDepthBar() {
  const el = $('liqDepth');
  if (!el) return;

  const m = markets[currentIndex];
  const isLabeled = m?.description && isOurLabeledMarket(m.description);

  // Helper to hide bar
  const hideBar = () => {
    el.classList.remove('active');
    el.innerHTML = '';
    // Also remove any orphaned legend
    const legend = el.nextElementSibling;
    if (legend?.classList.contains('liq-depth-legend')) legend.remove();
  };

  // Only show for non-legacy (labeled) markets
  if (!isLabeled) {
    hideBar();
    return;
  }

  const { amm, vault, bids } = liquidityDepths;
  const total = amm + vault + bids;

  if (total <= 0) {
    hideBar();
    return;
  }

  // Update global liquidity tracking
  marketLiquidity.total = total;
  marketLiquidity.hitsAmm = total >= marketLiquidity.threshold;

  // Calculate block counts (20 blocks total like progress bar)
  const TOTAL_BLOCKS = 20;
  const bidsBlocks = Math.round((bids / total) * TOTAL_BLOCKS);
  const vaultBlocks = Math.round((vault / total) * TOTAL_BLOCKS);
  const ammBlocks = TOTAL_BLOCKS - bidsBlocks - vaultBlocks; // Remainder to AMM

  // Build ASCII bar with colored blocks - order: vaults, amm, orders
  const barHtml = `<div class="liq-depth-bar">` +
    (vaultBlocks > 0 ? `<span class="vault">${'█'.repeat(vaultBlocks)}</span>` : '') +
    (ammBlocks > 0 ? `<span class="amm">${'█'.repeat(ammBlocks)}</span>` : '') +
    (bidsBlocks > 0 ? `<span class="bids">${'█'.repeat(bidsBlocks)}</span>` : '') +
    `</div>`;

  // Build legend with amounts - TVL breakdown showing where collateral sits
  const collateralSym = getCollateralSymbol(m?.collateral);
  const fmt = (v) => v < 0.001 ? '<0.001' : v < 0.01 ? v.toFixed(4) : v.toFixed(2);

  // AMM routing progress indicator
  const progressPct = Math.min(100, (total / marketLiquidity.threshold) * 100);
  const progressBlocks = Math.round(progressPct / 10); // 10 blocks for 100%
  const emptyBlocks = 10 - progressBlocks;
  const isActive = marketLiquidity.hitsAmm;
  const remaining = Math.max(0, marketLiquidity.threshold - total);

  // Build progress bar with filled and remaining blocks
  let progressBar;
  let routingLabel;
  let routingClass;

  if (isActive) {
    // AMM is active - show full green bar
    progressBar = `<span class="filled">${'▓'.repeat(10)}</span>`;
    routingLabel = '✓ AMM';
    routingClass = 'active';
  } else {
    // Building phase - show progress with remaining in dimmed color
    progressBar = `<span class="filled">${'▓'.repeat(progressBlocks)}</span><span class="remaining">${'░'.repeat(emptyBlocks)}</span>`;
    routingLabel = `book ${progressPct.toFixed(0)}%`;
    routingClass = 'building';
  }

  // Build detailed tooltip
  const tooltipLines = [];
  if (isActive) {
    tooltipLines.push(`✓ AMM routing active`);
    tooltipLines.push(`Trades move the price via constant-product AMM`);
    tooltipLines.push(`Total liquidity: ${fmt(total)} ${collateralSym}`);
  } else {
    tooltipLines.push(`📈 Building toward AMM (${progressPct.toFixed(0)}%)`);
    tooltipLines.push(`Current: ${fmt(total)} / ${fmt(marketLiquidity.threshold)} ${collateralSym}`);
    tooltipLines.push(`Need ${fmt(remaining)} more ${collateralSym} for AMM routing`);
    tooltipLines.push(`Until then: orders mint shares & list on book`);
  }
  const tooltip = tooltipLines.join('\n');

  // Show "need X more" for below-threshold markets
  const needHtml = !isActive && remaining > 0
    ? `<span class="need">+${fmt(remaining)} ${collateralSym}</span>`
    : '';

  // Build venue breakdown (tooltip on bar hover)
  const venueItems = [];
  if (vault > 0) venueItems.push(`<span class="vault">█ ${fmt(vault)}</span>`);
  if (amm > 0) venueItems.push(`<span class="amm">█ ${fmt(amm)}</span>`);
  if (bids > 0) venueItems.push(`<span class="bids">█ ${fmt(bids)}</span>`);

  const legendHtml = `<div class="liq-depth-legend">` +
    `<span class="venue-breakdown">${venueItems.join('')}</span>` +
    `<span class="routing ${routingClass}" title="${tooltip}">${progressBar} ${routingLabel}${needHtml}</span>` +
    `</div>`;

  el.innerHTML = barHtml + legendHtml;
  el.classList.add('active');

  // Remove any old separate legend element
  const oldLegend = el.nextElementSibling;
  if (oldLegend?.classList.contains('liq-depth-legend')) oldLegend.remove();
}

function formatShares(wei) {
  if (wei === 0n) return '0';
  const eth = Number(wei) / 1e18;
  if (eth < 0.0001) return '<0.0001';
  if (eth < 1) return eth.toFixed(4);
  if (eth < 1000) return eth.toFixed(2);
  return eth.toLocaleString('en-US', { maximumFractionDigits: 2 });
}

// Format quote output - show more decimals for small values
function formatQuoteOutput(val, isEth = false) {
  if (val === 0) return '0.00';
  if (val < 0.0001) return val.toFixed(6);
  if (val < 0.01) return val.toFixed(4);
  if (val < 1) return val.toFixed(4);
  if (val < 100) return val.toFixed(2);
  return val.toFixed(1);
}

function formatFees(wei, collateralAddress) {
  if (wei === 0n) return '0';
  const amt = Number(wei) / 1e18;
  const sym = getCollateralSymbol(collateralAddress);
  if (amt < 0.0001) return `<0.0001 ${sym}`;
  if (amt < 0.01) return amt.toFixed(6) + ` ${sym}`;
  return amt.toFixed(4) + ` ${sym}`;
}

function formatCountdown(closeTimestamp) {
  const now = Math.floor(Date.now() / 1000);
  const diff = closeTimestamp - now;
  if (diff <= 0) return 'closed';
  const days = Math.floor(diff / 86400);
  const hours = Math.floor((diff % 86400) / 3600);
  const mins = Math.floor((diff % 3600) / 60);
  if (days > 30) return new Date(closeTimestamp * 1000).toLocaleDateString();
  if (days > 0) return `${days}d ${hours}h`;
  if (hours > 0) return `${hours}h ${mins}m`;
  return `${mins}m`;
}

// Parse calldata into human-readable format with SwissKnife link
function parseCalldata(calldata, targetAddr) {
  // Normalize calldata to hex string (ethers v6 may return Uint8Array or other types)
  if (calldata && typeof calldata !== 'string') {
    try {
      calldata = ethers.hexlify(calldata);
    } catch (e) {
      calldata = '';
    }
  }
  calldata = calldata || '';

  const swissKnifeUrl = calldata && calldata !== '0x' && calldata.length > 2
    ? `https://calldata.swiss-knife.xyz/decoder?calldata=${calldata}`
    : null;

  // Empty calldata = ETH balance check
  if (!calldata || calldata === '0x' || calldata.length < 10) {
    return {
      parsed: `ETH balance of <a href="https://etherscan.io/address/${targetAddr}" target="_blank" rel="noopener">${targetAddr.slice(0,6)}...${targetAddr.slice(-4)}</a>`,
      raw: '(none - ETH balance)',
      swissKnifeUrl: null
    };
  }

  const selector = calldata.slice(0, 10).toLowerCase();

  // balanceOf(address) - 0x70a08231
  if (selector === '0x70a08231' && calldata.length >= 74) {
    const account = '0x' + calldata.slice(34, 74);
    return {
      parsed: `balanceOf(<a href="https://etherscan.io/address/${account}" target="_blank" rel="noopener">${account.slice(0,6)}...${account.slice(-4)}</a>)`,
      raw: calldata,
      swissKnifeUrl
    };
  }

  // totalSupply() - 0x18160ddd
  if (selector === '0x18160ddd') {
    return {
      parsed: 'totalSupply()',
      raw: calldata,
      swissKnifeUrl
    };
  }

  // latestAnswer() - 0x50d25bcd (Chainlink)
  if (selector === '0x50d25bcd') {
    return {
      parsed: 'latestAnswer() <span style="opacity:0.5">(Chainlink)</span>',
      raw: calldata,
      swissKnifeUrl
    };
  }

  // latestRoundData() - 0xfeaf968c (Chainlink)
  if (selector === '0xfeaf968c') {
    return {
      parsed: 'latestRoundData() <span style="opacity:0.5">(Chainlink)</span>',
      raw: calldata,
      swissKnifeUrl
    };
  }

  // protocolFeeController() - 0xf02de3b2 (Uniswap V4)
  if (selector === '0xf02de3b2') {
    return {
      parsed: 'protocolFeeController() <span style="opacity:0.5">(Uniswap V4)</span>',
      raw: calldata,
      swissKnifeUrl,
      functionName: 'protocolFeeController'
    };
  }

  // Unknown - show raw with link
  return {
    parsed: null,
    raw: calldata,
    swissKnifeUrl
  };
}

// Format calldata display for inspect panel
function formatCalldataHtml(calldata, targetAddr, label) {
  // Normalize calldata to hex string (ethers v6 may return Uint8Array or other types)
  if (calldata && typeof calldata !== 'string') {
    try {
      calldata = ethers.hexlify(calldata);
    } catch (e) {
      calldata = '';
    }
  }
  calldata = calldata || '';

  // Handle empty/unused calldata (e.g., callDataB in scalar conditions)
  if (!calldata || calldata === '0x' || calldata.length < 10) {
    // Check if this is an ETH balance check (has valid target but no calldata)
    if (targetAddr && targetAddr !== ethers.ZeroAddress) {
      return `<div class="inspect-row">
        <span class="inspect-label">${label}</span>
        <span class="inspect-value">ETH balance of <a href="https://etherscan.io/address/${targetAddr}" target="_blank" rel="noopener">${targetAddr.slice(0,6)}...${targetAddr.slice(-4)}</a></span>
      </div>`;
    }
    return `<div class="inspect-row">
      <span class="inspect-label">${label}</span>
      <span class="inspect-value">(empty)</span>
    </div>`;
  }

  const parsed = parseCalldata(calldata, targetAddr);
  let html = '';

  if (parsed.parsed) {
    html += `<div class="inspect-row">
      <span class="inspect-label">${label}</span>
      <span class="inspect-value">${parsed.parsed}</span>
    </div>`;
  }

  // Always show raw calldata row with SwissKnife link
  const rawDisplay = parsed.raw.length > 20 ? parsed.raw.slice(0, 20) + '...' : parsed.raw;
  const swissLink = parsed.swissKnifeUrl
    ? ` <a href="${parsed.swissKnifeUrl}" target="_blank" rel="noopener" title="Decode on SwissKnife" style="opacity:0.7">🔍</a>`
    : '';

  html += `<div class="inspect-row">
    <span class="inspect-label">${parsed.parsed ? '' : label}</span>
    <span class="inspect-value" title="${parsed.raw}">${rawDisplay}${swissLink}</span>
  </div>`;

  return html;
}

// Start countdown timer to update display
let countdownInterval;
function startCountdownTimer() {
  if (countdownInterval) clearInterval(countdownInterval);
  countdownInterval = setInterval(() => {
    const m = markets[currentIndex];
    if (m?.marketId && !m.resolved && m.close) {
      const el = document.getElementById('countdown');
      if (el) el.textContent = formatCountdown(m.close);
    }
  }, 1000);
}

// Auto-refresh market data every 30s
let refreshInterval;
function startAutoRefresh() {
  if (refreshInterval) clearInterval(refreshInterval);
  refreshInterval = setInterval(async () => {
    const m = markets[currentIndex];
    if (m?.marketId && !m.resolved) {
      try {
        // Use combined loader for efficient single-batch refresh
        await loadAllMarketData();
        render(); // Update meta display (countdown, etc.)
      } catch (e) {
        console.warn('Auto-refresh failed:', e.message);
      }
    }
  }, 30000);
}

// ======================== TRADE ========================
function executeTrade() {
  if (tradeMode === 'buy') {
    buy();
  } else {
    sell();
  }
}

async function buy() {
  if (!connectedAddress) return toggleWallet();
  if (isTrading) return;

  const m = markets[currentIndex];
  if (!m?.marketId) {
    alert('No market selected');
    return;
  }

  const amtStr = $('amt').value;
  const amt = parseFloat(amtStr);
  if (!amt || amt <= 0) return;

  const buyYes = dir === 'Y';
  const collateralIn = ethers.parseEther(amtStr);
  const deadline = Math.floor(Date.now() / 1000) + 3600; // 1 hour

  // Detect if market uses ERC20 collateral
  const useETH = isETHCollateral(m.collateral);

  isTrading = true;
  $('tradeBtn').disabled = true;
  $('tradeBtn').textContent = '...';

  try {
    const pamm = new ethers.Contract(CONTRACTS.PAMM, PAMM_ABI, signer);
    let tx;

    // Calculate minSharesOut with 1% slippage buffer (99% of quoted)
    if (!lastQuote?.expectedOut) {
      alert('Please wait for quote to load before buying');
      isTrading = false;
      $('tradeBtn').disabled = false;
      $('tradeBtn').textContent = 'BUY';
      return;
    }
    // Prevent using quote from different market
    if (lastQuote.marketId && lastQuote.marketId !== m.marketId) {
      alert('Quote is for a different market. Please refresh.');
      lastQuote = null;
      calc(); // Re-fetch quote
      isTrading = false;
      $('tradeBtn').disabled = false;
      $('tradeBtn').textContent = 'BUY';
      return;
    }
    // Block stale quotes (> 30 seconds) - force re-quote
    const quoteAge = Date.now() - (lastQuote.timestamp || 0);
    if (quoteAge > 30000) {
      lastQuote = null;
      calc(); // Re-fetch quote
      isTrading = false;
      $('tradeBtn').disabled = false;
      $('tradeBtn').textContent = 'BUY';
      showToast('Quote expired. Please try again.', 'error', 3000);
      return;
    }
    const minSharesOut = lastQuote.expectedOut * 99n / 100n;

    // For legacy/external markets, use PM_ROUTER (atomic split+swap)
    if (lastQuote?.isLegacy) {

      const pmRouter = new ethers.Contract(CONTRACTS.PM_ROUTER, PM_ROUTER_ABI, signer);

      // Handle ERC20 approval for legacy markets
      if (!useETH) {
        const approval = await ensureERC20Approval(m.collateral, CONTRACTS.PM_ROUTER, collateralIn);
        if (approval.usePermit) {
          // PM_ROUTER doesn't have multicall, so permit tokens need separate handling
          // For now, fall back to traditional approve (already done in ensureERC20Approval)
          showToast('Note', 'Permit not supported for legacy markets, using approval', 'pending');
        }
      }

      tx = await pmRouter.buy(
        BigInt(m.marketId),
        buyYes,
        collateralIn,
        minSharesOut,
        LEGACY_FEE_BPS, // 30 bps fee tier
        connectedAddress,
        deadline,
        useETH ? { value: collateralIn } : {}
      );
    } else {
      const router = new ethers.Contract(CONTRACTS.MASTER_ROUTER, MASTER_ROUTER_ABI, signer);
      const routerInterface = new ethers.Interface(MASTER_ROUTER_ABI);
      const tokenInterface = new ethers.Interface(ERC20_ABI);

      // Check if we need approval
      let needsApproval = false;
      if (!useETH) {
        const token = new ethers.Contract(m.collateral, ERC20_ABI, provider);
        const allowance = await token.allowance(connectedAddress, CONTRACTS.MASTER_ROUTER);
        needsApproval = allowance < collateralIn;
      }

      // Build the swap calldata based on routing
      let swapCalldata;
      if (lastQuote?.useBookBuilding) {
        const yesPrice = lastQuote.ammSpotPriceBps || 5000;
        const buySidePrice = buyYes ? yesPrice : (10000 - yesPrice);
        const maxSweepPrice = Math.min(buySidePrice + 100, 9999);
        const askPrice = Math.max((10000 - buySidePrice) - 50, 1);
        swapCalldata = routerInterface.encodeFunctionData('sweepMintAndPool', [
          m.marketId, buyYes, collateralIn, maxSweepPrice, askPrice, connectedAddress, deadline
        ]);
      } else {
        swapCalldata = routerInterface.encodeFunctionData('buyWithSweep', [
          m.marketId, buyYes, collateralIn, minSharesOut, 9999, connectedAddress, deadline
        ]);
      }

      // Try EIP-5792 atomic batching first (single popup for approve + swap)
      if (needsApproval && await supportsAtomicBatch()) {
        showToast('Confirm approval + swap in your wallet...', 'pending');

        const approveCalldata = tokenInterface.encodeFunctionData('approve', [
          CONTRACTS.MASTER_ROUTER, collateralIn
        ]);

        const batchResult = await sendBatchedCalls([
          { to: m.collateral, data: approveCalldata },
          { to: CONTRACTS.MASTER_ROUTER, data: swapCalldata }
        ]);

        if (batchResult.success) {
          tx = { hash: batchResult.hash, wait: async () => provider.getTransactionReceipt(batchResult.hash) };
        } else {
          throw new Error(batchResult.error || 'Batch transaction failed');
        }
      } else if (needsApproval) {
        // Fall back to permit signature + multicall (2 popups but 1 tx) or approve tx + swap tx
        const approval = await ensureERC20Approval(m.collateral, CONTRACTS.MASTER_ROUTER, collateralIn);

        if (approval.usePermit) {
          // Use multicall: permit + swap (single tx after permit signature popup)
          const permitCalldata = routerInterface.encodeFunctionData('permit', [
            m.collateral, connectedAddress, approval.permitData.amount, approval.permitData.deadline,
            approval.permitData.v, approval.permitData.r, approval.permitData.s
          ]);
          tx = await router.multicall([permitCalldata, swapCalldata]);
        } else {
          // Traditional flow: approval already done, just do swap
          if (lastQuote?.useBookBuilding) {
            const yesPrice = lastQuote.ammSpotPriceBps || 5000;
            const buySidePrice = buyYes ? yesPrice : (10000 - yesPrice);
            const maxSweepPrice = Math.min(buySidePrice + 100, 9999);
            const askPrice = Math.max((10000 - buySidePrice) - 50, 1);
            tx = await router.sweepMintAndPool(m.marketId, buyYes, collateralIn, maxSweepPrice, askPrice, connectedAddress, deadline);
          } else {
            tx = await router.buyWithSweep(m.marketId, buyYes, collateralIn, minSharesOut, 9999, connectedAddress, deadline);
          }
        }
      } else {
        // No approval needed - just do the swap
        if (lastQuote?.useBookBuilding) {
          const yesPrice = lastQuote.ammSpotPriceBps || 5000;
          const buySidePrice = buyYes ? yesPrice : (10000 - yesPrice);
          const maxSweepPrice = Math.min(buySidePrice + 100, 9999);
          const askPrice = Math.max((10000 - buySidePrice) - 50, 1);
          tx = await router.sweepMintAndPool(m.marketId, buyYes, collateralIn, maxSweepPrice, askPrice, connectedAddress, deadline, useETH ? { value: collateralIn } : {});
        } else {
          tx = await router.buyWithSweep(m.marketId, buyYes, collateralIn, minSharesOut, 9999, connectedAddress, deadline, useETH ? { value: collateralIn } : {});
        }
      }
    }

    // Save direction before closeDrop() clears it
    const side = dir === 'Y' ? 'YES' : 'NO';
    const otherSide = dir === 'Y' ? 'NO' : 'YES';
    const usedBookBuilding = lastQuote?.useBookBuilding && !lastQuote?.isLegacy;

    showTxPending(tx.hash);
    const receipt = await tx.wait();

    // Show success immediately after confirmation
    if (usedBookBuilding) {
      const yesPrice = lastQuote.ammSpotPriceBps || 5000;
      const buySidePrice = dir === 'Y' ? yesPrice : (10000 - yesPrice);
      const listPrice = ((10000 - buySidePrice - 50) / 100).toFixed(1);
      showTxSuccess(`Bought ${side} + listed ${otherSide} at ${listPrice}%`, receipt.hash);
    } else {
      showTxSuccess(`Bought ${side} shares!`, receipt.hash);
    }

    // Refresh odds and positions (don't let failures hide success toast)
    try {
      m.y = await loadMarketOdds(m.marketId);
      await loadPositions();
      render();
    } catch (refreshErr) {
      console.warn('Refresh after buy failed:', refreshErr);
    }

    $('amt').value = '';
    $('out').textContent = '0.00';
    lastQuote = null;
    closeDrop();

  } catch (e) {
    console.error('Buy failed:', e);
    const msg = e.reason || e.message || 'Unknown error';
    hideToast();
    if (!msg.toLowerCase().includes('user rejected')) {
      showTxError('Buy failed: ' + msg);
    }
  } finally {
    isTrading = false;
    $('tradeBtn').disabled = false;
    $('tradeBtn').textContent = 'BUY';
    // Check if wallet/chain changed during transaction
    if (window._pendingReload) {
      window._pendingReload = false;
      window.location.reload();
    }
  }
}

async function sell() {
  if (!connectedAddress) return toggleWallet();
  if (isTrading) return;

  const m = markets[currentIndex];
  if (!m?.marketId) {
    alert('No market selected');
    return;
  }

  const amtStr = $('amt').value;
  const amt = parseFloat(amtStr);
  if (!amt || amt <= 0) return;

  const sellYes = dir === 'Y';
  const sharesIn = ethers.parseEther(amtStr);
  const deadline = Math.floor(Date.now() / 1000) + 3600;

  // Check if user has enough shares
  const balance = sellYes ? userPositions.yes : userPositions.no;
  if (sharesIn > balance) {
    alert(`Insufficient ${dir} shares. You have ${formatShares(balance)}`);
    return;
  }

  isTrading = true;
  $('tradeBtn').disabled = true;
  $('tradeBtn').textContent = '...';

  try {
    const pamm = new ethers.Contract(CONTRACTS.PAMM, PAMM_ABI, signer);
    let tx;

    // Calculate minCollateralOut with 1% slippage buffer (99% of quoted)
    if (!lastQuote?.expectedOut) {
      alert('Please wait for quote to load before selling');
      isTrading = false;
      $('tradeBtn').disabled = false;
      $('tradeBtn').textContent = 'SELL';
      return;
    }
    // Prevent using quote from different market
    if (lastQuote.marketId && lastQuote.marketId !== m.marketId) {
      alert('Quote is for a different market. Please refresh.');
      lastQuote = null;
      calc(); // Re-fetch quote
      isTrading = false;
      $('tradeBtn').disabled = false;
      $('tradeBtn').textContent = 'SELL';
      return;
    }
    // Block stale quotes (> 30 seconds) - force re-quote
    const quoteAge = Date.now() - (lastQuote.timestamp || 0);
    if (quoteAge > 30000) {
      lastQuote = null;
      calc(); // Re-fetch quote
      isTrading = false;
      $('tradeBtn').disabled = false;
      $('tradeBtn').textContent = 'SELL';
      showToast('Quote expired. Please try again.', 'error', 3000);
      return;
    }
    const minCollateralOut = lastQuote.expectedOut * 99n / 100n;

    // For legacy/external markets, use PM_ROUTER (atomic swap+merge)
    if (lastQuote?.isLegacy) {
      const pmRouter = new ethers.Contract(CONTRACTS.PM_ROUTER, PM_ROUTER_ABI, signer);

      // Check operator approval for PM_ROUTER
      const isOp = await pamm.isOperator(connectedAddress, CONTRACTS.PM_ROUTER);
      if (!isOp) {
        const approveTx = await pamm.setOperator(CONTRACTS.PM_ROUTER, true);
        await approveTx.wait();
      }

      // PM_ROUTER.sell handles the swap+merge atomically
      tx = await pmRouter.sell(
        BigInt(m.marketId),
        sellYes,
        sharesIn,
        minCollateralOut,
        LEGACY_FEE_BPS, // 30 bps fee tier
        connectedAddress,
        deadline
      );
    } else {
      const router = new ethers.Contract(CONTRACTS.MASTER_ROUTER, MASTER_ROUTER_ABI, signer);
      const routerInterface = new ethers.Interface(MASTER_ROUTER_ABI);
      const pammInterface = new ethers.Interface(PAMM_ABI);

      // Check operator approval for MasterRouter
      const isOp = await pamm.isOperator(connectedAddress, CONTRACTS.MASTER_ROUTER);

      // Build the sell calldata based on routing
      let sellCalldata;
      if (lastQuote?.useBookBuilding) {
        const yesPrice = lastQuote.ammSpotPriceBps || 5000;
        const sidePrice = sellYes ? yesPrice : (10000 - yesPrice);
        const minSweepPrice = Math.max(sidePrice - 100, 1);
        const askPrice = Math.max(sidePrice - 50, 1);
        sellCalldata = routerInterface.encodeFunctionData('sellWithAskFallback', [
          m.marketId, sellYes, sharesIn, minSweepPrice, askPrice, connectedAddress, deadline
        ]);
      } else {
        sellCalldata = routerInterface.encodeFunctionData('sellWithSweep', [
          m.marketId, sellYes, sharesIn, minCollateralOut, 1, connectedAddress, deadline
        ]);
      }

      // Try EIP-5792 atomic batching if we need operator approval
      if (!isOp && await supportsAtomicBatch()) {
        showToast('Confirm operator approval + sell in your wallet...', 'pending');

        const setOperatorCalldata = pammInterface.encodeFunctionData('setOperator', [
          CONTRACTS.MASTER_ROUTER, true
        ]);

        const batchResult = await sendBatchedCalls([
          { to: CONTRACTS.PAMM, data: setOperatorCalldata },
          { to: CONTRACTS.MASTER_ROUTER, data: sellCalldata }
        ]);

        if (batchResult.success) {
          tx = { hash: batchResult.hash, wait: async () => provider.getTransactionReceipt(batchResult.hash) };
        } else {
          throw new Error(batchResult.error || 'Batch transaction failed');
        }
      } else {
        // Traditional flow: approve then sell
        if (!isOp) {
          showToast('Approving router to manage your shares...', 'pending');
          const approveTx = await pamm.setOperator(CONTRACTS.MASTER_ROUTER, true);
          await approveTx.wait();
        }

        if (lastQuote?.useBookBuilding) {
          const yesPrice = lastQuote.ammSpotPriceBps || 5000;
          const sidePrice = sellYes ? yesPrice : (10000 - yesPrice);
          const minSweepPrice = Math.max(sidePrice - 100, 1);
          const askPrice = Math.max(sidePrice - 50, 1);
          tx = await router.sellWithAskFallback(m.marketId, sellYes, sharesIn, minSweepPrice, askPrice, connectedAddress, deadline);
        } else {
          tx = await router.sellWithSweep(m.marketId, sellYes, sharesIn, minCollateralOut, 1, connectedAddress, deadline);
        }
      }
    }

    // Save direction before closeDrop() clears it
    const side = dir === 'Y' ? 'YES' : 'NO';
    const usedBookBuilding = lastQuote?.useBookBuilding && !lastQuote?.isLegacy;

    showTxPending(tx.hash);
    const receipt = await tx.wait();

    // Show success immediately after confirmation
    if (usedBookBuilding) {
      const yesPrice = lastQuote.ammSpotPriceBps || 5000;
      const sidePrice = dir === 'Y' ? yesPrice : (10000 - yesPrice);
      const listPrice = ((sidePrice - 50) / 100).toFixed(1);
      showTxSuccess(`Listed ${side} for sale at ${listPrice}%`, receipt.hash);
    } else {
      showTxSuccess(`Sold ${side} shares!`, receipt.hash);
    }

    // Refresh odds and positions (don't let failures hide success toast)
    try {
      m.y = await loadMarketOdds(m.marketId);
      await loadPositions();
      render();
    } catch (refreshErr) {
      console.warn('Refresh after sell failed:', refreshErr);
    }

    $('amt').value = '';
    $('out').textContent = '0.00';
    lastQuote = null;
    closeDrop();

  } catch (e) {
    console.error('Sell failed:', e);
    const msg = e.reason || e.message || 'Unknown error';
    hideToast();
    if (!msg.toLowerCase().includes('user rejected')) {
      showTxError('Sell failed: ' + msg);
    }
  } finally {
    isTrading = false;
    $('tradeBtn').disabled = false;
    $('tradeBtn').textContent = 'SELL';
    // Check if wallet/chain changed during transaction
    if (window._pendingReload) {
      window._pendingReload = false;
      window.location.reload();
    }
  }
}

// ======================== COMBINED MARKET DATA LOADER ========================
// Batches all RPC calls for a market into parallel requests
let loadingMarketId = null; // Track which market is currently loading

async function loadAllMarketData() {
  const m = markets[currentIndex];
  if (!m?.marketId) return;

  const marketId = m.marketId;

  // Skip if already loading this market, or abort if different market started loading
  if (loadingMarketId === marketId) return;
  loadingMarketId = marketId;

  const rpc = provider || await getRpc();
  const pamm = new ethers.Contract(CONTRACTS.PAMM, PAMM_ABI, rpc);
  const isLabeled = isOurLabeledMarket(m.description);

  // Get or fetch noId (immutable, safe to cache forever)
  let cached = marketDataCache.get(marketId);
  let noId;
  if (cached?.noId) {
    noId = cached.noId;
  } else {
    noId = await pamm.getNoId(BigInt(marketId));
    cached = { noId };
    cacheSet(marketDataCache, marketId, cached, MAX_MARKET_CACHE);
  }

  const yesId = BigInt(marketId);
  const yesIsId0 = yesId < noId;
  const buyYes = dir !== 'N';

  // Build parallel call array based on market type and connection state
  const calls = [];
  const callMap = {};

  if (isLabeled) {
    const quoter = new ethers.Contract(CONTRACTS.QUOTER, QUOTER_ABI, rpc);

    // Always fetch market summary and liquidity breakdown (needed for depth bar)
    calls.push(quoter.getMarketSummary(marketId, { gasLimit: 5000000 }));
    callMap.summary = calls.length - 1;

    // Fetch breakdown for current direction (for depth bar display)
    calls.push(quoter.getLiquidityBreakdown(marketId, buyYes, { gasLimit: 5000000 }));
    callMap.breakdown = calls.length - 1;

    // Also fetch opposite direction's breakdown (for total bid pool collateral in TVL)
    calls.push(quoter.getLiquidityBreakdown(marketId, !buyYes, { gasLimit: 5000000 }));
    callMap.breakdownOther = calls.length - 1;

    // User position data if connected
    if (connectedAddress) {
      calls.push(quoter.getUserFullPosition(marketId, connectedAddress, { gasLimit: 5000000 }));
      callMap.userPos = calls.length - 1;
    }
  } else {
    // Legacy market - fetch pool state
    calls.push(pamm.getPoolState(BigInt(marketId), LEGACY_FEE_BPS));
    callMap.poolState = calls.length - 1;

    // User balances if connected
    if (connectedAddress) {
      calls.push(pamm.balanceOf(connectedAddress, BigInt(marketId)));
      callMap.yesBal = calls.length - 1;
      calls.push(pamm.balanceOf(connectedAddress, BigInt(noId)));
      callMap.noBal = calls.length - 1;
    }
  }

  // AMM LP balance if connected
  if (connectedAddress) {
    const zamm = new ethers.Contract(CONTRACTS.ZAMM, ZAMM_ABI, rpc);
    const poolId = calculatePoolId(marketId, isLabeled);
    calls.push(zamm.balanceOf(connectedAddress, poolId));
    callMap.ammLpBal = calls.length - 1;
    calls.push(zamm.pools(poolId));
    callMap.poolData = calls.length - 1;
    cached.poolId = poolId;
  }

  // Execute all calls in parallel
  const results = await Promise.all(calls.map(c => c.catch(e => ({ error: e }))));

  // Store results in cache for use by render functions
  cached.results = results;
  cached.callMap = callMap;
  cached.isLabeled = isLabeled;
  cached.noId = noId;
  cached.yesIsId0 = yesIsId0;
  cached.lastLoaded = Date.now();
  cacheSet(marketDataCache, marketId, cached, MAX_MARKET_CACHE);

  // Sync odds bar immediately from AMM spot price (regardless of panel state)
  try {
    let spotBps = null; // null = not loaded, 0+ = valid price
    if (isLabeled && callMap.summary !== undefined) {
      const summary = results[callMap.summary];
      if (summary && !summary.error && summary.ammPriceYesBps !== undefined) {
        spotBps = Number(summary.ammPriceYesBps);
      }
    } else if (callMap.poolState !== undefined) {
      const poolState = results[callMap.poolState];
      if (poolState && !poolState.error) {
        const ammYes = Number(poolState.rYes) / 1e18;
        const ammNo = Number(poolState.rNo) / 1e18;
        const total = ammYes + ammNo;
        spotBps = total > 0 ? Math.round((ammNo / total) * 10000) : 0;
      }
    }
    // Update odds bar if we're still viewing this market and have valid price
    // Note: spotBps=0 is valid (0% YES), only skip if null (not loaded)
    const currentM = markets[currentIndex];
    if (spotBps !== null && currentM?.marketId === marketId) {
      const yPct = spotBps / 100;
      currentM.y = yPct;
      currentM.oddsLoaded = true;
      setOddsBar(yPct);
      cacheMarkets(markets); // Persist updated odds to cache
    }
  } catch (e) {
    console.warn('Odds sync failed:', e);
  }

  // Calculate total bid pool collateral from both directions and update TVL
  try {
    if (isLabeled && callMap.breakdown !== undefined && callMap.breakdownOther !== undefined) {
      const breakdown = results[callMap.breakdown];
      const breakdownOther = results[callMap.breakdownOther];
      const bidDepth1 = breakdown && !breakdown.error ? Number(breakdown.poolBidDepth) / 1e18 : 0;
      const bidDepth2 = breakdownOther && !breakdownOther.error ? Number(breakdownOther.poolBidDepth) / 1e18 : 0;
      const totalBidPoolCollateral = bidDepth1 + bidDepth2;

      // Store on market object for TVL display
      const currentM = markets[currentIndex];
      if (currentM?.marketId === marketId) {
        currentM.bidPoolCollateral = totalBidPoolCollateral;
        // Update TVL display in header
        const collateralSym = getCollateralSymbol(currentM.collateral);
        const totalLiquidity = (currentM.tvl || 0) + totalBidPoolCollateral;
        const tvlStr = totalLiquidity < 1 ? totalLiquidity.toFixed(4) : totalLiquidity.toFixed(2);
        const metaEl = $('meta');
        if (metaEl && metaEl.innerHTML.includes('|')) {
          // Update just the TVL portion by re-rendering
          render();
        }
      }
    }
  } catch (e) {
    console.warn('Bid pool TVL calc failed:', e);
  }

  // Check if user navigated away during load - abort if so
  if (markets[currentIndex]?.marketId !== marketId) {
    loadingMarketId = null;
    return;
  }

  // Now process results in parallel render functions
  await Promise.all([
    processPositionsData(m, cached),
    processPriceChartData(m, cached),
    processResolutionData(m, cached)
  ]);

  // Clear loading flag
  loadingMarketId = null;
}

// Process positions from cached data
async function processPositionsData(m, cached) {
  if (!connectedAddress || !m?.marketId) {
    userPositions = { yes: 0n, no: 0n };
    lpPositions = { yesVault: 0n, noVault: 0n, ammLP: 0n, yesFees: 0n, noFees: 0n };
    vaultStats = { yesTotalShares: 0n, noTotalShares: 0n, yesUnderlying: 0n, noUnderlying: 0n, yesTotalFees: 0n, noTotalFees: 0n };
    poolStats = { reserve0: 0n, reserve1: 0n, totalSupply: 0n, userShare: 0, yesReserve: 0n, noReserve: 0n, impliedYesPrice: 50 };
    renderPositions();
    return;
  }

  const { results, callMap, noId, yesIsId0 } = cached;
  // Recalculate isLabeled from current description (cache may be stale after code updates)
  const isLabeled = isOurLabeledMarket(m.description);

  // If cache is stale (labeled but no summary), skip - processPriceChartData will trigger refresh
  if (isLabeled && callMap.summary === undefined) {
    renderPositions();
    return;
  }

  try {
    if (isLabeled) {
      const summary = results[callMap.summary];
      const userPos = results[callMap.userPos];

      if (summary?.error || userPos?.error) throw summary?.error || userPos?.error;

      userPositions = {
        yes: BigInt(userPos.yesShareBalance),
        no: BigInt(userPos.noShareBalance)
      };

      lpPositions.yesVault = BigInt(userPos.yesVaultLP);
      lpPositions.noVault = BigInt(userPos.noVaultLP);
      lpPositions.yesFees = BigInt(userPos.pendingYesCollateral);
      lpPositions.noFees = BigInt(userPos.pendingNoCollateral);

      vaultStats.yesTotalShares = BigInt(summary.totalYesVaultLP);
      vaultStats.noTotalShares = BigInt(summary.totalNoVaultLP);
      vaultStats.yesUnderlying = BigInt(summary.vaultYesShares);
      vaultStats.noUnderlying = BigInt(summary.vaultNoShares);

      poolStats.yesReserve = BigInt(summary.ammYesReserve);
      poolStats.noReserve = BigInt(summary.ammNoReserve);
      poolStats.reserve0 = yesIsId0 ? poolStats.yesReserve : poolStats.noReserve;
      poolStats.reserve1 = yesIsId0 ? poolStats.noReserve : poolStats.yesReserve;
      poolStats.impliedYesPrice = Number(summary.ammPriceYesBps) / 100;
    } else {
      const poolState = results[callMap.poolState];
      const yesBal = results[callMap.yesBal];
      const noBal = results[callMap.noBal];

      if (poolState?.error) throw poolState.error;

      userPositions = {
        yes: BigInt(yesBal || 0n),
        no: BigInt(noBal || 0n)
      };

      lpPositions.yesVault = 0n;
      lpPositions.noVault = 0n;
      lpPositions.yesFees = 0n;
      lpPositions.noFees = 0n;
      vaultStats = { yesTotalShares: 0n, noTotalShares: 0n, yesUnderlying: 0n, noUnderlying: 0n, yesTotalFees: 0n, noTotalFees: 0n };

      poolStats.yesReserve = BigInt(poolState.rYes);
      poolStats.noReserve = BigInt(poolState.rNo);
      poolStats.reserve0 = yesIsId0 ? poolStats.yesReserve : poolStats.noReserve;
      poolStats.reserve1 = yesIsId0 ? poolStats.noReserve : poolStats.yesReserve;
      const total = poolStats.yesReserve + poolStats.noReserve;
      poolStats.impliedYesPrice = total > 0n ? Number(poolStats.noReserve * 10000n / total) / 100 : 50;
    }

    // AMM LP balance
    if (callMap.ammLpBal !== undefined) {
      const userLpBal = results[callMap.ammLpBal];
      const poolData = results[callMap.poolData];
      if (!userLpBal?.error) {
        lpPositions.ammLP = BigInt(userLpBal);
        if (!poolData?.error && poolData.totalSupply > 0n) {
          poolStats.totalSupply = BigInt(poolData.totalSupply);
          poolStats.userShare = Number(lpPositions.ammLP * 10000n / poolStats.totalSupply) / 100;
        }
      }
    }

    renderPositions();
  } catch (e) {
    console.warn('Error processing positions:', e);
    renderPositions();
  }
}

// Process price chart from cached data
async function processPriceChartData(m, cached) {
  const chartSection = $('chartSection');

  if (!m?.marketId) {
    chartSection.style.display = 'none';
    return;
  }

  const { results, callMap, noId, yesIsId0, poolId } = cached;
  // Recalculate isLabeled from current description (cache may be stale after code updates)
  const isLabeled = isOurLabeledMarket(m.description);
  const buyYes = dir !== 'N';

  // If isLabeled changed (e.g., NFTBAL added), cache is stale - trigger fresh load
  if (isLabeled && callMap.summary === undefined) {
    marketDataCache.delete(m.marketId);
    loadLiquidityPanel();
    return;
  }

  try {
    let ammYes = 0, ammNo = 0, spotBps = 0, feeBps = 0;
    let vaultShares = 0, vaultPrice = 0, hasVault = false;
    let liqBreakdown = null;

    if (isLabeled) {
      const summary = results[callMap.summary];
      const breakdown = callMap.breakdown !== undefined ? results[callMap.breakdown] : null;

      if (summary?.error) throw summary.error;

      spotBps = Number(summary.ammPriceYesBps);
      priceChart.twapBps = Number(summary.twapPriceYesBps);
      feeBps = Number(summary.feeBps);
      ammYes = Number(summary.ammYesReserve) / 1e18;
      ammNo = Number(summary.ammNoReserve) / 1e18;

      if (breakdown && !breakdown.error) {
        liqBreakdown = breakdown;
        vaultShares = Number(breakdown.vaultOtcShares) / 1e18;
        vaultPrice = Number(breakdown.vaultOtcPriceBps) / 100;
        hasVault = breakdown.vaultOtcAvailable && vaultShares > 0;
      }
    } else {
      const poolState = results[callMap.poolState];
      if (poolState && !poolState.error) {
        ammYes = Number(poolState.rYes) / 1e18;
        ammNo = Number(poolState.rNo) / 1e18;
        const total = ammYes + ammNo;
        spotBps = total > 0 ? Math.round((ammNo / total) * 10000) : 0;
        feeBps = LEGACY_FEE_BPS;
        priceChart.twapBps = 0;
      }
      hasVault = false;
    }

    priceChart.spotBps = spotBps;
    priceChart.poolId = poolId;

    // Sync main odds bar with fresh spot price (always, even if panel closed)
    // Note: spotBps=0 is valid (0% YES), only skip if undefined/null
    if (typeof spotBps === 'number') {
      m.y = spotBps / 100;
      m.oddsLoaded = true;
      setOddsBar(m.y);
    }

    // Update liquidity depths for depth bar (always, even if panel closed)
    // Show TVL breakdown: where is the collateral actually sitting?
    if (isLabeled) {
      const summary = results[callMap.summary];
      // Vaults: total shares held by YES and NO vaults (each share backed by collateral)
      const vaultYes = summary ? Number(summary.vaultYesShares) / 1e18 : 0;
      const vaultNo = summary ? Number(summary.vaultNoShares) / 1e18 : 0;
      liquidityDepths.vault = vaultYes + vaultNo;

      // AMM: min of reserves = matched pairs = collateral value locked in AMM
      liquidityDepths.amm = Math.min(ammYes, ammNo);

      // Orders: total bid pool collateral (from both directions, calculated earlier)
      liquidityDepths.bids = m.bidPoolCollateral || 0;

      updateLiquidityDepthBar();
    }

    // If panel is closed, don't render the rest of the chart UI
    if (!liqPanelOpen) {
      chartSection.style.display = 'none';
      return;
    }
    chartSection.style.display = 'block';

    // Update spot/TWAP/fee display
    $('chartSpot').textContent = typeof spotBps === 'number' ? (spotBps / 100).toFixed(1) + '%' : '--';
    $('chartFee').textContent = feeBps > 0 ? (feeBps / 100).toFixed(2) + '%' : '--';

    const twapRow = $('chartTwapRow');
    if (priceChart.twapBps > 0) {
      $('chartTwap').textContent = (priceChart.twapBps / 100).toFixed(1) + '%';
      twapRow.style.display = '';
    } else {
      twapRow.style.display = 'none';
    }

    // Update liquidity breakdown display (detailed panel view)
    updateLiquidityDisplay(ammYes, ammNo, hasVault, vaultShares, vaultPrice, liqBreakdown, buyYes, isLabeled, m);

    // Update ZAMM link
    if (poolId) {
      const poolIdDecimal = BigInt(poolId).toString();
      $('chartLink').href = `https://zamm.finance/p/1/${poolIdDecimal}`;
    }

    // Update liquidity sources
    liquiditySources = { hasVault, hasBidPool: false, hasAmm: ammYes > 0 || ammNo > 0 };
    updateLiquidityIndicator();

    renderPriceChart();
  } catch (e) {
    console.warn('Error processing price chart:', e);
    $('chartContainer').innerHTML = '<div class="chart-empty">Price data unavailable</div>';
  }
}

// Process resolution data - delegates to existing loadResolutionStatus
// (kept separate due to complex oracle type detection logic)
async function processResolutionData(m, cached) {
  // Resolution loading has complex oracle detection logic that may need
  // additional RPC calls (token symbols, decimals), so delegate to existing function
  await loadResolutionStatus();
}

// Helper to update liquidity breakdown display
function updateLiquidityDisplay(ammYes, ammNo, hasVault, vaultShares, vaultPrice, liqBreakdown, buyYes, isLabeled, m) {
  const liqSection = $('liquidityBreakdown');
  liqSection.style.display = 'block';

  const vaultRow = $('liqVaultRow');
  if (hasVault) {
    const vaultAmt = vaultShares < 0.01 ? vaultShares.toFixed(4) : vaultShares.toFixed(2);
    $('liqVault').textContent = `${vaultAmt} @ ${vaultPrice.toFixed(1)}%`;
    vaultRow.style.display = '';
  } else {
    vaultRow.style.display = 'none';
  }

  const ammRow = $('liqAmmRow');
  const ammTotal = ammYes + ammNo;
  if (ammTotal > 0.001) {
    const ammAmt = ammTotal < 0.01 ? ammTotal.toFixed(4) : ammTotal.toFixed(2);
    $('liqAmm').textContent = ammAmt;
    ammRow.style.display = '';
  } else {
    ammRow.style.display = 'none';
  }

  // Update liquidity depths for the depth bar visualization
  liquidityDepths.amm = (ammYes + ammNo) / 2; // Use average as depth proxy
  liquidityDepths.vault = hasVault ? vaultShares : 0;

  // Order book from breakdown if available
  const bidPoolRow = $('liqBidPoolRow');
  if (liqBreakdown) {
    const askDepth = Number(liqBreakdown.poolAskDepth) / 1e18;
    const bidDepth = Number(liqBreakdown.poolBidDepth) / 1e18;
    const relevantDepth = buyYes ? askDepth : bidDepth;
    const relevantPrice = buyYes ? Number(liqBreakdown.poolBestAskBps) / 100 : Number(liqBreakdown.poolBestBidBps) / 100;

    // Track total bid pool depth (both sides)
    liquidityDepths.bids = askDepth + bidDepth;

    if (relevantDepth > 0.001) {
      const depthAmt = relevantDepth < 0.01 ? relevantDepth.toFixed(4) : relevantDepth.toFixed(2);
      $('liqBidPoolAmt').textContent = depthAmt;
      $('liqBidPoolPrice').textContent = relevantPrice.toFixed(1) + '%';
      bidPoolRow.style.display = '';
      liquiditySources.hasBidPool = true;
    } else {
      bidPoolRow.style.display = 'none';
    }
  } else {
    liquidityDepths.bids = 0;
    bidPoolRow.style.display = 'none';
  }

  // Update the visual liquidity depth bar
  updateLiquidityDepthBar();
}

// ======================== POSITIONS ========================
async function loadPositions() {
  const m = markets[currentIndex];
  const capturedMarketId = m?.marketId; // Capture for stale check
  if (!connectedAddress || !capturedMarketId) {
    userPositions = { yes: 0n, no: 0n };
    lpPositions = { yesVault: 0n, noVault: 0n, ammLP: 0n, yesFees: 0n, noFees: 0n };
    vaultStats = { yesTotalShares: 0n, noTotalShares: 0n, yesUnderlying: 0n, noUnderlying: 0n, yesTotalFees: 0n, noTotalFees: 0n };
    poolStats = { reserve0: 0n, reserve1: 0n, totalSupply: 0n, userShare: 0, yesReserve: 0n, noReserve: 0n, impliedYesPrice: 50 };
    renderPositions();
    return;
  }

  try {
    const rpc = provider || await getRpc();
    const pamm = new ethers.Contract(CONTRACTS.PAMM, PAMM_ABI, rpc);
    const zamm = new ethers.Contract(CONTRACTS.ZAMM, ZAMM_ABI, rpc);
    const isLabeled = isOurLabeledMarket(m.description);
    const noId = await pamm.getNoId(BigInt(m.marketId));
    // Abort if user switched markets during async call
    if (markets[currentIndex]?.marketId !== capturedMarketId) return;
    const yesId = BigInt(m.marketId);
    const yesIsId0 = yesId < noId;

    // For labeled markets, use Quoter; for legacy/external, query directly
    if (isLabeled) {
      const quoter = new ethers.Contract(CONTRACTS.QUOTER, QUOTER_ABI, rpc);

      // Single call for user positions + vault LP + pending fees (replaces ~6 calls)
      // Single call for market summary (replaces ~5 calls)
      const [userPos, marketSummary] = await Promise.all([
        quoter.getUserFullPosition(m.marketId, connectedAddress, { gasLimit: 5000000 }),
        quoter.getMarketSummary(m.marketId, { gasLimit: 5000000 })
      ]);
      // Abort if user switched markets during async call
      if (markets[currentIndex]?.marketId !== capturedMarketId) return;

      // User trading positions
      userPositions = {
        yes: BigInt(userPos.yesShareBalance),
        no: BigInt(userPos.noShareBalance)
      };

      // User vault LP positions + pending fees (already calculated by quoter!)
      lpPositions.yesVault = BigInt(userPos.yesVaultLP);
      lpPositions.noVault = BigInt(userPos.noVaultLP);
      lpPositions.yesFees = BigInt(userPos.pendingYesCollateral);
      lpPositions.noFees = BigInt(userPos.pendingNoCollateral);

      // Market/vault stats from summary
      vaultStats.yesTotalShares = BigInt(marketSummary.totalYesVaultLP);
      vaultStats.noTotalShares = BigInt(marketSummary.totalNoVaultLP);
      vaultStats.yesUnderlying = BigInt(marketSummary.vaultYesShares);
      vaultStats.noUnderlying = BigInt(marketSummary.vaultNoShares);
      vaultStats.yesTotalFees = 0n;
      vaultStats.noTotalFees = 0n;

      // Pool stats from summary
      poolStats.yesReserve = BigInt(marketSummary.ammYesReserve);
      poolStats.noReserve = BigInt(marketSummary.ammNoReserve);
      poolStats.reserve0 = yesIsId0 ? poolStats.yesReserve : poolStats.noReserve;
      poolStats.reserve1 = yesIsId0 ? poolStats.noReserve : poolStats.yesReserve;
      poolStats.impliedYesPrice = Number(marketSummary.ammPriceYesBps) / 100;
    } else {
      // Legacy/external market - query PAMM directly
      // Get user share balances directly from PAMM
      const [yesBal, noBal] = await Promise.all([
        pamm.balanceOf(connectedAddress, BigInt(m.marketId)),
        pamm.balanceOf(connectedAddress, BigInt(noId))
      ]);
      // Abort if user switched markets during async call
      if (markets[currentIndex]?.marketId !== capturedMarketId) return;

      userPositions = {
        yes: BigInt(yesBal),
        no: BigInt(noBal)
      };

      // Legacy markets don't have vault infrastructure
      lpPositions.yesVault = 0n;
      lpPositions.noVault = 0n;
      lpPositions.yesFees = 0n;
      lpPositions.noFees = 0n;
      vaultStats = { yesTotalShares: 0n, noTotalShares: 0n, yesUnderlying: 0n, noUnderlying: 0n, yesTotalFees: 0n, noTotalFees: 0n };

      // Get pool state for legacy market (30 bps fee)
      const poolState = await pamm.getPoolState(BigInt(m.marketId), LEGACY_FEE_BPS);
      poolStats.yesReserve = BigInt(poolState.rYes);
      poolStats.noReserve = BigInt(poolState.rNo);
      poolStats.reserve0 = yesIsId0 ? poolStats.yesReserve : poolStats.noReserve;
      poolStats.reserve1 = yesIsId0 ? poolStats.noReserve : poolStats.yesReserve;
      const total = poolStats.yesReserve + poolStats.noReserve;
      poolStats.impliedYesPrice = total > 0n ? Number(poolStats.noReserve * 10000n / total) / 100 : 50;
    }

    // AMM LP balance still needs separate call (not in quoter)
    try {
      const poolId = calculatePoolId(m.marketId, isLabeled);

      const [userLpBal, poolData] = await Promise.all([
        zamm.balanceOf(connectedAddress, poolId),
        zamm.pools(poolId)
      ]);
      // Abort if user switched markets during async call
      if (markets[currentIndex]?.marketId !== capturedMarketId) return;

      lpPositions.ammLP = userLpBal;
      poolStats.totalSupply = BigInt(poolData.supply);
      poolStats.userShare = poolStats.totalSupply > 0n
        ? Number(userLpBal * 10000n / poolStats.totalSupply) / 100
        : 0;
    } catch (e) {
      lpPositions.ammLP = 0n;
      poolStats.totalSupply = 0n;
      poolStats.userShare = 0;
    }

    renderPositions();
  } catch (e) {
    console.warn('Failed to load positions:', e);
    userPositions = { yes: 0n, no: 0n };
    lpPositions = { yesVault: 0n, noVault: 0n, ammLP: 0n, yesFees: 0n, noFees: 0n };
    vaultStats = { yesTotalShares: 0n, noTotalShares: 0n, yesUnderlying: 0n, noUnderlying: 0n, yesTotalFees: 0n, noTotalFees: 0n };
    poolStats = { reserve0: 0n, reserve1: 0n, totalSupply: 0n, userShare: 0, yesReserve: 0n, noReserve: 0n, impliedYesPrice: 50 };
    renderPositions();
  }
}

function renderPositions() {
  const m = markets[currentIndex];
  const hasPosition = userPositions.yes > 0n || userPositions.no > 0n;
  const hasLPPosition = lpPositions.yesVault > 0n || lpPositions.noVault > 0n || lpPositions.ammLP > 0n;

  // Only show positions box if user has trading position, LP position, or liq panel is open (for LP button)
  const showPositions = connectedAddress && m?.marketId && (
    hasPosition ||
    hasLPPosition ||
    (liqPanelOpen && !m.resolved) // Show for LP button access even with no positions
  );
  $('positions').style.display = showPositions ? 'block' : 'none';

  $('yesBalance').textContent = formatShares(userPositions.yes);
  $('noBalance').textContent = formatShares(userPositions.no);

  // Show/hide LP button based on market state and liq panel toggle
  $('lpBtnPos').style.display = (m?.resolved || !liqPanelOpen) ? 'none' : 'block';

  // Handle LP positions display (only if liq panel is open)
  const lpPosSection = $('lpPositions');
  if (hasLPPosition && liqPanelOpen) {
    lpPosSection.style.display = 'block';
    $('yesVaultBalance').textContent = formatShares(lpPositions.yesVault);
    $('noVaultBalance').textContent = formatShares(lpPositions.noVault);
    $('ammLpBalance').textContent = formatShares(lpPositions.ammLP);

    // Display pending fees (earned, harvestable)
    $('yesVaultFees').textContent = lpPositions.yesFees > 0n ? `+${formatFees(lpPositions.yesFees, m.collateral)}` : '';
    $('noVaultFees').textContent = lpPositions.noFees > 0n ? `+${formatFees(lpPositions.noFees, m.collateral)}` : '';

    // Enable/disable harvest buttons (only when fees > 0)
    $('yesHarvestBtn').disabled = lpPositions.yesFees === 0n;
    $('noHarvestBtn').disabled = lpPositions.noFees === 0n;

    // Enable/disable withdraw buttons
    $('yesVaultWithdrawBtn').disabled = lpPositions.yesVault === 0n;
    $('noVaultWithdrawBtn').disabled = lpPositions.noVault === 0n;
    $('ammLpWithdrawBtn').disabled = lpPositions.ammLP === 0n;

    // Display pool stats (only if user has AMM LP)
    const poolStatsEl = $('poolStats');
    if (lpPositions.ammLP > 0n && poolStats.totalSupply > 0n) {
      poolStatsEl.style.display = 'block';
      $('poolYesReserve').textContent = formatShares(poolStats.yesReserve);
      $('poolNoReserve').textContent = formatShares(poolStats.noReserve);
      $('poolTotalSupply').textContent = formatShares(poolStats.totalSupply);
      $('poolUserShare').textContent = poolStats.userShare.toFixed(2) + '%';
    } else {
      poolStatsEl.style.display = 'none';
    }
  } else {
    lpPosSection.style.display = 'none';
  }

  // Handle claim section for resolved markets
  const claimSection = $('claimSection');
  if (m?.resolved && hasPosition) {
    const winningShares = m.outcome ? userPositions.yes : userPositions.no;
    const losingShares = m.outcome ? userPositions.no : userPositions.yes;

    if (winningShares > 0n) {
      // User has winning shares - can claim
      const claimableAmt = Number(winningShares) / 1e18;
      const collateralSym = getCollateralSymbol(m.collateral);
      claimSection.style.display = 'block';
      $('claimInfo').textContent = `You have winning ${m.outcome ? 'YES' : 'NO'} shares`;
      $('claimAmount').textContent = `~${claimableAmt.toFixed(4)} ${collateralSym}`;
      $('claimBtn').textContent = 'CLAIM';
      $('claimBtn').disabled = false;
      $('claimBtn').classList.remove('claimed');
    } else if (losingShares > 0n) {
      // User only has losing shares
      const collateralSym = getCollateralSymbol(m.collateral);
      claimSection.style.display = 'block';
      $('claimInfo').textContent = `Your ${m.outcome ? 'NO' : 'YES'} shares lost`;
      $('claimAmount').textContent = `0 ${collateralSym}`;
      $('claimBtn').textContent = 'NO PAYOUT';
      $('claimBtn').disabled = true;
      $('claimBtn').classList.add('claimed');
    } else {
      claimSection.style.display = 'none';
    }
  } else {
    claimSection.style.display = 'none';
  }
}

async function claim() {
  if (!connectedAddress) return toggleWallet();

  const m = markets[currentIndex];
  if (!m?.marketId || !m.resolved) {
    alert('Market is not resolved yet');
    return;
  }

  const winningShares = m.outcome ? userPositions.yes : userPositions.no;
  if (winningShares <= 0n) {
    alert('No winning shares to claim');
    return;
  }

  $('claimBtn').disabled = true;
  $('claimBtn').textContent = '...';

  try {
    const pamm = new ethers.Contract(CONTRACTS.PAMM, PAMM_ABI, signer);
    const tx = await pamm.claim(BigInt(m.marketId), connectedAddress);

    showTxPending(tx.hash);
    const receipt = await tx.wait();
    console.log('Claim tx:', receipt.hash);

    // Show success immediately after confirmation
    showTxSuccess('Claimed winnings!', receipt.hash);

    // Update claim UI to show claimed state
    $('claimBtn').textContent = 'CLAIMED';
    $('claimBtn').classList.add('claimed');
    $('claimInfo').textContent = 'Successfully claimed!';

    // Refresh positions and UI (don't block success toast)
    try {
      await loadPositions();
      render();
    } catch (refreshErr) {
      console.warn('Refresh after claim failed:', refreshErr);
    }

  } catch (e) {
    console.error('Claim failed:', e);
    const msg = e.reason || e.message || 'Unknown error';
    if (!msg.toLowerCase().includes('user rejected')) {
      showTxError('Claim failed: ' + msg);
    } else {
      hideToast();
    }
    $('claimBtn').disabled = false;
    $('claimBtn').textContent = 'CLAIM';
  }
}

// ======================== RESOLUTION ========================

function toggleResolveDetails() {
  resolveDetailsOpen = !resolveDetailsOpen;
  $('resolveToggle').classList.toggle('expanded', resolveDetailsOpen);
  $('resolveDetails').classList.toggle('expanded', resolveDetailsOpen);
}

async function loadResolutionStatus() {
  const m = markets[currentIndex];
  const capturedMarketId = m?.marketId; // Capture for stale check
  const resolveSection = $('resolveSection');
  const toggleStatus = $('resolveToggleStatus');

  if (!capturedMarketId) {
    resolveSection.style.display = 'none';
    return;
  }

  // Check if this market uses our canonical resolver or is a legacy market with compatible resolver
  const resolverLower = m.resolver?.toLowerCase() || '';
  const isOurResolver = resolverLower === CONTRACTS.RESOLVER.toLowerCase();
  const isLegacyMarket = m.isLegacy === true;
  // Legacy markets use onchain resolvers - show friendly name for them too
  const isKnownResolver = isOurResolver || isLegacyMarket;

  // Set resolver label with link
  const toggleLabel = $('resolveToggleLabel');
  if (m.resolver) {
    const resolverName = isKnownResolver ? 'Onchain Resolver' : `${m.resolver.slice(0,6)}...${m.resolver.slice(-4)}`;
    const etherscanUrl = `https://etherscan.io/address/${m.resolver}`;
    toggleLabel.innerHTML = `⚙ <a href="${etherscanUrl}" target="_blank" rel="noopener" onclick="event.stopPropagation()" style="color:inherit;text-decoration:underline;text-decoration-color:#0FF;">${resolverName}</a>`;
  } else {
    toggleLabel.textContent = '⚙ Resolution';
  }

  // Show resolution panel for our resolver OR legacy markets (which may have compatible resolvers)
  if (!isOurResolver && !isLegacyMarket) {
    resolveSection.style.display = 'none';
    return;
  }

  // For resolved markets, show toggle with RESOLVED status
  if (m.resolved) {
    const winner = m.outcome ? 'YES' : 'NO';
    toggleStatus.textContent = `RESOLVED ${winner}`;
    toggleStatus.className = 'resolve-toggle-status resolved';
    $('resolveDetails').innerHTML = `
      <div style="text-align:center;padding:12px;">
        <div style="font-size:24px;margin-bottom:8px;">${m.outcome ? '✓' : '✗'}</div>
        <div style="font-weight:bold;color:${m.outcome ? '#0F0' : '#F00'};">${winner} WINS</div>
      </div>
    `;
    resolveSection.style.display = 'block';
    return;
  }

  // Set up loading state
  const detailsEl = $('resolveDetails');
  detailsEl.innerHTML = `<div style="text-align:center;padding:12px;opacity:0.5;">Loading oracle data...</div>`;
  detailsEl.classList.remove('ready');
  resolveSection.style.display = 'block';

  try {
    const rpc = provider || await getRpc();
    // Use market's resolver address (our canonical resolver or legacy resolver)
    const resolverAddr = isOurResolver ? CONTRACTS.RESOLVER : m.resolver;
    // Use appropriate ABI - legacy resolver has different conditions return format
    const resolverAbi = isOurResolver ? RESOLVER_ABI : LEGACY_RESOLVER_ABI;
    const resolver = new ethers.Contract(resolverAddr, resolverAbi, rpc);

    // Get resolution preview and condition details in parallel
    const [previewResult, condData] = await Promise.all([
      resolver.preview(BigInt(m.marketId)),
      resolver.conditions(BigInt(m.marketId))
    ]);
    // Abort if user switched markets during async call
    if (markets[currentIndex]?.marketId !== capturedMarketId) return;
    const [value, condTrue, ready] = previewResult;

    resolutionStatus.value = value;
    resolutionStatus.threshold = condData.threshold;
    resolutionStatus.condTrue = condTrue;
    resolutionStatus.ready = ready;
    resolutionStatus.op = condData.op;

    const oracleAddr = condData.targetA;
    // Normalize callData to hex string (ethers v6 may return different types)
    let callData = condData.callDataA;
    if (callData && typeof callData !== 'string') {
      callData = ethers.hexlify(callData);
    }
    callData = callData || '';
    const opNames = ['<', '>', '≤', '≥', '=', '≠'];
    const opName = opNames[condData.op] || '?';

    // Detect market type from condition data (not just description)
    // ETH balance: targetA = account, callData = empty
    // ERC20 balance: targetA = token, callData = balanceOf(account)
    // Chainlink price: targetA = feed, callData = latestAnswer()
    const callDataLower = callData.toLowerCase();
    const isBalanceOfCall = callData.length >= 74 && callDataLower.slice(0, 10) === '0x70a08231';
    const isLatestAnswerCall = callData.length >= 10 && callDataLower.slice(0, 10) === '0x50d25bcd';
    const isETHBalanceCheck = oracleAddr && (!callData || callData === '0x' || callData.length < 10);

    // Determine decimals, prefix, suffix based on detected type
    let decimals = 8;
    let prefix = '$';
    let suffix = '';
    let tokenSymbol = '';
    let accountAddr = '';
    let oracleHtml = '';

    if (isBalanceOfCall) {
      // ERC20 or ERC721 balance market
      accountAddr = '0x' + callData.slice(34, 74);
      decimals = 18; // Default for ERC20
      prefix = '';
      let isNFT = false;

      // Try to fetch token symbol and decimals (detect NFT if decimals fails)
      try {
        const tokenContract = new ethers.Contract(oracleAddr, [
          'function symbol() view returns (string)',
          'function decimals() view returns (uint8)',
          'function supportsInterface(bytes4) view returns (bool)'
        ], rpc);

        // Try decimals first
        let decResult = null;
        try {
          decResult = await tokenContract.decimals();
          decimals = Number(decResult);
        } catch (e) {
          // No decimals - check if it's an ERC721
          try {
            isNFT = await tokenContract.supportsInterface('0x80ac58cd');
            if (isNFT) decimals = 0;
          } catch (e2) {
            decimals = 18; // Fallback to ERC20 default
          }
        }

        const sym = await tokenContract.symbol().catch(() => null);
        // Abort if user switched markets during async call
        if (markets[currentIndex]?.marketId !== capturedMarketId) return;
        tokenSymbol = sym || oracleAddr.slice(0, 6);
        suffix = isNFT ? ` ${tokenSymbol} NFTs` : ` ${tokenSymbol}`;
      } catch (e) {
        suffix = isNFT ? ' NFTs' : ' tokens';
      }

      // Build oracle display: account on token (with logo if available)
      const accountAddrLower = accountAddr.toLowerCase();
      const accountName = ACCOUNT_NAMES[accountAddrLower] || `${accountAddr.slice(0,6)}...${accountAddr.slice(-4)}`;
      const shortToken = tokenSymbol || `${oracleAddr.slice(0,6)}...${oracleAddr.slice(-4)}`;
      const tokenLogo = getTokenLogo(oracleAddr);
      const tokenColor = COLORS[tokenSymbol?.toUpperCase()] || '#375BD2';
      oracleHtml = `<a href="https://etherscan.io/address/${accountAddr}" target="_blank" rel="noopener" style="color:inherit;text-decoration:underline;text-decoration-color:${tokenColor}" title="${accountAddr}">${accountName}</a>`;
      oracleHtml += ` <span style="opacity:0.5">bal on</span> `;
      oracleHtml += `<a href="https://etherscan.io/token/${oracleAddr}" target="_blank" rel="noopener" style="color:inherit;text-decoration:underline;text-decoration-color:${tokenColor}" title="${tokenSymbol || 'Token'} contract">${tokenLogo}${shortToken}</a>`;

    } else if (isETHBalanceCheck) {
      // Could be ETH balance OR legacy token balance with non-standard format
      // Check if oracleAddr is actually a token contract
      let isTokenContract = false;
      let tokenSym = '';
      try {
        const testContract = new ethers.Contract(oracleAddr, ['function symbol() view returns (string)', 'function decimals() view returns (uint8)'], rpc);
        tokenSym = await testContract.symbol().catch(() => null);
        if (tokenSym && tokenSym.length > 0 && tokenSym.length <= 10) {
          isTokenContract = true;
          decimals = Number(await testContract.decimals().catch(() => 18));
        }
      } catch (e) {}

      if (isTokenContract) {
        // Legacy token balance market - oracleAddr is the token
        // Account should be in targetB if not in callData
        accountAddr = condData.targetB && condData.targetB !== ethers.ZeroAddress
          ? condData.targetB
          : oracleAddr; // Fallback to oracleAddr if no other source
        tokenSymbol = tokenSym;
        prefix = '';
        suffix = ` ${tokenSymbol}`;

        const shortAccount = `${accountAddr.slice(0,6)}...${accountAddr.slice(-4)}`;
        const shortToken = tokenSymbol;
        const tokenLogo = getTokenLogo(oracleAddr);
        const tokenColor = COLORS[tokenSymbol.toUpperCase()] || '#375BD2';
        oracleHtml = `<a href="https://etherscan.io/address/${accountAddr}" target="_blank" rel="noopener" style="color:inherit;text-decoration:underline;text-decoration-color:${tokenColor}" title="Account being checked: ${accountAddr}">${shortAccount}</a>`;
        oracleHtml += ` <span style="opacity:0.5">bal on</span> `;
        oracleHtml += `<a href="https://etherscan.io/token/${oracleAddr}" target="_blank" rel="noopener" style="color:inherit;text-decoration:underline;text-decoration-color:${tokenColor}" title="${tokenSymbol} token: ${oracleAddr}">${tokenLogo}${shortToken}</a>`;
      } else {
        // ETH balance market - targetA is the account being checked
        accountAddr = oracleAddr;
        decimals = 18;
        prefix = '';
        suffix = ' ETH';

        const shortAccount = `${accountAddr.slice(0,6)}...${accountAddr.slice(-4)}`;
        const ethLogo = TOKEN_LOGOS['eth'] || '';
        oracleHtml = `<a href="https://etherscan.io/address/${accountAddr}" target="_blank" rel="noopener" style="color:inherit;text-decoration:underline;text-decoration-color:#627EEA" title="Account ETH balance">${shortAccount}</a> <span style="opacity:0.5">${ethLogo}ETH bal</span>`;
      }

    } else if (isLatestAnswerCall) {
      // Chainlink price feed
      decimals = 8;
      prefix = '$';
      suffix = '';

      const shortOracle = `${oracleAddr.slice(0,6)}...${oracleAddr.slice(-4)}`;
      // Use LINK token logo for Chainlink price feeds
      const chainlinkLogo = TOKEN_LOGOS['0x514910771af9ca656af840dff83e8264ecf986ca'] || '';
      oracleHtml = `<a href="https://etherscan.io/address/${oracleAddr}" target="_blank" rel="noopener" style="color:inherit;text-decoration:underline;text-decoration-color:#375BD2" title="Chainlink price feed">${chainlinkLogo}${shortOracle}</a> <span style="opacity:0.5">price feed</span>`;

    } else if (callData && callData.slice(0, 10).toLowerCase() === '0x18160ddd') {
      // totalSupply() call - raw count, no decimals
      decimals = 0;
      prefix = '';
      suffix = ' minted';

      // Try to fetch contract name/symbol for better display
      let contractName = '';
      let contractSymbol = '';
      try {
        const contract = new ethers.Contract(oracleAddr, [
          'function name() view returns (string)',
          'function symbol() view returns (string)'
        ], rpc);
        const [name, symbol] = await Promise.all([
          contract.name().catch(() => null),
          contract.symbol().catch(() => null)
        ]);
        // Abort if user switched markets during async call
        if (markets[currentIndex]?.marketId !== capturedMarketId) return;
        contractName = name || '';
        contractSymbol = symbol || '';
      } catch (e) {}

      const shortAddr = `${oracleAddr.slice(0,6)}...${oracleAddr.slice(-4)}`;
      const displayName = contractName || contractSymbol || shortAddr;

      // Check for known NFT collections with custom logos
      const lowerName = (contractName || '').toLowerCase();
      const lowerSymbol = (contractSymbol || '').toLowerCase();
      let nftLogo = '';
      let accentColor = '#9945FF';

      if (lowerName === 'zorgz' || lowerSymbol === 'zzz') {
        nftLogo = TOKEN_LOGOS['zorgz'] || '';
        accentColor = '#e8e8e0'; // bone color from zOrgz palette
      }

      oracleHtml = `<a href="https://etherscan.io/address/${oracleAddr}" target="_blank" rel="noopener" style="color:inherit;text-decoration:underline;text-decoration-color:${accentColor}" title="${oracleAddr}">${nftLogo}${displayName}</a> <span style="opacity:0.5">totalSupply</span>`;

    } else {
      // Unknown oracle type - use heuristics
      const threshold = Number(condData.threshold);
      if (threshold > 1e15) {
        decimals = 18;
        prefix = '';
        suffix = ' units';
      }

      if (oracleAddr && oracleAddr !== ethers.ZeroAddress) {
        // Check if this is a known contract
        const knownContract = getKnownContract(oracleAddr);
        if (knownContract) {
          const logo = knownContract.logo || '';
          const color = knownContract.color || '#666';
          oracleHtml = `<a href="https://etherscan.io/address/${oracleAddr}" target="_blank" rel="noopener" style="color:inherit;text-decoration:underline;text-decoration-color:${color}" title="${oracleAddr}">${logo}${knownContract.name}</a>`;
        } else {
          const shortOracle = `${oracleAddr.slice(0,6)}...${oracleAddr.slice(-4)}`;
          oracleHtml = `<a href="https://etherscan.io/address/${oracleAddr}" target="_blank" rel="noopener" style="color:inherit;text-decoration:underline;text-decoration-color:#666">${shortOracle}</a>`;
        }
      }
    }

    // Detect address existence check: op = ≠ (5) and threshold = 0
    // This is commonly used for "fee controller != 0" style checks
    // Note: condData.op may be BigInt from ethers, so convert to Number for comparison
    const isAddressExistenceCheck = Number(condData.op) === 5 && Number(condData.threshold) === 0;

    // Format values
    const valueFormatted = Number(value) / Math.pow(10, decimals);
    const thresholdFormatted = Number(condData.threshold) / Math.pow(10, decimals);

    const formatVal = (v) => {
      if (v >= 1e9) return (v / 1e9).toFixed(2) + 'B';
      if (v >= 1e6) return (v / 1e6).toFixed(2) + 'M';
      if (v >= 1e3) return (v / 1e3).toFixed(2) + 'K';
      if (v < 0.01 && v > 0) return v.toFixed(6);
      return v.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
    };

    // Deadline info (shared by both layouts)
    const now = Math.floor(Date.now() / 1000);
    const isClosed = m.close && m.close <= now;
    const daysUntilClose = m.close ? Math.floor((m.close - now) / 86400) : 0;
    const closePreposition = daysUntilClose > 30 ? 'on' : 'in'; // "on 4/1/2026" vs "in 2d 4h"
    const deadlineText = isClosed
      ? '<span style="color:#0F0">Market closed</span>'
      : m.close ? `Closes ${closePreposition} <span style="color:#F50">${formatCountdown(m.close)}</span>` : '';

    let conditionHtml;

    if (isAddressExistenceCheck) {
      // Special layout for address existence checks (e.g., "fee controller != 0")
      // Show as binary status rather than progress bar
      const rawValue = BigInt(value);
      const isSet = rawValue !== 0n;

      // Try to format as address if it looks like one (non-zero, fits in address space)
      let valueDisplay;
      if (isSet && rawValue <= BigInt('0xffffffffffffffffffffffffffffffffffffffff')) {
        const addrHex = '0x' + rawValue.toString(16).padStart(40, '0');
        const shortAddr = `${addrHex.slice(0,6)}...${addrHex.slice(-4)}`;
        valueDisplay = `<a href="https://etherscan.io/address/${addrHex}" target="_blank" rel="noopener" style="color:#0F0;text-decoration:underline;text-decoration-color:#0F0">${shortAddr}</a>`;
      } else if (isSet) {
        valueDisplay = `<span style="color:#0F0">${rawValue.toString()}</span>`;
      } else {
        valueDisplay = '<span style="color:#F00;opacity:0.7">Not Set</span>';
      }

      // Parse calldata to get function name for better labeling
      const parsedCall = parseCalldata(callData, oracleAddr);
      let conditionLabel = 'Value';
      let functionDisplay = '';

      // Check for known function calls
      if (parsedCall.functionName === 'protocolFeeController') {
        conditionLabel = 'Protocol Fee Controller';
        functionDisplay = `<code style="font-size:10px;opacity:0.6;background:#333;padding:2px 6px;border-radius:3px;">protocolFeeController()</code>`;
      } else if (parsedCall.parsed) {
        // Use parsed function name if available
        conditionLabel = parsedCall.parsed.replace(/<[^>]*>/g, '').replace(/\(\).*$/, '');
      } else if (m.description) {
        // Fallback: try to extract meaningful name from description like "V4 Protocol Fee Controller != 0"
        const match = m.description.match(/^(?:V4 Protocol\s+)?(.+?)\s*[!<>=]+\s*0?$/i);
        if (match) {
          conditionLabel = match[1].trim();
        }
      }

      // Show oracle contract name if known
      const knownOracle = getKnownContract(oracleAddr);
      const oracleDisplay = knownOracle
        ? `<a href="https://etherscan.io/address/${oracleAddr}" target="_blank" rel="noopener" style="color:inherit;text-decoration:underline;text-decoration-color:${knownOracle.color || '#666'}" title="${oracleAddr}">${knownOracle.logo || ''}${knownOracle.name}</a>`
        : oracleHtml;

      const statusIcon = isSet ? '✓' : '○';
      const statusColor = isSet ? '#0F0' : '#F50';
      const statusText = isSet ? 'ENABLED' : 'NOT SET';

      conditionHtml = `
        <div class="resolve-condition" style="text-align:center;">
          <div style="font-size:10px;opacity:0.5;margin-bottom:4px;">${oracleDisplay}</div>
          ${functionDisplay ? `<div style="margin-bottom:8px;">${functionDisplay}</div>` : ''}
          <div style="font-size:11px;opacity:0.6;margin-bottom:4px;">${conditionLabel}</div>
          <div style="font-size:32px;margin:8px 0;color:${statusColor}">${statusIcon}</div>
          <div style="font-weight:bold;color:${statusColor};margin-bottom:8px;">${statusText}</div>
          <div style="font-size:12px;font-family:monospace;">${valueDisplay}</div>
        </div>
      `;
    } else {
      // Standard progress bar layout for numeric thresholds
      const progressPct = thresholdFormatted > 0
        ? Math.min(100, (valueFormatted / thresholdFormatted) * 100)
        : 0;
      const progressText = progressPct.toFixed(1) + '%';
      const conditionVerb = condData.op >= 2 ? 'reaches' : 'falls below';
      const conditionTarget = oracleHtml || 'Oracle value';

      conditionHtml = `
        <div class="resolve-condition">
          <div class="resolve-condition-target">${conditionTarget}</div>
          <div style="margin-top:6px;">
            ${conditionVerb} <span class="resolve-condition-thresh">${opName} ${prefix}${formatVal(thresholdFormatted)}${suffix}</span>
          </div>
        </div>
        <div class="resolve-progress">
          <div class="resolve-progress-bar${condTrue ? ' met' : ''}">
            <span class="filled">${'█'.repeat(Math.round(progressPct / 5))}</span><span class="empty">${'░'.repeat(20 - Math.round(progressPct / 5))}</span>
          </div>
          <div class="resolve-progress-text">
            <span><span class="resolve-condition-val">${prefix}${formatVal(valueFormatted)}${suffix}</span></span>
            <span>${progressText}</span>
          </div>
        </div>
      `;
    }

    // Build final layout
    detailsEl.innerHTML = `
      ${conditionHtml}
      ${deadlineText ? `<div style="text-align:center;font-size:11px;margin-bottom:12px;font-family:monospace;opacity:0.8">[${deadlineText}]</div>` : ''}
      <button class="resolve-btn" id="resolveBtn" onclick="resolveMarket()" ${ready ? '' : 'disabled'}>
        ${ready ? 'RESOLVE MARKET' : 'RESOLVE MARKET'}
      </button>
      <div class="resolve-hint">${ready
        ? 'Condition met! Click to settle the market.'
        : isClosed ? 'Market closed - can resolve with current value' : 'Unlocks when threshold reached or market closes'}</div>
      <button class="inspect-toggle" onclick="toggleInspect()">▼ Inspect On-Chain Condition</button>
      <div class="inspect-panel" id="inspectPanel">
        <div class="inspect-row">
          <span class="inspect-label">targetA</span>
          <span class="inspect-value"><a href="https://etherscan.io/address/${condData.targetA}" target="_blank" rel="noopener">${condData.targetA}</a></span>
        </div>
        <div class="inspect-row">
          <span class="inspect-label">targetB</span>
          <span class="inspect-value">${condData.targetB === ethers.ZeroAddress ? '(none)' : `<a href="https://etherscan.io/address/${condData.targetB}" target="_blank" rel="noopener">${condData.targetB}</a>`}</span>
        </div>
        <div class="inspect-row">
          <span class="inspect-label">op</span>
          <span class="inspect-value">${condData.op} (${opNames[condData.op] || '?'})</span>
        </div>
        <div class="inspect-row">
          <span class="inspect-label">isRatio</span>
          <span class="inspect-value">${condData.isRatio}</span>
        </div>
        <div class="inspect-row">
          <span class="inspect-label">threshold</span>
          <span class="inspect-value">${condData.threshold.toString()}</span>
        </div>
        ${formatCalldataHtml(condData.callDataA, condData.targetA, 'callDataA')}
        ${formatCalldataHtml(condData.callDataB, condData.targetB, 'callDataB')}
      </div>
    `;

    // Update toggle status badge
    // ready = true when condition met OR close time passed (either way, can resolve)
    const toggleStatus = $('resolveToggleStatus');
    if (ready && condTrue) {
      toggleStatus.textContent = 'READY';
      toggleStatus.className = 'resolve-toggle-status ready';
    } else if (ready && !condTrue) {
      toggleStatus.textContent = 'CLOSED'; // market closed, condition not met
      toggleStatus.className = 'resolve-toggle-status ready';
    } else {
      toggleStatus.textContent = 'PENDING';
      toggleStatus.className = 'resolve-toggle-status pending';
    }

    // Add ready class to details panel
    detailsEl.classList.toggle('ready', ready);
  } catch (e) {
    console.warn('Failed to load resolution status:', e);
    resolveSection.style.display = 'none';
  }
}

function toggleInspect() {
  const panel = $('inspectPanel');
  const toggle = panel?.previousElementSibling;
  if (panel) {
    const expanded = panel.classList.toggle('expanded');
    if (toggle) toggle.textContent = expanded ? '▲ Hide Condition Details' : '▼ Inspect On-Chain Condition';
  }
}

async function resolveMarket() {
  const m = markets[currentIndex];
  if (!m?.marketId || !resolutionStatus.ready) return;

  $('resolveBtn').disabled = true;
  $('resolveBtn').textContent = '...';

  try {
    const resolverSigner = signer || (await connectWithWallet('metamask'), signer);
    if (!resolverSigner) {
      throw new Error('Please connect wallet first');
    }

    const resolver = new ethers.Contract(CONTRACTS.RESOLVER, RESOLVER_ABI, resolverSigner);
    const tx = await resolver.resolveMarket(BigInt(m.marketId));

    showTxPending(tx.hash);
    const receipt = await tx.wait();
    console.log('Resolve tx:', receipt.hash);

    // Show success immediately after confirmation
    showTxSuccess(`Market resolved: ${resolutionStatus.condTrue ? 'YES' : 'NO'}!`, receipt.hash);

    // Update local state
    m.resolved = true;
    m.outcome = resolutionStatus.condTrue;

    // Refresh UI (don't block success toast)
    try {
      await loadPositions();
      render();
    } catch (refreshErr) {
      console.warn('Refresh after resolve failed:', refreshErr);
    }

  } catch (e) {
    console.error('Resolution failed:', e);
    const msg = e.reason || e.message || 'Unknown error';
    if (!msg.toLowerCase().includes('user rejected')) {
      showTxError('Resolution failed: ' + msg);
    } else {
      hideToast();
    }
    $('resolveBtn').disabled = !resolutionStatus.ready;
    $('resolveBtn').textContent = 'RESOLVE MARKET';
  }
}

// ======================== PRICE CHART ========================
async function loadPriceChart() {
  const m = markets[currentIndex];
  const capturedMarketId = m?.marketId; // Capture for stale check
  const chartSection = $('chartSection');

  if (!capturedMarketId || !liqPanelOpen) {
    chartSection.style.display = 'none';
    return;
  }

  chartSection.style.display = 'block';

  try {
    const rpc = provider || await getRpc();
    const quoter = new ethers.Contract(CONTRACTS.QUOTER, QUOTER_ABI, rpc);
    const pamm = new ethers.Contract(CONTRACTS.PAMM, PAMM_ABI, rpc);
    const hookRouter = new ethers.Contract(CONTRACTS.PM_HOOK_ROUTER, PM_HOOK_ROUTER_ABI, rpc);

    // Detect if this is our labeled market or external (includes uniPM markets)
    const isOurMarket = isOurLabeledMarket(m.description);
    const buyYes = dir !== 'N';
    const noId = await pamm.getNoId(BigInt(m.marketId));
    // Abort if user switched markets during async call
    if (markets[currentIndex]?.marketId !== capturedMarketId) return;

    // For external markets, try direct pool query with 30 bps fee
    let ammYes = 0, ammNo = 0, spotBps = 0, feeBps = 0;
    let vaultShares = 0, vaultPrice = 0, hasVault = false;
    let liqBreakdown = null;

    if (isOurMarket) {
      // Use Quoter for our labeled markets (they use PM_FEE_HOOK)
      const [summary, breakdown] = await Promise.all([
        quoter.getMarketSummary(m.marketId, { gasLimit: 5000000 }),
        quoter.getLiquidityBreakdown(m.marketId, buyYes, { gasLimit: 5000000 })
      ]);
      // Abort if user switched markets during async call
      if (markets[currentIndex]?.marketId !== capturedMarketId) return;
      liqBreakdown = breakdown;
      spotBps = Number(summary.ammPriceYesBps);
      priceChart.twapBps = Number(summary.twapPriceYesBps);
      feeBps = Number(summary.feeBps);
      ammYes = Number(summary.ammYesReserve) / 1e18;
      ammNo = Number(summary.ammNoReserve) / 1e18;
      vaultShares = Number(breakdown.vaultOtcShares) / 1e18;
      vaultPrice = Number(breakdown.vaultOtcPriceBps) / 100;
      hasVault = breakdown.vaultOtcAvailable && vaultShares > 0;
    } else {
      // External market - query PAMM directly with legacy fee
      try {
        const poolState = await pamm.getPoolState(BigInt(m.marketId), LEGACY_FEE_BPS);
        ammYes = Number(poolState.rYes) / 1e18;
        ammNo = Number(poolState.rNo) / 1e18;
        // Compute spot price from reserves
        const total = ammYes + ammNo;
        spotBps = total > 0 ? Math.round((ammNo / total) * 10000) : 0;
        feeBps = LEGACY_FEE_BPS;
        priceChart.twapBps = 0; // No TWAP for external
      } catch (e) {
        console.log('External pool query failed:', e.message);
      }
      // External markets don't have our vault system
      hasVault = false;
    }

    priceChart.spotBps = spotBps;

    // Sync main odds bar with fresh spot price
    // Note: spotBps=0 is valid (0% YES), only skip if undefined/null
    if (typeof spotBps === 'number') {
      m.y = spotBps / 100;
      m.oddsLoaded = true;
      setOddsBar(m.y);
    }

    // Update spot/TWAP/fee display
    $('chartSpot').textContent = typeof spotBps === 'number' ? (spotBps / 100).toFixed(1) + '%' : '--';
    $('chartFee').textContent = feeBps > 0 ? (feeBps / 100).toFixed(2) + '%' : '--';

    // Hide TWAP row if no TWAP available
    const twapRow = $('chartTwapRow');
    if (priceChart.twapBps > 0) {
      $('chartTwap').textContent = (priceChart.twapBps / 100).toFixed(1) + '%';
      twapRow.style.display = '';
    } else {
      twapRow.style.display = 'none';
    }

    // Update liquidity breakdown
    const liqSection = $('liquidityBreakdown');
    liqSection.style.display = 'block';

    // Vault OTC liquidity - hide row if no meaningful vault liquidity
    const vaultRow = $('liqVaultRow');
    const hasVaultLiquidity = hasVault && vaultShares >= 0.0001; // Hide if effectively zero
    if (hasVaultLiquidity) {
      const vaultAmt = vaultShares < 0.01 ? vaultShares.toFixed(4) : vaultShares.toFixed(2);
      $('liqVault').textContent = `${vaultAmt} @ ${vaultPrice.toFixed(1)}%`;
      vaultRow.style.display = '';
    } else {
      vaultRow.style.display = 'none';
    }

    // AMM liquidity (use already computed values)
    const ammSpot = spotBps / 100;
    const hasAmm = ammYes > 0.001 || ammNo > 0.001;
    const fmtAmm = (v) => v < 1 ? v.toFixed(4) : v.toFixed(2);
    $('liqAmm').textContent = hasAmm
      ? `${fmtAmm(ammYes)}Y / ${fmtAmm(ammNo)}N @ ${ammSpot.toFixed(1)}%`
      : 'no pool';

    // Fetch and display orderbook levels (only for our markets)
    const orderbookEl = $('orderbookLevels');
    let hasBidPool = false;
    if (!isOurMarket) {
      // External markets don't use our bid pool system
      orderbookEl.innerHTML = '';
    } else try {
      const levels = await quoter.getActiveLevels(m.marketId, buyYes, 5, { gasLimit: 5000000 });
      const { askPrices, askDepths, bidPrices, bidDepths } = levels;

      let html = '';
      const hasAsks = askPrices.some(p => Number(p) > 0);
      const hasBids = bidPrices.some(p => Number(p) > 0);
      hasBidPool = hasAsks || hasBids;

      if (hasAsks || hasBids) {
        html += '<div class="orderbook-title">Orderbook</div>';

        // Show asks (selling to buyers in the pool)
        if (hasAsks) {
          html += '<div class="orderbook-side asks">';
          for (let i = 0; i < askPrices.length; i++) {
            const price = Number(askPrices[i]);
            const depth = Number(askDepths[i]) / 1e18;
            if (price > 0 && depth > 0) {
              html += `<div class="ob-level"><span class="ob-price">${(price / 100).toFixed(0)}%</span><span class="ob-depth ask">${depth.toFixed(2)} shares</span></div>`;
            }
          }
          html += '</div>';
        }

        // Show bids (buying from sellers in the pool)
        if (hasBids) {
          const collateralSym = getCollateralSymbol(m.collateral);
          html += '<div class="orderbook-side bids">';
          for (let i = 0; i < bidPrices.length; i++) {
            const price = Number(bidPrices[i]);
            const depth = Number(bidDepths[i]) / 1e18;
            if (price > 0 && depth > 0) {
              html += `<div class="ob-level"><span class="ob-price">${(price / 100).toFixed(0)}%</span><span class="ob-depth bid">${depth.toFixed(4)} ${collateralSym}</span></div>`;
            }
          }
          html += '</div>';
        }
      }

      orderbookEl.innerHTML = html;

      // Show bid pool row if there are active bids
      const bidPoolRow = $('bidPoolRow');
      if (hasBidPool) {
        // Calculate total bid pool depth
        const totalAskDepth = askDepths.reduce((sum, d) => sum + Number(d), 0) / 1e18;
        const totalBidDepth = bidDepths.reduce((sum, d) => sum + Number(d), 0) / 1e18;
        const totalDepth = totalAskDepth + totalBidDepth;
        const depthStr = totalDepth < 0.01 ? totalDepth.toFixed(4) : totalDepth.toFixed(2);
        $('bidPoolBalance').textContent = `${depthStr} ETH depth`;
        bidPoolRow.style.display = '';
      } else {
        bidPoolRow.style.display = 'none';
      }
    } catch (e) {
      console.log('Orderbook fetch error:', e.message);
      orderbookEl.innerHTML = '';
      $('bidPoolRow').style.display = 'none';
    }

    // Update liquidity sources state and indicator
    liquiditySources = { hasVault, hasBidPool, hasAmm };
    updateLiquidityIndicator();

    // Compute pool ID for ZAMM link
    const poolId = calculatePoolId(m.marketId, isOurMarket);
    priceChart.poolId = poolId;

    // Set ZAMM link (use decimal pool ID)
    const poolIdDecimal = BigInt(poolId).toString();
    $('chartLink').href = `https://zamm.finance/p/1/${poolIdDecimal}`;

    // Render simple price visualization
    renderPriceChart();

  } catch (e) {
    console.warn('Failed to load price chart:', e);
    $('chartContainer').innerHTML = '<div class="chart-empty">Price data unavailable</div>';
    $('liquidityBreakdown').style.display = 'none';
  }
}

function renderPriceChart() {
  const container = $('chartContainer');

  if (priceChart.spotBps === 0) {
    container.innerHTML = '<div class="chart-empty">No liquidity yet</div>';
    $('chartOldest').textContent = '--';
    $('chartNewest').textContent = '--';
    return;
  }

  // Show current price as visual indicator with YES/NO split
  const yesPct = priceChart.spotBps / 100;
  const noPct = 100 - yesPct;

  container.innerHTML = `
    <div class="price-visual">
      <div class="price-bar yes" style="width: ${yesPct}%">
        <span class="price-label">YES ${yesPct.toFixed(1)}%</span>
      </div>
      <div class="price-bar no" style="width: ${noPct}%">
        <span class="price-label">NO ${noPct.toFixed(1)}%</span>
      </div>
    </div>
  `;

  // Update footer
  $('chartOldest').textContent = '';
  $('chartNewest').textContent = 'now';
}

// ======================== CREATE MARKET ========================
let currentEthPrice = 0; // Store for price diff calculation
let currentMarketType = 'price'; // 'price', 'ethBalance', 'tokenBalance'
let resolvedAddresses = { ethBalance: null, tokenBalance: null };
let currentBalances = { ethBalance: 0, tokenBalance: 0 }; // Store current balances for presets

async function loadEthPrice() {
  const el = $('livePrice');
  if (!el) return;
  el.textContent = '...';
  try {
    const rpc = await getRpc();
    const chainlink = new ethers.Contract(CONTRACTS.CHAINLINK_ETH_USD, CHAINLINK_ABI, rpc);
    const price = await chainlink.latestAnswer();
    currentEthPrice = Number(price) / 1e8;
    el.textContent = '$' + currentEthPrice.toLocaleString('en-US', { maximumFractionDigits: 0 });
    updatePriceDiffHint();
  } catch {
    el.textContent = '–';
    currentEthPrice = 0;
  }
}

// Date preset helper - calculates end of day/week/month/year in UTC
function setDatePreset(inputId, preset) {
  const now = new Date();
  let target = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()));

  switch (preset) {
    case 'day':
      // End of current UTC day (23:59)
      target.setUTCHours(23, 59, 0, 0);
      break;
    case 'week':
      // End of current week (Sunday 23:59 UTC)
      const daysUntilSunday = 7 - target.getUTCDay();
      target.setUTCDate(target.getUTCDate() + daysUntilSunday);
      target.setUTCHours(23, 59, 0, 0);
      break;
    case 'month':
      // End of current month (last day 23:59 UTC)
      target.setUTCMonth(target.getUTCMonth() + 1, 0);
      target.setUTCHours(23, 59, 0, 0);
      break;
    case 'year':
      // End of current year (Dec 31 23:59 UTC)
      target.setUTCFullYear(target.getUTCFullYear(), 11, 31);
      target.setUTCHours(23, 59, 0, 0);
      break;
  }

  // Format for datetime-local input (YYYY-MM-DDTHH:MM)
  const formatted = target.toISOString().slice(0, 16);
  $(inputId).value = formatted;

  // Trigger the input event to update hints and previews
  $(inputId).dispatchEvent(new Event('input'));
}

// Price preset helper - calculates target price from current ETH price + percentage
function setPricePreset(percent) {
  if (!currentEthPrice) return;
  const target = Math.round(currentEthPrice * (1 + percent / 100));
  $('targetPrice').value = '$' + target.toLocaleString('en-US');
  updatePriceDiffHint();
  updatePricePreview();
}

// Balance preset helper - calculates threshold from current balance + percentage
function setBalancePreset(type, percent) {
  const balance = currentBalances[type];
  if (!balance) return;
  const target = balance * (1 + percent / 100);

  if (type === 'ethBalance') {
    $('ethBalanceThreshold').value = target.toFixed(4);
    updateETHBalancePreview();
  } else {
    $('tokenBalanceThreshold').value = Math.round(target);
    updateTokenBalancePreview();
  }
}

// Parse datetime-local input as UTC (not local time)
function parseUTCDateTime(dateStr) {
  if (!dateStr) return 0;
  // Append 'Z' to treat as UTC
  return Math.floor(new Date(dateStr + ':00Z').getTime() / 1000);
}

// Show local time equivalent for UTC datetime input
function updateLocalTimeHint(inputId, hintId) {
  const dateStr = $(inputId).value;
  const hint = $(hintId);
  if (!dateStr) {
    hint.textContent = '';
    return;
  }
  const utcTimestamp = parseUTCDateTime(dateStr);
  const localDate = new Date(utcTimestamp * 1000);
  const options = { month: 'short', day: 'numeric', hour: 'numeric', minute: '2-digit', timeZoneName: 'short' };
  hint.textContent = '→ ' + localDate.toLocaleString('en-US', options) + ' your time';
}

function switchMarketType(type) {
  currentMarketType = type;

  // Update tabs
  document.querySelectorAll('.market-type-tab').forEach((tab, i) => {
    const types = ['price', 'balance', 'totalSupply'];
    tab.classList.toggle('active', types[i] === type);
  });

  // Update form sections
  $('priceForm').classList.toggle('active', type === 'price');
  $('balanceForm').classList.toggle('active', type === 'balance');
  $('totalSupplyForm').classList.toggle('active', type === 'totalSupply');

  // Update title
  const titles = {
    price: 'Price Market',
    balance: 'Balance Market',
    totalSupply: 'Supply Market'
  };
  $('createModalTitle').textContent = titles[type];
}

// Preview update functions
function updatePricePreview() {
  const price = $('targetPrice').value.replace(/[^0-9]/g, '') || '___';
  const dateStr = $('closeDate').value;
  let dateDisplay = '___';
  if (dateStr) {
    const d = new Date(dateStr);
    dateDisplay = d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
  }
  $('pricePreview').innerHTML = `Will ETH hit <b>$${price.replace(/\B(?=(\d{3})+(?!\d))/g, ',')}</b> by <b>${dateDisplay}</b>?`;
}

function updateETHBalancePreview() {
  const addr = $('ethBalanceAddress').value;
  const resolved = $('ethBalanceResolved').textContent;
  let addrDisplay = 'address';
  if (resolved && resolved.includes('0x')) {
    addrDisplay = resolved.split(' ')[0];
  } else if (addr && addr.includes('.')) {
    addrDisplay = addr;
  } else if (addr && addr.startsWith('0x')) {
    addrDisplay = addr.slice(0, 8) + '...';
  }
  const threshold = $('ethBalanceThreshold').value || '___';
  const dateStr = $('ethBalanceCloseDate').value;
  let dateDisplay = '___';
  if (dateStr) {
    const d = new Date(dateStr);
    dateDisplay = d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
  }
  $('ethBalancePreview').innerHTML = `Will <b>${addrDisplay}</b> hold ≥ <b>${threshold}</b> ETH by <b>${dateDisplay}</b>?`;
}

function updateTokenBalancePreview() {
  const addr = $('tokenBalanceAddress').value;
  const resolved = $('tokenBalanceResolved').textContent;
  let addrDisplay = 'address';
  if (resolved && resolved.includes('0x')) {
    addrDisplay = resolved.split(' ')[0];
  } else if (addr && addr.includes('.')) {
    addrDisplay = addr;
  } else if (addr && addr.startsWith('0x')) {
    addrDisplay = addr.slice(0, 8) + '...';
  }
  const threshold = $('tokenBalanceThreshold').value || '___';
  const tokenInfo = $('tokenInfo').textContent;
  // Extract symbol only if it looks like valid token info (contains "decimals")
  let tokenName = 'tokens';
  if (tokenInfo && tokenInfo.includes('decimals')) {
    tokenName = tokenInfo.split(' ')[0]; // Gets the symbol
  }
  const dateStr = $('tokenBalanceCloseDate').value;
  let dateDisplay = '___';
  if (dateStr) {
    const d = new Date(dateStr);
    dateDisplay = d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
  }
  $('tokenBalancePreview').innerHTML = `Will <b>${addrDisplay}</b> hold ≥ <b>${threshold}</b> ${tokenName} by <b>${dateDisplay}</b>?`;
}

// Combined Balance market functions
let balanceAssetType = 'eth'; // 'eth' or 'token'
let balanceTokenData = { symbol: null, decimals: 18, address: null };
let balanceWalletResolved = null;
let currentBalanceValue = 0;

function setBalanceAssetType(type) {
  balanceAssetType = type;
  $('balanceTypeEth').classList.toggle('active', type === 'eth');
  $('balanceTypeToken').classList.toggle('active', type === 'token');
  $('balanceTokenGroup').style.display = type === 'token' ? 'block' : 'none';

  // Clear cached balance when switching
  currentBalanceValue = 0;
  $('currentBalanceHint').textContent = '';

  // Reload balance for current address if we have one
  if (balanceWalletResolved) {
    loadBalanceForWallet(balanceWalletResolved);
  }

  updateBalancePreview();
}

function updateBalancePreview() {
  const addr = $('balanceWalletAddress').value;
  const resolved = $('balanceWalletResolved').textContent;
  let addrDisplay = 'address';
  if (resolved && resolved.includes('0x')) {
    addrDisplay = resolved.split(' ')[0];
  } else if (addr && addr.includes('.')) {
    addrDisplay = addr;
  } else if (addr && addr.startsWith('0x')) {
    addrDisplay = addr.slice(0, 8) + '...';
  }

  const threshold = $('balanceThreshold').value || '___';
  const dateStr = $('balanceCloseDate').value;
  let dateDisplay = '___';
  if (dateStr) {
    const d = new Date(dateStr);
    dateDisplay = d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
  }

  let assetName = 'ETH';
  if (balanceAssetType === 'token') {
    const tokenInfo = $('balanceTokenInfo').textContent;
    if (tokenInfo && tokenInfo.includes('decimals')) {
      assetName = tokenInfo.split(' ')[0];
    } else {
      assetName = 'tokens';
    }
  }

  $('balancePreview').innerHTML = `Will <b>${addrDisplay}</b> hold ≥ <b>${threshold}</b> ${assetName} by <b>${dateDisplay}</b>?`;
}

let balanceENSTimer = null;
function resolveBalanceENS() {
  clearTimeout(balanceENSTimer);
  balanceENSTimer = setTimeout(resolveBalanceENSInternal, 400);
}

async function resolveBalanceENSInternal() {
  const input = $('balanceWalletAddress').value.trim();
  const hint = $('balanceWalletResolved');

  balanceWalletResolved = null;
  currentBalanceValue = 0;
  $('currentBalanceHint').textContent = '';

  if (!input) {
    hint.textContent = '';
    return;
  }

  if (ethers.isAddress(input)) {
    balanceWalletResolved = input;
    hint.innerHTML = '<span style="color:#0F0">Valid address</span>';
    loadBalanceForWallet(input);
    return;
  }

  if (input.includes('.')) {
    hint.textContent = 'Resolving ENS...';
    try {
      const rpc = await getRpc();
      const resolved = await rpc.resolveName(input);
      if ($('balanceWalletAddress').value.trim() !== input) return;
      if (resolved) {
        balanceWalletResolved = resolved;
        hint.innerHTML = `<span style="color:#0F0">${resolved.slice(0,6)}...${resolved.slice(-4)}</span>`;
        loadBalanceForWallet(resolved);
      } else {
        hint.innerHTML = '<span style="color:#F00">ENS not found</span>';
      }
    } catch (e) {
      if ($('balanceWalletAddress').value.trim() !== input) return;
      hint.innerHTML = '<span style="color:#F00">ENS resolution failed</span>';
    }
  } else {
    hint.innerHTML = '<span style="color:#F00">Invalid address</span>';
  }
}

async function loadBalanceForWallet(address) {
  const balanceHint = $('currentBalanceHint');
  try {
    const rpc = await getRpc();
    if (balanceAssetType === 'eth') {
      const balance = await rpc.getBalance(address);
      const ethBal = Number(ethers.formatEther(balance));
      currentBalanceValue = ethBal;
      balanceHint.textContent = `(current: ${ethBal.toFixed(4)} ETH)`;
    } else if (balanceTokenData.address) {
      const token = new ethers.Contract(balanceTokenData.address, [
        'function balanceOf(address) view returns (uint256)'
      ], rpc);
      const balance = await token.balanceOf(address);
      const bal = Number(balance) / (10 ** balanceTokenData.decimals);
      currentBalanceValue = bal;
      balanceHint.textContent = `(current: ${bal.toLocaleString()})`;
    }
  } catch (e) {
    console.warn('Failed to load balance:', e);
  }
}

async function loadBalanceTokenInfo() {
  const address = $('balanceTokenAddress').value.trim();
  const hint = $('balanceTokenInfo');

  balanceTokenData = { symbol: null, decimals: 18, address: null };

  if (!address) {
    hint.textContent = '';
    updateBalancePreview();
    return;
  }

  if (!ethers.isAddress(address)) {
    hint.innerHTML = '<span style="color:#F00">Invalid address</span>';
    updateBalancePreview();
    return;
  }

  hint.textContent = 'Loading...';
  try {
    const rpc = await getRpc();
    const contract = new ethers.Contract(address, [
      'function symbol() view returns (string)',
      'function decimals() view returns (uint8)'
    ], rpc);

    const [symbol, decimals] = await Promise.all([
      contract.symbol().catch(() => 'TOKEN'),
      contract.decimals().catch(() => 18)
    ]);

    balanceTokenData = { symbol, decimals: Number(decimals), address };
    hint.innerHTML = `<span style="color:#0F0">${symbol}</span> (${decimals} decimals)`;

    // Reload balance if we have an address
    if (balanceWalletResolved) {
      loadBalanceForWallet(balanceWalletResolved);
    }

    updateBalancePreview();
  } catch (e) {
    hint.innerHTML = '<span style="color:#F00">Failed to load token</span>';
    updateBalancePreview();
  }
}

function setBalancePresetNew(pct) {
  if (currentBalanceValue <= 0) {
    alert('Enter a wallet address first to use presets');
    return;
  }
  let newVal;
  if (pct === 0) {
    newVal = currentBalanceValue;
  } else {
    newVal = currentBalanceValue * (1 + pct / 100);
  }
  // Round appropriately based on asset type
  if (balanceAssetType === 'eth') {
    $('balanceThreshold').value = newVal.toFixed(4);
  } else {
    $('balanceThreshold').value = Math.round(newVal);
  }
  updateBalancePreview();
}

// Total Supply market functions
let totalSupplyTokenData = { symbol: null, decimals: 18, supply: 0n };

function updateTotalSupplyPreview() {
  const tokenInfo = $('totalSupplyTokenInfo').textContent;
  let tokenName = 'token';
  if (tokenInfo && tokenInfo.includes('decimals')) {
    tokenName = tokenInfo.split(' ')[0];
  }
  const op = $('totalSupplyOp').value;
  const opSymbols = { gte: '≥', lte: '≤', gt: '>', lt: '<' };
  const opSymbol = opSymbols[op] || '≥';
  const threshold = $('totalSupplyThreshold').value || '___';
  const dateStr = $('totalSupplyCloseDate').value;
  let dateDisplay = '___';
  if (dateStr) {
    const d = new Date(dateStr);
    dateDisplay = d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
  }
  $('totalSupplyPreview').innerHTML = `Will <b>${tokenName}</b> supply be <b>${opSymbol} ${Number(threshold).toLocaleString()}</b> by <b>${dateDisplay}</b>?`;
}

async function loadTotalSupplyTokenInfo() {
  const address = $('totalSupplyToken').value.trim();
  const hint = $('totalSupplyTokenInfo');
  const supplyHint = $('currentTotalSupplyHint');

  totalSupplyTokenData = { symbol: null, decimals: 18, supply: 0n };
  if (supplyHint) supplyHint.textContent = '';

  if (!address) {
    hint.textContent = '';
    updateTotalSupplyPreview();
    return;
  }

  if (!ethers.isAddress(address)) {
    hint.innerHTML = '<span style="color:#F00">Invalid address</span>';
    updateTotalSupplyPreview();
    return;
  }

  hint.textContent = 'Loading...';
  try {
    const rpc = await getRpc();
    const contract = new ethers.Contract(address, [
      'function symbol() view returns (string)',
      'function decimals() view returns (uint8)',
      'function totalSupply() view returns (uint256)'
    ], rpc);

    const [symbol, decimals, supply] = await Promise.all([
      contract.symbol().catch(() => 'TOKEN'),
      contract.decimals().catch(() => 18),
      contract.totalSupply().catch(() => 0n)
    ]);

    totalSupplyTokenData = { symbol, decimals: Number(decimals), supply };
    const supplyNum = Number(supply) / (10 ** Number(decimals));
    hint.innerHTML = `<span style="color:#0F0">${symbol}</span> (${decimals} decimals)`;
    if (supplyHint) supplyHint.textContent = `(current: ${supplyNum.toLocaleString()})`;
    updateTotalSupplyPreview();
  } catch (e) {
    hint.innerHTML = '<span style="color:#F00">Failed to load token</span>';
    updateTotalSupplyPreview();
  }
}

function setTotalSupplyPreset(pct) {
  if (!totalSupplyTokenData.supply || totalSupplyTokenData.supply === 0n) {
    alert('Load a token first to use presets');
    return;
  }
  const currentSupply = Number(totalSupplyTokenData.supply) / (10 ** totalSupplyTokenData.decimals);
  let newVal;
  if (pct === 0) {
    newVal = currentSupply;
  } else {
    newVal = currentSupply * (1 + pct / 100);
  }
  // Round to reasonable precision
  $('totalSupplyThreshold').value = Math.round(newVal);
  updateTotalSupplyPreview();
}

async function loadGasPrice() {
  try {
    const rpc = await getRpc();
    const feeData = await rpc.getFeeData();
    const gasGwei = Number(feeData.gasPrice) / 1e9;
    $('liveGasPrice').textContent = gasGwei.toFixed(2);
  } catch (e) {
    $('liveGasPrice').textContent = '...';
  }
}

function updateGasFormHints() {
  const marketType = $('gasMarketType').value;
  const thresholdGroup = $('gasThresholdGroup');
  const rangeGroup = $('gasRangeGroup');
  const opGroup = $('gasOpGroup');
  const thresholdHint = $('gasThresholdHint');

  // Range market uses lower/upper, others use threshold
  if (marketType === 'range') {
    thresholdGroup.style.display = 'none';
    rangeGroup.style.display = 'block';
    opGroup.style.display = 'none';
  } else {
    thresholdGroup.style.display = 'block';
    rangeGroup.style.display = 'none';
    opGroup.style.display = marketType === 'twap' ? 'block' : 'none';

    // Update hint based on market type
    const hints = {
      twap: 'Resolves YES if avg gas meets condition',
      volatility: 'Resolves YES if gas swing (max-min) >= threshold',
      peak: 'Resolves YES if gas spikes >= threshold',
      trough: 'Resolves YES if gas dips <= threshold'
    };
    thresholdHint.textContent = hints[marketType] || hints.twap;
  }
}

const ensDebounceTimers = { ethBalance: null, tokenBalance: null };

function resolveENS(type) {
  // Debounce ENS lookups to avoid rapid requests while typing
  clearTimeout(ensDebounceTimers[type]);
  ensDebounceTimers[type] = setTimeout(() => resolveENSInternal(type), 400);
}

async function resolveENSInternal(type) {
  const inputId = type === 'ethBalance' ? 'ethBalanceAddress' : 'tokenBalanceAddress';
  const hintId = type === 'ethBalance' ? 'ethBalanceResolved' : 'tokenBalanceResolved';
  const input = $(inputId).value.trim();
  const hint = $(hintId);

  resolvedAddresses[type] = null;
  currentBalances[type] = 0;
  const balanceHint = type === 'ethBalance' ? $('currentEthBalanceHint') : $('currentTokenBalanceHint');
  if (balanceHint) balanceHint.textContent = '';

  if (!input) {
    hint.textContent = '';
    return;
  }

  // Check if already a valid address
  if (ethers.isAddress(input)) {
    resolvedAddresses[type] = input;
    hint.innerHTML = `<span style="color:#0F0">Valid address</span>`;
    if (type === 'ethBalance') loadAddressETHBalance(input);
    if (type === 'tokenBalance') loadAddressTokenBalance(input);
    return;
  }

  // Try ENS resolution
  if (input.includes('.')) {
    hint.textContent = 'Resolving ENS...';
    try {
      const rpc = await getRpc();
      const resolved = await rpc.resolveName(input);
      // Check if input changed while we were resolving
      if ($(inputId).value.trim() !== input) return;
      if (resolved) {
        resolvedAddresses[type] = resolved;
        hint.innerHTML = `<span style="color:#0F0">${resolved.slice(0,6)}...${resolved.slice(-4)}</span>`;
        if (type === 'ethBalance') loadAddressETHBalance(resolved);
        if (type === 'tokenBalance') loadAddressTokenBalance(resolved);
      } else {
        hint.innerHTML = `<span style="color:#F00">ENS not found</span>`;
      }
    } catch (e) {
      // Check if input changed while we were resolving
      if ($(inputId).value.trim() !== input) return;
      hint.innerHTML = `<span style="color:#F00">ENS resolution failed</span>`;
    }
  } else {
    hint.innerHTML = `<span style="color:#F00">Invalid address</span>`;
  }
}

async function loadTokenInfo() {
  const address = $('tokenAddress').value.trim();
  const hint = $('tokenInfo');

  if (!address) {
    hint.textContent = '';
    updateTokenBalancePreview();
    return;
  }

  if (!ethers.isAddress(address)) {
    hint.innerHTML = `<span style="color:#F00">Invalid address</span>`;
    updateTokenBalancePreview();
    return;
  }

  hint.textContent = 'Loading...';
  try {
    const rpc = await getRpc();
    const token = new ethers.Contract(address, [
      'function name() view returns (string)',
      'function symbol() view returns (string)',
      'function decimals() view returns (uint8)',
      'function supportsInterface(bytes4) view returns (bool)'
    ], rpc);

    // Check for ERC721 first
    let isNFT = false;
    try {
      isNFT = await token.supportsInterface('0x80ac58cd');
    } catch (e) {}

    let decimals = 0;
    if (isNFT) {
      decimals = 0;
    } else {
      try {
        decimals = await token.decimals();
      } catch (e) {
        decimals = 18;
      }
    }

    const [name, symbol] = await Promise.all([
      token.name().catch(() => null),
      token.symbol().catch(() => null)
    ]);

    if (symbol) {
      const typeLabel = isNFT ? 'NFT' : `${decimals} decimals`;
      hint.innerHTML = `<span style="color:#0F0">${symbol}${name ? ' - ' + name : ''} (${typeLabel})</span>`;
      // Reload token balance if wallet address is already set
      if (resolvedAddresses.tokenBalance) loadAddressTokenBalance(resolvedAddresses.tokenBalance);
    } else {
      hint.innerHTML = `<span style="color:#F80">Unknown token</span>`;
    }
  } catch (e) {
    hint.innerHTML = `<span style="color:#F00">Failed to load token</span>`;
  }
  updateTokenBalancePreview();
}

async function loadAddressETHBalance(address) {
  try {
    const rpc = await getRpc();
    const balance = await rpc.getBalance(address);
    const ethBal = Number(ethers.formatEther(balance));
    currentBalances.ethBalance = ethBal;
    const hint = $('ethBalanceResolved');
    hint.innerHTML += ` <span style="opacity:0.6">(${ethBal.toFixed(4)} ETH)</span>`;
    $('currentEthBalanceHint').textContent = `(current: ${ethBal.toFixed(4)})`;
  } catch (e) {
    currentBalances.ethBalance = 0;
  }
}

async function loadAddressTokenBalance(walletAddress) {
  const tokenAddress = $('tokenAddress').value.trim();
  if (!tokenAddress || !ethers.isAddress(tokenAddress)) {
    currentBalances.tokenBalance = 0;
    $('currentTokenBalanceHint').textContent = '';
    return;
  }
  try {
    const rpc = await getRpc();
    const token = new ethers.Contract(tokenAddress, [
      'function balanceOf(address) view returns (uint256)',
      'function decimals() view returns (uint8)',
      'function supportsInterface(bytes4) view returns (bool)'
    ], rpc);

    const balance = await token.balanceOf(walletAddress);

    // Check for ERC721 first (more reliable than catching decimals error)
    let decimals = 18;
    let isNFT = false;
    try {
      isNFT = await token.supportsInterface('0x80ac58cd');
    } catch (e) {
      // Not ERC165 compatible, assume ERC20
    }

    if (isNFT) {
      decimals = 0;
    } else {
      try {
        decimals = await token.decimals();
      } catch (e) {
        decimals = 18;
      }
    }

    const tokenBal = Number(ethers.formatUnits(balance, decimals));
    currentBalances.tokenBalance = tokenBal;
    const hint = $('tokenBalanceResolved');
    const formatted = isNFT
      ? `${Math.floor(tokenBal)} NFT${Math.floor(tokenBal) !== 1 ? 's' : ''}`
      : tokenBal >= 1000000 ? tokenBal.toExponential(2) : tokenBal.toLocaleString('en-US', { maximumFractionDigits: 4 });
    hint.innerHTML += ` <span style="opacity:0.6">(${formatted})</span>`;
    $('currentTokenBalanceHint').textContent = `(current: ${formatted})`;
  } catch (e) {
    currentBalances.tokenBalance = 0;
    $('currentTokenBalanceHint').textContent = '';
  }
}

async function showCreateModal() {
  $('createModal').classList.add('active');

  // Reset to price market type
  switchMarketType('price');

  // Set default close datetime to 1 year from now at midnight
  const oneYear = new Date();
  oneYear.setFullYear(oneYear.getFullYear() + 1);
  oneYear.setHours(0, 0, 0, 0);
  const defaultDate = oneYear.toISOString().slice(0, 16);

  // Set all date inputs
  $('closeDate').value = defaultDate;
  if ($('gasCloseDate')) $('gasCloseDate').value = defaultDate;
  $('ethBalanceCloseDate').value = defaultDate;
  $('tokenBalanceCloseDate').value = defaultDate;

  // Set defaults
  $('targetPrice').value = '$10,000';
  $('totalLiquidity').value = '0.01'; // Default liquidity
  if ($('gasThreshold')) $('gasThreshold').value = '30';
  if ($('gasLower')) $('gasLower').value = '20';
  if ($('gasUpper')) $('gasUpper').value = '50';
  $('ethBalanceThreshold').value = '100';
  $('tokenBalanceThreshold').value = '1000000';

  // Clear address fields and balance hints
  $('ethBalanceAddress').value = '';
  $('ethBalanceResolved').textContent = '';
  $('currentEthBalanceHint').textContent = '';
  $('tokenAddress').value = '';
  $('tokenInfo').textContent = '';
  $('tokenBalanceAddress').value = '';
  $('tokenBalanceResolved').textContent = '';
  $('currentTokenBalanceHint').textContent = '';
  resolvedAddresses = { ethBalance: null, tokenBalance: null };
  currentBalances = { ethBalance: 0, tokenBalance: 0 };

  // Reset advanced liquidity options
  $('manualAmmAmount').value = '';
  $('manualVaultAmount').value = '';
  $('manualBidsAmount').value = '';
  $('manualEnableInitialBuy').checked = false;
  $('initialBuyAdvanced').style.display = 'none';
  $('advancedToggle').classList.remove('open');
  $('advancedSection').classList.remove('open');

  // Initialize liquidity split
  updateLiqSplit();

  // Load live ETH price
  loadEthPrice();
}

function formatTargetPrice() {
  const input = $('targetPrice');
  // Extract digits only
  const raw = input.value.replace(/[^0-9]/g, '');
  if (!raw) {
    input.value = '';
    $('priceDiffHint').textContent = '';
    return;
  }
  const num = parseInt(raw);
  // Format with $ and commas
  input.value = '$' + num.toLocaleString('en-US');
  updatePriceDiffHint();
}

function updatePriceDiffHint() {
  const hint = $('priceDiffHint');
  if (!currentEthPrice) {
    hint.textContent = '';
    return;
  }
  const raw = $('targetPrice').value.replace(/[^0-9]/g, '');
  if (!raw) {
    hint.textContent = '';
    return;
  }
  const target = parseInt(raw);
  const diff = target - currentEthPrice;
  const pct = (diff / currentEthPrice * 100).toFixed(1);
  const sign = diff >= 0 ? '+' : '';
  const color = diff >= 0 ? '#0F0' : '#F00';
  hint.innerHTML = `<span style="color:${color}">${sign}$${Math.abs(diff).toLocaleString('en-US', {maximumFractionDigits: 0})} (${sign}${pct}%)</span> from current price`;
}

function closeCreateModal() {
  $('createModal').classList.remove('active');
}

// ============ SMART LIQUIDITY SPLIT ============

// Compute optimal split using smooth scaling formula
// Small amounts → heavier AMM (60/20/20)
// Large amounts → more depth (40/30/30)
// Smooth logarithmic transition between extremes
function computeOptimalSplit(totalETH) {
  if (totalETH <= 0) {
    return { amm: 0, vault: 0, bids: 0, ammPct: 60, vaultPct: 20, bidsPct: 20 };
  }

  // Scale factor: 0 at 0.01 ETH, 1 at ~10 ETH, using log curve
  // log10(0.01*100) = 0, log10(10*100) = 3
  const scale = Math.min(1, Math.max(0, Math.log10(totalETH * 100) / 3));

  // Interpolate: AMM 60%→40%, Vault 20%→30%, Bids 20%→30%
  const ammPct = Math.round(60 - 20 * scale);
  const vaultPct = Math.round(20 + 10 * scale);
  const bidsPct = 100 - ammPct - vaultPct; // Ensure adds to 100

  return {
    amm: totalETH * ammPct / 100,
    vault: totalETH * vaultPct / 100,
    bids: totalETH * bidsPct / 100,
    ammPct, vaultPct, bidsPct
  };
}

// Set liquidity from preset button
function setLiqPreset(amount) {
  $('totalLiquidity').value = amount;
  // Update active state on buttons
  document.querySelectorAll('.liq-preset').forEach(btn => {
    btn.classList.toggle('active', parseFloat(btn.textContent) === amount);
  });
  updateLiqSplit();
}

// Update the visual split bar and hidden inputs
function updateLiqSplit() {
  const total = parseFloat($('totalLiquidity').value) || 0;

  // Check for manual overrides in advanced section
  const manualAmm = parseFloat($('manualAmmAmount').value);
  const manualVault = parseFloat($('manualVaultAmount').value);
  const manualBids = parseFloat($('manualBidsAmount').value);

  let split;
  if (!isNaN(manualAmm) || !isNaN(manualVault) || !isNaN(manualBids)) {
    // Manual mode - use specified values
    const amm = isNaN(manualAmm) ? 0 : manualAmm;
    const vault = isNaN(manualVault) ? 0 : manualVault;
    const bids = isNaN(manualBids) ? 0 : manualBids;
    const manualTotal = amm + vault + bids;
    split = {
      amm, vault, bids,
      ammPct: manualTotal > 0 ? Math.round(amm / manualTotal * 100) : 0,
      vaultPct: manualTotal > 0 ? Math.round(vault / manualTotal * 100) : 0,
      bidsPct: manualTotal > 0 ? Math.round(bids / manualTotal * 100) : 0
    };
    // Update total to match manual inputs
    if (manualTotal > 0) {
      $('totalLiquidity').value = manualTotal.toFixed(4);
    }
  } else {
    // Auto mode - compute optimal split
    split = computeOptimalSplit(total);
  }

  // Update legend with amounts
  $('liqLegAmm').textContent = `${split.amm.toFixed(3)} AMM`;
  $('liqLegVault').textContent = `${split.vault.toFixed(3)} Vault`;
  $('liqLegBids').textContent = `${split.bids.toFixed(3)} Bids`;

  // Update hidden inputs for existing createMarket logic
  $('seedAmount').value = split.amm;
  $('enableVault').checked = split.vault > 0;
  $('vaultAmount').value = split.vault;
  $('enableBids').checked = split.bids > 0;
  $('bidsAmount').value = split.bids;

  // Use manual vault percentages if set, otherwise 50/50
  const yesPct = parseInt($('manualVaultYesPct').value) || 50;
  const noPct = parseInt($('manualVaultNoPct').value) || 50;
  $('vaultYesPct').value = yesPct;
  $('vaultNoPct').value = noPct;

  // Use manual bid spread if set
  $('bidSpreadPreset').value = $('manualBidSpread').value || 'balanced';

  // Handle initial buy from advanced
  const buyEnabled = $('manualEnableInitialBuy').checked;
  $('enableInitialBuy').checked = buyEnabled;
  if (buyEnabled) {
    $('initialBuySide').value = $('manualInitialBuySide').value;
    $('initialBuyAmount').value = $('manualInitialBuyAmount').value;
  }

  // Update preset button states
  const currentTotal = parseFloat($('totalLiquidity').value) || 0;
  document.querySelectorAll('.liq-preset').forEach((btn, i) => {
    btn.classList.toggle('active', Math.abs(LIQUIDITY_PRESETS_ETH[i] - currentTotal) < 0.001);
  });
}

// Toggle advanced section
function toggleAdvanced() {
  const toggle = $('advancedToggle');
  const section = $('advancedSection');
  const isOpen = toggle.classList.toggle('open');
  section.classList.toggle('open', isOpen);
}

// Handle manual override changes
function onManualSplitChange() {
  updateLiqSplit();
}

// Show/hide initial buy inputs in advanced section
document.addEventListener('DOMContentLoaded', () => {
  const checkbox = $('manualEnableInitialBuy');
  if (checkbox) {
    checkbox.addEventListener('change', () => {
      $('initialBuyAdvanced').style.display = checkbox.checked ? 'block' : 'none';
      updateLiqSplit();
    });
  }
  // Initialize split on load
  updateLiqSplit();
});

// Bid spread presets: array of { buyYes, priceInBps }
// YES bids (buyYes=true) are placed below 50% - buying YES cheap
// NO bids (buyYes=false) are placed above 50% - buying NO cheap (= selling YES high)
const BID_PRESETS = {
  balanced: [
    { buyYes: true, priceInBps: 2500 },  // YES @ 25%
    { buyYes: true, priceInBps: 3500 },  // YES @ 35%
    { buyYes: true, priceInBps: 4500 },  // YES @ 45%
    { buyYes: false, priceInBps: 5500 }, // NO @ 55% (YES sell @ 45%)
    { buyYes: false, priceInBps: 6500 }, // NO @ 65% (YES sell @ 35%)
    { buyYes: false, priceInBps: 7500 }, // NO @ 75% (YES sell @ 25%)
  ],
  tight: [
    { buyYes: true, priceInBps: 3500 },  // YES @ 35%
    { buyYes: true, priceInBps: 4000 },  // YES @ 40%
    { buyYes: true, priceInBps: 4500 },  // YES @ 45%
    { buyYes: false, priceInBps: 5500 }, // NO @ 55%
    { buyYes: false, priceInBps: 6000 }, // NO @ 60%
    { buyYes: false, priceInBps: 6500 }, // NO @ 65%
  ],
  wide: [
    { buyYes: true, priceInBps: 1500 },  // YES @ 15%
    { buyYes: true, priceInBps: 2500 },  // YES @ 25%
    { buyYes: true, priceInBps: 3500 },  // YES @ 35%
    { buyYes: false, priceInBps: 6500 }, // NO @ 65%
    { buyYes: false, priceInBps: 7500 }, // NO @ 75%
    { buyYes: false, priceInBps: 8500 }, // NO @ 85%
  ],
  yesOnly: [
    { buyYes: true, priceInBps: 2000 },  // YES @ 20%
    { buyYes: true, priceInBps: 3000 },  // YES @ 30%
    { buyYes: true, priceInBps: 3500 },  // YES @ 35%
    { buyYes: true, priceInBps: 4000 },  // YES @ 40%
    { buyYes: true, priceInBps: 4500 },  // YES @ 45%
  ],
  noOnly: [
    { buyYes: false, priceInBps: 5500 }, // NO @ 55%
    { buyYes: false, priceInBps: 6000 }, // NO @ 60%
    { buyYes: false, priceInBps: 6500 }, // NO @ 65%
    { buyYes: false, priceInBps: 7500 }, // NO @ 75%
    { buyYes: false, priceInBps: 8000 }, // NO @ 80%
  ]
};

function getBidsParams() {
  if (!$('enableBids').checked) return null;
  const amount = parseFloat($('bidsAmount').value) || 0;
  if (amount <= 0) return null;

  const preset = $('bidSpreadPreset').value;
  const levels = BID_PRESETS[preset];
  if (!levels || levels.length === 0) return null;

  const totalWei = ethers.parseEther(amount.toString());
  const perLevel = totalWei / BigInt(levels.length);
  const remainder = totalWei % BigInt(levels.length);

  // Build bids array: { buyYes, priceInBps, amount, minShares }
  // Add any remainder to first bid to avoid losing dust
  return levels.map((level, i) => ({
    buyYes: level.buyYes,
    priceInBps: BigInt(level.priceInBps), // Must be BigInt for proper ABI encoding
    amount: i === 0 ? perLevel + remainder : perLevel,
    minShares: 0n // No slippage check for initial seeding
  }));
}

function getVaultParams() {
  if (!$('enableVault').checked) return null;
  const vaultAmount = parseFloat($('vaultAmount').value) || 0;
  if (vaultAmount <= 0) return null;
  const yesPct = parseInt($('vaultYesPct').value) || 0;
  const noPct = parseInt($('vaultNoPct').value) || 0;
  const collateralForVault = ethers.parseEther(vaultAmount.toString());
  // Shares are in wei - pct of total vault collateral
  const vaultYesShares = collateralForVault * BigInt(yesPct) / 100n;
  const vaultNoShares = collateralForVault * BigInt(noPct) / 100n;
  return { collateralForVault, vaultYesShares, vaultNoShares };
}

function getInitialBuyParams() {
  if (!$('enableInitialBuy').checked) return null;
  const amount = parseFloat($('initialBuyAmount').value) || 0;
  if (amount <= 0) return null;
  const buyYes = $('initialBuySide').value === 'yes';
  const collateralForBuy = ethers.parseEther(amount.toString());
  return { buyYes, collateralForBuy };
}

function getTotalCollateral() {
  const seedAmount = parseFloat($('seedAmount').value) || 0;
  const vaultAmount = $('enableVault').checked ? (parseFloat($('vaultAmount').value) || 0) : 0;
  const buyAmount = $('enableInitialBuy').checked ? (parseFloat($('initialBuyAmount').value) || 0) : 0;
  const bidsAmount = $('enableBids').checked ? (parseFloat($('bidsAmount').value) || 0) : 0;
  return seedAmount + vaultAmount + buyAmount + bidsAmount;
}

async function createMarket() {
  if (!connectedAddress) {
    closeCreateModal();
    return toggleWallet();
  }

  const seedAmount = parseFloat($('seedAmount').value) || 0;
  const totalCollateral = getTotalCollateral();

  // Validate minimum liquidity (ETH-equivalent)
  // For now create market uses ETH, so direct comparison
  // When non-ETH collateral is supported, use: collateralToETH(totalCollateral, selectedCollateral)
  const minLiquidity = MIN_ETH.DUST; // 0.0001 ETH minimum
  if (totalCollateral < minLiquidity) {
    const minStr = formatCollateralAmount(minLiquidity);
    alert(`Enter at least ${minStr} ETH total liquidity (AMM + Vault + Buy)`);
    return;
  }

  const collateralForLP = ethers.parseEther(seedAmount.toFixed(18));
  const totalWei = ethers.parseEther(totalCollateral.toFixed(18));
  const deadline = Math.floor(Date.now() / 1000) + 3600;
  const vaultParams = getVaultParams();
  const buyParams = getInitialBuyParams();
  const bidsParams = getBidsParams();

  // Route to appropriate handler based on market type
  if (currentMarketType === 'price') {
    await createPriceMarket(collateralForLP, totalWei, deadline, vaultParams, buyParams, bidsParams);
  } else if (currentMarketType === 'balance') {
    await createBalanceMarket(collateralForLP, totalWei, deadline, vaultParams, buyParams, bidsParams);
  } else if (currentMarketType === 'totalSupply') {
    await createTotalSupplyMarket(collateralForLP, totalWei, deadline, vaultParams, buyParams, bidsParams);
  }
}

async function createPriceMarket(collateralForLP, totalWei, deadline, vaultParams, buyParams, bidsParams) {
  const targetPriceRaw = $('targetPrice').value.replace(/[^0-9]/g, '');
  const targetPrice = parseInt(targetPriceRaw);
  const closeDateStr = $('closeDate').value;

  if (!targetPrice || targetPrice < 1) {
    alert('Enter a valid target price');
    return;
  }
  if (!closeDateStr) {
    alert('Select a close date and time');
    return;
  }

  const closeTimestamp = parseUTCDateTime(closeDateStr);
  const minCloseTime = Math.floor(Date.now() / 1000) + 3600; // At least 1 hour from now
  if (closeTimestamp < minCloseTime) {
    alert('Close date must be at least 1 hour in the future');
    return;
  }

  // Chainlink uses 8 decimals
  const threshold = BigInt(targetPrice) * BigInt(1e8);

  // Build tagged description for parsing: TYPE|ASSET|QUOTE|OP|PRICE|CLOSE (OP 3 = GTE)
  const description = `PRICE|ETH|USD|3|${targetPrice}|${closeTimestamp}`;

  $('createBtn').disabled = true;
  $('createBtn').textContent = 'CREATING...';

  try {
    const bootstrapper = new ethers.Contract(CONTRACTS.BOOTSTRAPPER, BOOTSTRAPPER_ABI, signer);
    let tx;

    const hasVaultOrBuy = vaultParams || buyParams;
    const hasBids = bidsParams && bidsParams.length > 0;

    if (hasVaultOrBuy && hasBids) {
      // Full bootstrap: AMM + Vault + Initial Buy + Bids
      const vault = vaultParams || { collateralForVault: 0n, vaultYesShares: 0n, vaultNoShares: 0n };
      const buy = buyParams || { buyYes: false, collateralForBuy: 0n };
      tx = await bootstrapper.bootstrapPriceMarketWithVaultAndBids(
        description,
        ethers.ZeroAddress,
        closeTimestamp,
        CONTRACTS.PM_FEE_HOOK,
        collateralForLP,
        connectedAddress,
        deadline,
        CONTRACTS.CHAINLINK_ETH_USD,
        OP.GTE,
        threshold,
        vault,
        buy,
        bidsParams,
        { value: totalWei }
      );
    } else if (hasVaultOrBuy) {
      // AMM + Vault + Initial Buy (no bids)
      const vault = vaultParams || { collateralForVault: 0n, vaultYesShares: 0n, vaultNoShares: 0n };
      const buy = buyParams || { buyYes: false, collateralForBuy: 0n };
      tx = await bootstrapper.bootstrapPriceMarketWithVault(
        description,
        ethers.ZeroAddress,
        closeTimestamp,
        CONTRACTS.PM_FEE_HOOK,
        collateralForLP,
        connectedAddress,
        deadline,
        CONTRACTS.CHAINLINK_ETH_USD,
        OP.GTE,
        threshold,
        vault,
        buy,
        { value: totalWei }
      );
    } else if (hasBids) {
      // AMM + Bids only (no vault/buy)
      tx = await bootstrapper.bootstrapPriceMarketWithBids(
        description,
        ethers.ZeroAddress,
        closeTimestamp,
        CONTRACTS.PM_FEE_HOOK,
        collateralForLP,
        connectedAddress,
        deadline,
        CONTRACTS.CHAINLINK_ETH_USD,
        OP.GTE,
        threshold,
        bidsParams,
        { value: totalWei }
      );
    } else {
      // Simple bootstrap (AMM only)
      tx = await bootstrapper.bootstrapPriceMarket(
        description,
        ethers.ZeroAddress,
        closeTimestamp,
        CONTRACTS.PM_FEE_HOOK,
        collateralForLP,
        connectedAddress,
        deadline,
        CONTRACTS.CHAINLINK_ETH_USD,
        OP.GTE,
        threshold,
        { value: collateralForLP }
      );
    }

    showTxPending(tx.hash);
    const receipt = await tx.wait();
    console.log('Bootstrap tx:', receipt.hash);

    const marketId = parseMarketIdFromReceipt(receipt);

    // Close modal and show success immediately after confirmation
    closeCreateModal();
    showCreateSuccess(receipt, marketId, vaultParams, buyParams, bidsParams);

    // Add market to UI (don't block success)
    if (marketId) {
      addMarketToUI(marketId, formatQuestion(targetPrice, closeTimestamp), targetPrice, closeTimestamp);
    }

  } catch (e) {
    hideToast();
    handleCreateError(e);
  } finally {
    $('createBtn').disabled = false;
    $('createBtn').textContent = 'CREATE MARKET';
  }
}

async function showCreateSuccess(receipt, marketId, vaultParams, buyParams, bidsParams) {
  const extras = [];
  if (vaultParams) extras.push('vault');
  if (buyParams && buyParams.collateralForBuy > 0n) extras.push('initial buy');
  if (bidsParams && bidsParams.length > 0) extras.push(`${bidsParams.length} bids`);
  const extraMsg = extras.length ? ` with ${extras.join(' + ')}` : '';

  const marketIdStr = marketId ? marketId.toString() : null;

  // Show success toast with link
  showTxSuccess(`Market created${extraMsg}!`, receipt.hash);

  // Load the new market and navigate to it
  if (marketIdStr) {
    await loadMarketById(marketIdStr);
    window.history.pushState({}, '', `#${marketIdStr}`);
    render();
    await loadAllMarketData();
  } else {
    // Fallback: reload all markets
    await loadMarkets();
    render();
  }
}

async function createBalanceMarket(collateralForLP, totalWei, deadline, vaultParams, buyParams, bidsParams) {
  const walletAddress = balanceWalletResolved || $('balanceWalletAddress').value.trim();
  const threshold = parseFloat($('balanceThreshold').value);
  const closeDateStr = $('balanceCloseDate').value;

  if (!walletAddress || !ethers.isAddress(walletAddress)) {
    alert('Enter a valid wallet address');
    return;
  }
  if (!threshold || threshold <= 0) {
    alert('Enter a valid balance threshold');
    return;
  }
  if (!closeDateStr) {
    alert('Select a close date and time');
    return;
  }

  const closeTimestamp = parseUTCDateTime(closeDateStr);
  const minCloseTime = Math.floor(Date.now() / 1000) + 3600;
  if (closeTimestamp < minCloseTime) {
    alert('Close date must be at least 1 hour in the future');
    return;
  }

  $('createBtn').disabled = true;
  $('createBtn').textContent = 'CREATING...';

  try {
    const bootstrapper = new ethers.Contract(CONTRACTS.BOOTSTRAPPER, BOOTSTRAPPER_ABI, signer);
    let tx;
    const hasBids = bidsParams && bidsParams.length > 0;
    const hasVault = vaultParams || buyParams;

    if (balanceAssetType === 'eth') {
      // ETH Balance market
      const thresholdWei = ethers.parseEther(threshold.toString());
      const description = `ETHBAL|${walletAddress}|3|${threshold}|${closeTimestamp}`;

      if (hasVault && hasBids) {
        const vault = vaultParams || { collateralForVault: 0n, vaultYesShares: 0n, vaultNoShares: 0n };
        const buy = buyParams || { buyYes: false, collateralForBuy: 0n };
        tx = await bootstrapper.bootstrapETHBalanceMarketWithVaultAndBids(
          description, ethers.ZeroAddress, closeTimestamp, CONTRACTS.PM_FEE_HOOK,
          collateralForLP, connectedAddress, deadline, walletAddress, OP.GTE, thresholdWei,
          vault, buy, bidsParams, { value: totalWei }
        );
      } else if (hasVault) {
        const vault = vaultParams || { collateralForVault: 0n, vaultYesShares: 0n, vaultNoShares: 0n };
        const buy = buyParams || { buyYes: false, collateralForBuy: 0n };
        tx = await bootstrapper.bootstrapETHBalanceMarketWithVault(
          description, ethers.ZeroAddress, closeTimestamp, CONTRACTS.PM_FEE_HOOK,
          collateralForLP, connectedAddress, deadline, walletAddress, OP.GTE, thresholdWei,
          vault, buy, { value: totalWei }
        );
      } else {
        tx = await bootstrapper.bootstrapETHBalanceMarket(
          description, ethers.ZeroAddress, closeTimestamp, CONTRACTS.PM_FEE_HOOK,
          collateralForLP, connectedAddress, deadline, walletAddress, OP.GTE, thresholdWei,
          { value: collateralForLP }
        );
      }
    } else {
      // Token Balance market
      const tokenAddress = balanceTokenData.address || $('balanceTokenAddress').value.trim();
      if (!tokenAddress || !ethers.isAddress(tokenAddress)) {
        alert('Enter a valid token address');
        $('createBtn').disabled = false;
        $('createBtn').textContent = 'CREATE MARKET';
        return;
      }

      const decimals = balanceTokenData.decimals || 18;
      const symbol = balanceTokenData.symbol || 'TOKEN';
      const thresholdUnits = ethers.parseUnits(threshold.toString(), decimals);
      const description = `TOKBAL|${tokenAddress}|${walletAddress}|3|${threshold}|${closeTimestamp}`;

      if (hasVault && hasBids) {
        const vault = vaultParams || { collateralForVault: 0n, vaultYesShares: 0n, vaultNoShares: 0n };
        const buy = buyParams || { buyYes: false, collateralForBuy: 0n };
        tx = await bootstrapper.bootstrapTokenBalanceMarketWithVaultAndBids(
          description, ethers.ZeroAddress, closeTimestamp, CONTRACTS.PM_FEE_HOOK,
          collateralForLP, connectedAddress, deadline, tokenAddress, walletAddress, OP.GTE, thresholdUnits,
          vault, buy, bidsParams, { value: totalWei }
        );
      } else if (hasVault) {
        const vault = vaultParams || { collateralForVault: 0n, vaultYesShares: 0n, vaultNoShares: 0n };
        const buy = buyParams || { buyYes: false, collateralForBuy: 0n };
        tx = await bootstrapper.bootstrapTokenBalanceMarketWithVault(
          description, ethers.ZeroAddress, closeTimestamp, CONTRACTS.PM_FEE_HOOK,
          collateralForLP, connectedAddress, deadline, tokenAddress, walletAddress, OP.GTE, thresholdUnits,
          vault, buy, { value: totalWei }
        );
      } else {
        tx = await bootstrapper.bootstrapTokenBalanceMarket(
          description, ethers.ZeroAddress, closeTimestamp, CONTRACTS.PM_FEE_HOOK,
          collateralForLP, connectedAddress, deadline, tokenAddress, walletAddress, OP.GTE, thresholdUnits,
          { value: collateralForLP }
        );
      }
    }

    showTxPending(tx.hash);
    const receipt = await tx.wait();
    console.log('Bootstrap tx:', receipt.hash);

    const marketId = parseMarketIdFromReceipt(receipt);
    if (marketId) {
      const shortAddr = `${walletAddress.slice(0,6)}...${walletAddress.slice(-4)}`;
      const assetName = balanceAssetType === 'eth' ? 'ETH' : (balanceTokenData.symbol || 'tokens');
      const formattedThreshold = threshold >= 1e6 ? `${(threshold/1e6).toFixed(1)}M` : threshold.toLocaleString();
      const q = `WILL <u style="text-decoration-color:#0F0">${shortAddr}</u> HOLD <u style="text-decoration-color:#627EEA">${formattedThreshold} ${assetName}</u>?`;
      addMarketToUI(marketId, q, threshold, closeTimestamp, balanceAssetType === 'eth' ? 'ethbal' : 'tokbal');
    }

    closeCreateModal();
    showCreateSuccess(receipt, marketId, vaultParams, buyParams, bidsParams);

  } catch (e) {
    hideToast();
    handleCreateError(e);
  } finally {
    $('createBtn').disabled = false;
    $('createBtn').textContent = 'CREATE MARKET';
  }
}

async function createETHBalanceMarket(collateralForLP, totalWei, deadline, vaultParams, buyParams, bidsParams) {
  const accountAddress = resolvedAddresses.ethBalance || $('ethBalanceAddress').value.trim();
  const threshold = parseFloat($('ethBalanceThreshold').value);
  const closeDateStr = $('ethBalanceCloseDate').value;

  if (!accountAddress || !ethers.isAddress(accountAddress)) {
    alert('Enter a valid wallet address');
    return;
  }
  if (!threshold || threshold <= 0) {
    alert('Enter a valid ETH threshold');
    return;
  }
  if (!closeDateStr) {
    alert('Select a close date and time');
    return;
  }

  const closeTimestamp = parseUTCDateTime(closeDateStr);
  const minCloseTime = Math.floor(Date.now() / 1000) + 3600; // At least 1 hour from now
  if (closeTimestamp < minCloseTime) {
    alert('Close date must be at least 1 hour in the future');
    return;
  }

  const thresholdWei = ethers.parseEther(threshold.toString());

  // Build tagged description: TYPE|ACCOUNT|OP|THRESHOLD|CLOSE (OP 3 = GTE)
  const description = `ETHBAL|${accountAddress}|3|${threshold}|${closeTimestamp}`;

  $('createBtn').disabled = true;
  $('createBtn').textContent = 'CREATING...';

  try {
    const bootstrapper = new ethers.Contract(CONTRACTS.BOOTSTRAPPER, BOOTSTRAPPER_ABI, signer);
    let tx;

    if (vaultParams || buyParams) {
      const vault = vaultParams || { collateralForVault: 0n, vaultYesShares: 0n, vaultNoShares: 0n };
      const buy = buyParams || { buyYes: false, collateralForBuy: 0n };

      tx = await bootstrapper.bootstrapETHBalanceMarketWithVault(
        description,
        ethers.ZeroAddress,
        closeTimestamp,
        CONTRACTS.PM_FEE_HOOK,
        collateralForLP,
        connectedAddress,
        deadline,
        accountAddress,
        OP.GTE,
        thresholdWei,
        vault,
        buy,
        { value: totalWei }
      );
    } else {
      tx = await bootstrapper.bootstrapETHBalanceMarket(
        description,
        ethers.ZeroAddress,
        closeTimestamp,
        CONTRACTS.PM_FEE_HOOK,
        collateralForLP,
        connectedAddress,
        deadline,
        accountAddress,
        OP.GTE,
        thresholdWei,
        { value: collateralForLP }
      );
    }

    const receipt = await tx.wait();
    console.log('Bootstrap tx:', receipt.hash);

    const marketId = parseMarketIdFromReceipt(receipt);
    if (marketId) {
      const shortAddr = `${accountAddress.slice(0,6)}...${accountAddress.slice(-4)}`;
      const q = `WILL <u style="text-decoration-color:#0F0">${shortAddr}</u> HOLD <u style="text-decoration-color:#627EEA">${threshold} ETH</u>?`;
      addMarketToUI(marketId, q, threshold, closeTimestamp, 'ethbal');
    }

    closeCreateModal();
    showCreateSuccess(receipt, marketId, vaultParams, buyParams, null);

  } catch (e) {
    handleCreateError(e);
  } finally {
    $('createBtn').disabled = false;
    $('createBtn').textContent = 'CREATE MARKET';
  }
}

async function createTokenBalanceMarket(collateralForLP, totalWei, deadline, vaultParams, buyParams, bidsParams) {
  const tokenAddress = $('tokenAddress').value.trim();
  const accountAddress = resolvedAddresses.tokenBalance || $('tokenBalanceAddress').value.trim();
  const threshold = parseFloat($('tokenBalanceThreshold').value);
  const closeDateStr = $('tokenBalanceCloseDate').value;

  if (!tokenAddress || !ethers.isAddress(tokenAddress)) {
    alert('Enter a valid token address');
    return;
  }
  if (!accountAddress || !ethers.isAddress(accountAddress)) {
    alert('Enter a valid wallet address');
    return;
  }
  if (!threshold || threshold <= 0) {
    alert('Enter a valid token threshold');
    return;
  }
  if (!closeDateStr) {
    alert('Select a close date and time');
    return;
  }

  const closeTimestamp = parseUTCDateTime(closeDateStr);
  const minCloseTime = Math.floor(Date.now() / 1000) + 3600; // At least 1 hour from now
  if (closeTimestamp < minCloseTime) {
    alert('Close date must be at least 1 hour in the future');
    return;
  }

  // Get token decimals (ERC20) or detect ERC721 (no decimals)
  let decimals = 18;
  let symbol = 'TOKEN';
  let isNFT = false;
  try {
    const rpc = await getRpc();
    const token = new ethers.Contract(tokenAddress, [
      'function decimals() view returns (uint8)',
      'function symbol() view returns (string)',
      'function supportsInterface(bytes4) view returns (bool)'
    ], rpc);

    // Check for ERC721 first (more reliable than catching decimals error)
    try {
      isNFT = await token.supportsInterface('0x80ac58cd');
    } catch (e) {
      // Not ERC165 compatible, assume ERC20
    }

    if (isNFT) {
      decimals = 0;
    } else {
      try {
        decimals = await token.decimals();
      } catch (e) {
        decimals = 18;
      }
    }

    try {
      symbol = await token.symbol();
    } catch (e) {
      symbol = isNFT ? 'NFT' : 'TOKEN';
    }
  } catch (e) {
    console.warn('Could not fetch token info, using defaults');
  }

  const thresholdUnits = ethers.parseUnits(threshold.toString(), decimals);

  // Build tagged description: TYPE|TOKEN|ACCOUNT|OP|THRESHOLD|CLOSE (OP 3 = GTE)
  // Use NFTBAL prefix for NFTs for clearer identification
  const typePrefix = isNFT ? 'NFTBAL' : 'TOKBAL';
  const description = `${typePrefix}|${tokenAddress}|${accountAddress}|3|${threshold}|${closeTimestamp}`;

  $('createBtn').disabled = true;
  $('createBtn').textContent = 'CREATING...';

  try {
    const bootstrapper = new ethers.Contract(CONTRACTS.BOOTSTRAPPER, BOOTSTRAPPER_ABI, signer);
    let tx;
    const hasBids = bidsParams && bidsParams.length > 0;
    const hasVault = vaultParams || buyParams;

    if (hasVault && hasBids) {
      // Both vault and bids
      const vault = vaultParams || { collateralForVault: 0n, vaultYesShares: 0n, vaultNoShares: 0n };
      const buy = buyParams || { buyYes: false, collateralForBuy: 0n };

      tx = await bootstrapper.bootstrapTokenBalanceMarketWithVaultAndBids(
        description,
        ethers.ZeroAddress,
        closeTimestamp,
        CONTRACTS.PM_FEE_HOOK,
        collateralForLP,
        connectedAddress,
        deadline,
        tokenAddress,
        accountAddress,
        OP.GTE,
        thresholdUnits,
        vault,
        buy,
        bidsParams,
        { value: totalWei }
      );
    } else if (hasVault) {
      // Vault only (no bids)
      const vault = vaultParams || { collateralForVault: 0n, vaultYesShares: 0n, vaultNoShares: 0n };
      const buy = buyParams || { buyYes: false, collateralForBuy: 0n };

      tx = await bootstrapper.bootstrapTokenBalanceMarketWithVault(
        description,
        ethers.ZeroAddress,
        closeTimestamp,
        CONTRACTS.PM_FEE_HOOK,
        collateralForLP,
        connectedAddress,
        deadline,
        tokenAddress,
        accountAddress,
        OP.GTE,
        thresholdUnits,
        vault,
        buy,
        { value: totalWei }
      );
    } else if (hasBids) {
      // Bids only (no vault)
      tx = await bootstrapper.bootstrapTokenBalanceMarketWithBids(
        description,
        ethers.ZeroAddress,
        closeTimestamp,
        CONTRACTS.PM_FEE_HOOK,
        collateralForLP,
        connectedAddress,
        deadline,
        tokenAddress,
        accountAddress,
        OP.GTE,
        thresholdUnits,
        bidsParams,
        { value: totalWei }
      );
    } else {
      // AMM only
      tx = await bootstrapper.bootstrapTokenBalanceMarket(
        description,
        ethers.ZeroAddress,
        closeTimestamp,
        CONTRACTS.PM_FEE_HOOK,
        collateralForLP,
        connectedAddress,
        deadline,
        tokenAddress,
        accountAddress,
        OP.GTE,
        thresholdUnits,
        { value: collateralForLP }
      );
    }

    const receipt = await tx.wait();
    console.log('Bootstrap tx:', receipt.hash);

    const marketId = parseMarketIdFromReceipt(receipt);
    if (marketId) {
      const shortAddr = `${accountAddress.slice(0,6)}...${accountAddress.slice(-4)}`;
      const formattedThreshold = threshold >= 1e6 ? `${(threshold/1e6).toFixed(1)}M` : threshold.toLocaleString();
      const q = `WILL <u style="text-decoration-color:#0F0">${shortAddr}</u> HOLD <u style="text-decoration-color:#627EEA">${formattedThreshold} ${symbol}</u>?`;
      addMarketToUI(marketId, q, threshold, closeTimestamp, 'tokbal');
    }

    closeCreateModal();
    showCreateSuccess(receipt, marketId, vaultParams, buyParams, null);

  } catch (e) {
    handleCreateError(e);
  } finally {
    $('createBtn').disabled = false;
    $('createBtn').textContent = 'CREATE MARKET';
  }
}

async function createTotalSupplyMarket(collateralForLP, totalWei, deadline, vaultParams, buyParams, bidsParams) {
  const tokenAddress = $('totalSupplyToken').value.trim();
  const threshold = parseFloat($('totalSupplyThreshold').value);
  const closeDateStr = $('totalSupplyCloseDate').value;
  const opSelect = $('totalSupplyOp').value;

  if (!tokenAddress || !ethers.isAddress(tokenAddress)) {
    alert('Enter a valid token address');
    return;
  }
  if (!threshold || threshold <= 0) {
    alert('Enter a valid supply threshold');
    return;
  }
  if (!closeDateStr) {
    alert('Select a close date and time');
    return;
  }

  const closeTimestamp = parseUTCDateTime(closeDateStr);
  const minCloseTime = Math.floor(Date.now() / 1000) + 3600;
  if (closeTimestamp < minCloseTime) {
    alert('Close date must be at least 1 hour in the future');
    return;
  }

  // Map selection to OP enum
  const opMap = { lt: OP.LT, gt: OP.GT, lte: OP.LTE, gte: OP.GTE };
  const op = opMap[opSelect] ?? OP.GTE;
  const opSymbols = { lt: '<', gt: '>', lte: '<=', gte: '>=' };
  const opSymbol = opSymbols[opSelect] || '>=';

  // Get token decimals
  let decimals = totalSupplyTokenData.decimals || 18;
  let symbol = totalSupplyTokenData.symbol || 'TOKEN';

  const thresholdUnits = ethers.parseUnits(threshold.toString(), decimals);

  // Build tagged description: SUPPLY|TOKEN|OP|THRESHOLD|CLOSE
  const description = `SUPPLY|${tokenAddress}|${op}|${threshold}|${closeTimestamp}`;

  // totalSupply() selector
  const callData = '0x18160ddd';

  $('createBtn').disabled = true;
  $('createBtn').textContent = 'CREATING...';

  try {
    const bootstrapper = new ethers.Contract(CONTRACTS.BOOTSTRAPPER, BOOTSTRAPPER_ABI, signer);
    let tx;
    const hasBids = bidsParams && bidsParams.length > 0;
    const hasVault = vaultParams || buyParams;

    if (hasVault && hasBids) {
      const vault = vaultParams || { collateralForVault: 0n, vaultYesShares: 0n, vaultNoShares: 0n };
      const buy = buyParams || { buyYes: false, collateralForBuy: 0n };

      tx = await bootstrapper.bootstrapWithConditionAndVaultAndBids(
        description,
        ethers.ZeroAddress,
        closeTimestamp,
        true, // canClose - allow early resolution
        CONTRACTS.PM_FEE_HOOK,
        collateralForLP,
        connectedAddress,
        deadline,
        tokenAddress,    // target contract
        callData,        // totalSupply()
        op,
        thresholdUnits,
        vault,
        buy,
        bidsParams,
        { value: totalWei }
      );
    } else if (hasVault) {
      const vault = vaultParams || { collateralForVault: 0n, vaultYesShares: 0n, vaultNoShares: 0n };
      const buy = buyParams || { buyYes: false, collateralForBuy: 0n };

      tx = await bootstrapper.bootstrapWithConditionAndVault(
        description,
        ethers.ZeroAddress,
        closeTimestamp,
        true,
        CONTRACTS.PM_FEE_HOOK,
        collateralForLP,
        connectedAddress,
        deadline,
        tokenAddress,
        callData,
        op,
        thresholdUnits,
        vault,
        buy,
        { value: totalWei }
      );
    } else if (hasBids) {
      tx = await bootstrapper.bootstrapWithConditionAndBids(
        description,
        ethers.ZeroAddress,
        closeTimestamp,
        true,
        CONTRACTS.PM_FEE_HOOK,
        collateralForLP,
        connectedAddress,
        deadline,
        tokenAddress,
        callData,
        op,
        thresholdUnits,
        bidsParams,
        { value: totalWei }
      );
    } else {
      tx = await bootstrapper.bootstrapWithCondition(
        description,
        ethers.ZeroAddress,
        closeTimestamp,
        true,
        CONTRACTS.PM_FEE_HOOK,
        collateralForLP,
        false,
        0n,
        0n,
        connectedAddress,
        deadline,
        tokenAddress,
        callData,
        op,
        thresholdUnits,
        { value: collateralForLP }
      );
    }

    showTxPending(tx.hash);
    const receipt = await tx.wait();
    console.log('Bootstrap tx:', receipt.hash);

    const marketId = parseMarketIdFromReceipt(receipt);
    if (marketId) {
      const formattedThreshold = threshold >= 1e6 ? `${(threshold/1e6).toFixed(1)}M` : threshold.toLocaleString();
      const q = `WILL <u style="text-decoration-color:#8247E5">${symbol}</u> SUPPLY BE <u style="text-decoration-color:#0F0">${opSymbol} ${formattedThreshold}</u>?`;
      addMarketToUI(marketId, q, threshold, closeTimestamp, 'supply');
    }

    closeCreateModal();
    showCreateSuccess(receipt, marketId, vaultParams, buyParams, bidsParams);

  } catch (e) {
    hideToast();
    handleCreateError(e);
  } finally {
    $('createBtn').disabled = false;
    $('createBtn').textContent = 'CREATE MARKET';
  }
}

async function createGasMarket(collateralForLP, totalWei, deadline, vaultParams, buyParams, bidsParams) {
  const marketType = $('gasMarketType').value;
  const closeDateStr = $('gasCloseDate').value;

  if (!closeDateStr) {
    alert('Select a close date and time');
    return;
  }

  const closeTimestamp = parseUTCDateTime(closeDateStr);
  const minCloseTime = Math.floor(Date.now() / 1000) + 3600; // At least 1 hour from now
  if (closeTimestamp < minCloseTime) {
    alert('Close date must be at least 1 hour in the future');
    return;
  }

  let description, methodName, methodArgs, useVault = false;

  if (marketType === 'range') {
    const lower = parseInt($('gasLower').value);
    const upper = parseInt($('gasUpper').value);
    if (!lower || !upper || lower >= upper) {
      alert('Enter valid gas range (lower < upper)');
      return;
    }
    // Gwei to wei for gas thresholds
    const lowerWei = BigInt(lower) * BigInt(1e9);
    const upperWei = BigInt(upper) * BigInt(1e9);
    description = `GAS|RANGE|${lower}|${upper}|${closeTimestamp}`;
    methodName = 'bootstrapGasRangeMarket';
    methodArgs = [
      description,
      ethers.ZeroAddress,
      closeTimestamp,
      false,
      CONTRACTS.PM_FEE_HOOK,
      collateralForLP,
      connectedAddress,
      deadline,
      lowerWei,
      upperWei
    ];
  } else {
    const threshold = parseInt($('gasThreshold').value);
    if (!threshold || threshold <= 0) {
      alert('Enter a valid gas threshold');
      return;
    }
    const thresholdWei = BigInt(threshold) * BigInt(1e9);
    const op = parseInt($('gasOp').value);

    const typeNames = { twap: 'TWAP', volatility: 'VOLATILITY', peak: 'PEAK', trough: 'TROUGH' };
    description = `GAS|${typeNames[marketType]}|${threshold}|${closeTimestamp}`;

    if (marketType === 'twap') {
      // TWAP supports vault deposits
      if (vaultParams || buyParams) {
        const vault = vaultParams || { collateralForVault: 0n, vaultYesShares: 0n, vaultNoShares: 0n };
        const buy = buyParams || { buyYes: false, collateralForBuy: 0n };
        methodName = 'bootstrapGasTWAPMarketWithVault';
        methodArgs = [
          description,
          ethers.ZeroAddress,
          closeTimestamp,
          false,
          CONTRACTS.PM_FEE_HOOK,
          collateralForLP,
          connectedAddress,
          deadline,
          op,
          thresholdWei,
          vault,
          buy
        ];
        useVault = true;
      } else {
        methodName = 'bootstrapGasTWAPMarket';
        methodArgs = [
          description,
          ethers.ZeroAddress,
          closeTimestamp,
          false,
          CONTRACTS.PM_FEE_HOOK,
          collateralForLP,
          connectedAddress,
          deadline,
          op,
          thresholdWei
        ];
      }
    } else if (marketType === 'volatility') {
      methodName = 'bootstrapGasVolatilityMarket';
      methodArgs = [
        description,
        ethers.ZeroAddress,
        closeTimestamp,
        false,
        CONTRACTS.PM_FEE_HOOK,
        collateralForLP,
        connectedAddress,
        deadline,
        thresholdWei
      ];
    } else if (marketType === 'peak') {
      methodName = 'bootstrapGasPeakMarket';
      methodArgs = [
        description,
        ethers.ZeroAddress,
        closeTimestamp,
        false,
        CONTRACTS.PM_FEE_HOOK,
        collateralForLP,
        connectedAddress,
        deadline,
        thresholdWei
      ];
    } else if (marketType === 'trough') {
      methodName = 'bootstrapGasTroughMarket';
      methodArgs = [
        description,
        ethers.ZeroAddress,
        closeTimestamp,
        false,
        CONTRACTS.PM_FEE_HOOK,
        collateralForLP,
        connectedAddress,
        deadline,
        thresholdWei
      ];
    }
  }

  $('createBtn').disabled = true;
  $('createBtn').textContent = 'CREATING...';

  try {
    const bootstrapper = new ethers.Contract(CONTRACTS.BOOTSTRAPPER, BOOTSTRAPPER_ABI, signer);
    const tx = await bootstrapper[methodName](...methodArgs, { value: useVault ? totalWei : collateralForLP });
    const receipt = await tx.wait();
    console.log('Gas market bootstrap tx:', receipt.hash);

    const marketId = parseMarketIdFromReceipt(receipt);
    if (marketId) {
      const threshold = parseInt($('gasThreshold').value) || 0;
      const lower = parseInt($('gasLower').value) || 0;
      const upper = parseInt($('gasUpper').value) || 0;
      const typeLabel = marketType.toUpperCase();
      const q = marketType === 'range'
        ? `WILL <u style="text-decoration-color:#F90">GAS</u> STAY BETWEEN <u style="text-decoration-color:#0F0">${lower}-${upper} GWEI</u>?`
        : `WILL <u style="text-decoration-color:#F90">GAS ${typeLabel}</u> REACH <u style="text-decoration-color:#0F0">${threshold} GWEI</u>?`;
      addMarketToUI(marketId, q, threshold || lower, closeTimestamp, 'gas');
    }

    closeCreateModal();
    showCreateSuccess(receipt, marketId, useVault ? vaultParams : null, useVault ? buyParams : null, null);

  } catch (e) {
    handleCreateError(e);
  } finally {
    $('createBtn').disabled = false;
    $('createBtn').textContent = 'CREATE MARKET';
  }
}

function parseMarketIdFromReceipt(receipt) {
  // Try multiple known event signatures
  const eventSignatures = [
    'MarketCreated(uint256,uint256,string,address,address,uint64,bool)',
    'MarketCreated(uint256,address,address)',
    'MarketCreated(uint256)',
    'Transfer(address,address,uint256)' // ERC1155 mint to get market ID
  ];

  for (const log of receipt.logs) {
    try {
      for (const sig of eventSignatures) {
        if (log.topics[0] === ethers.id(sig)) {
          // Market ID is typically in topics[1]
          if (log.topics[1]) {
            // Convert hex topic to decimal string
            const marketIdDecimal = BigInt(log.topics[1]).toString();
            return marketIdDecimal;
          }
        }
      }
    } catch (e) {}
  }

  // Fallback: look for any log from PAMM with a market-like ID in topics
  for (const log of receipt.logs) {
    try {
      if (log.address.toLowerCase() === CONTRACTS.PAMM.toLowerCase() && log.topics[1]) {
        // Convert hex topic to decimal string
        const marketIdDecimal = BigInt(log.topics[1]).toString();
        return marketIdDecimal;
      }
    } catch (e) {}
  }

  console.warn('Could not find market ID in receipt logs');
  return null;
}

function addMarketToUI(marketId, question, threshold, closeTimestamp, type = 'price') {
  const newMarket = {
    id: marketId.toString().slice(-6),
    marketId: marketId.toString(),
    q: question,
    c: type === 'price' ? '#627EEA' : '#0F0',
    logo: type === 'price' ? 'eth' : (type === 'ethbal' ? 'eth' : 'token'),
    y: 50,
    threshold: threshold,
    close: closeTimestamp,
    type: type
  };
  markets.unshift(newMarket);
  currentIndex = 0;
  render();
  window.history.pushState({}, '', `#${marketId}`);
}

function handleCreateError(e) {
  console.error('Create failed:', e);

  // Try to extract the most useful error message
  let msg = 'Unknown error';

  // Check for revert reason in various places ethers.js might put it
  if (e.reason) {
    msg = e.reason;
  } else if (e.data?.message) {
    msg = e.data.message;
  } else if (e.error?.message) {
    msg = e.error.message;
  } else if (e.shortMessage) {
    msg = e.shortMessage;
  } else if (e.message) {
    msg = e.message;
  }

  // For CALL_EXCEPTION, try to decode the revert data
  if (e.code === 'CALL_EXCEPTION' || msg.includes('CALL_EXCEPTION')) {
    const revertData = e.data || e.revert?.data || e.error?.data;
    if (revertData) {
      // Known error selectors from Bootstrapper
      const knownErrors = {
        '0x2929f974': 'TransferError',
        '0xab143c06': 'Reentrancy',
        '0x077a9c33': 'ValidationError'
      };
      const selector = revertData.slice(0, 10);
      if (knownErrors[selector]) {
        msg = `${knownErrors[selector]} - ${revertData}`;
      } else {
        msg = `Revert: ${revertData}`;
      }
    } else {
      msg = 'Transaction reverted (no revert data available)';
    }
  }

  if (!msg.toLowerCase().includes('user rejected') && !msg.toLowerCase().includes('user denied')) {
    alert('Create failed: ' + msg);
  }
}

// ======================== WALLET ========================
function initEIP6963() {
  // Listener already set up at script load time
  // Just re-request in case any new wallets appeared
  if (typeof window !== 'undefined') {
    window.dispatchEvent(new Event('eip6963:requestProvider'));
  }
}

function detectWallets() {
  const detected = [];
  const seenNames = new Set();

  // Step 1: Check WALLET_CONFIG for known wallets via window.ethereum flags
  for (const [key, config] of Object.entries(WALLET_CONFIG)) {
    if (key === 'walletconnect') continue;
    try {
      if (config.detect && config.detect()) {
        detected.push({ key, ...config });
        seenNames.add(config.name.toLowerCase());
      }
    } catch (e) {
      // Ignore detection errors
    }
  }

  // Step 2: Add EIP-6963 providers not already seen
  for (const [uuid, { info, provider }] of eip6963Providers.entries()) {
    const name = info?.name || 'Unknown';
    if (!seenNames.has(name.toLowerCase())) {
      const safeName = name.replace(/[<>&"']/g, c => ({'<':'&lt;','>':'&gt;','&':'&amp;','"':'&quot;',"'":'&#39;'}[c]));
      const iconUrl = info.icon && (info.icon.startsWith('data:') || info.icon.startsWith('https://')) ? info.icon : null;
      const safeIconUrl = iconUrl ? iconUrl.replace(/[<>&"']/g, c => ({'<':'&lt;','>':'&gt;','&':'&amp;','"':'&quot;',"'":'&#39;'}[c])) : null;
      detected.push({
        key: `eip6963_${uuid}`,
        name: safeName,
        icon: safeIconUrl ? `<img src="${safeIconUrl}" style="width:1.5rem;height:1.5rem;border-radius:4px;">` : '🔌',
        getProvider: () => provider
      });
      seenNames.add(name.toLowerCase());
    }
  }

  // Step 3: Check window.ethereum.providers array (multi-wallet setups)
  if (window.ethereum?.providers?.length) {
    for (let i = 0; i < window.ethereum.providers.length; i++) {
      const p = window.ethereum.providers[i];
      const name = p.isMetaMask ? 'MetaMask' : p.isCoinbaseWallet ? 'Coinbase' : p.isRabby ? 'Rabby' : null;
      if (name && !seenNames.has(name.toLowerCase())) {
        detected.push({ key: `provider_${i}`, name, icon: '🔗', getProvider: () => p });
        seenNames.add(name.toLowerCase());
      }
    }
  }

  // Step 4: Fallback to generic window.ethereum if no wallets found yet
  if (detected.length === 0 && window.ethereum) {
    detected.push({ key: 'injected', name: 'Browser Wallet', icon: '🔗', getProvider: () => window.ethereum });
  }

  // Step 5: Always add WalletConnect if available
  const wcModule = (typeof globalThis !== 'undefined' ? globalThis : window)['@walletconnect/ethereum-provider'];
  if (wcModule?.EthereumProvider) {
    detected.push({ key: 'walletconnect', name: 'WalletConnect', icon: '📱', isWalletConnect: true });
  }

  return detected;
}

function showWalletModal() {
  $('walletModal').classList.add('active');

  // Show loading state
  $('walletOptions').innerHTML = '<div style="padding:12px;text-align:center;">Detecting wallets...</div>';

  // Re-request EIP-6963 providers
  window.dispatchEvent(new Event('eip6963:requestProvider'));

  // Detect after short delay, with retry for slow wallets
  const doDetect = (attempt = 1) => {
    const wallets = detectWallets();
    const hasBrowserWallet = wallets.some(w => w.key !== 'walletconnect');

    // Retry once if no browser wallets found (some inject async)
    if (!hasBrowserWallet && attempt < 2) {
      setTimeout(() => doDetect(attempt + 1), 250);
    } else {
      renderWalletModal(wallets);
    }
  };

  setTimeout(() => doDetect(), 150);
}

function renderWalletModal(wallets) {
  const container = $('walletOptions');

  if (connectedAddress) {
    container.innerHTML = `
      <div style="padding: 12px; border: 2px solid var(--fg); margin-bottom: 12px;">
        <div style="font-weight: 600; margin-bottom: 6px;">Connected</div>
        <div style="font-size: 14px; word-break: break-all; color: #0F0;">${connectedAddress}</div>
      </div>
      <div class="wallet-option disconnect" onclick="disconnectWallet()">
        <span class="wallet-option-name">Disconnect</span>
      </div>
    `;
  } else {
    container.innerHTML = wallets.length > 0 ? wallets.map(w => `
      <div class="wallet-option" onclick="connectWithWallet('${w.key}')">
        <span class="wallet-option-icon">${w.icon}</span>
        <span class="wallet-option-name">${w.name}</span>
      </div>
    `).join('') : '<div style="padding:12px;text-align:center;">No wallets detected. Install MetaMask or use WalletConnect.</div>';
  }
}

function closeWalletModal() {
  $('walletModal').classList.remove('active');
}

function toggleWallet() {
  showWalletModal();
}

async function connectWithWallet(walletKey) {
  if (isConnecting) return;
  isConnecting = true;

  try {
    closeWalletModal();
    let walletProvider;

    if (walletKey === 'walletconnect') {
      const wcModule = (typeof globalThis !== 'undefined' ? globalThis : window)['@walletconnect/ethereum-provider'];
      const WCProvider = wcModule?.EthereumProvider;

      if (!WCProvider?.init) throw new Error('WalletConnect not available');

      if (walletConnectProvider) {
        try { await walletConnectProvider.disconnect?.(); } catch (e) {}
        walletConnectProvider = null;
      }

      walletConnectProvider = await WCProvider.init({
        projectId: '1e8390ef1c1d8a185e035912a1409749',
        chains: [1],
        showQrModal: true,
        rpcMap: { 1: 'https://1rpc.io/eth' },
        metadata: {
          name: 'ethPM',
          description: 'Ethereum Prediction Markets',
          url: window.location.origin,
          icons: []
        }
      });

      await walletConnectProvider.enable();
      walletProvider = walletConnectProvider;
    } else if (walletKey.startsWith('eip6963_')) {
      const uuid = walletKey.replace('eip6963_', '');
      walletProvider = eip6963Providers.get(uuid)?.provider;
    } else {
      walletProvider = WALLET_CONFIG[walletKey]?.getProvider() || window.ethereum;
    }

    if (!walletProvider) throw new Error('Wallet not found');

    if (walletKey !== 'walletconnect') {
      await walletProvider.request({ method: 'eth_requestAccounts' });
    }

    provider = new ethers.BrowserProvider(walletProvider);
    signer = await provider.getSigner();
    connectedAddress = await signer.getAddress();
    connectedWalletProvider = walletProvider;
    resetWalletCapabilities(); // Reset EIP-5792 capability cache for new wallet

    $('wallet').textContent = connectedAddress.slice(0, 6) + '...' + connectedAddress.slice(-4);
    resolveWeiName(connectedAddress);

    // Store handlers so they can be removed on disconnect
    // Don't reload if a transaction is pending
    walletProvider._onAccountsChanged = () => {
      if (isTrading) {
        console.warn('Wallet changed during transaction - will reload after completion');
        window._pendingReload = true;
      } else {
        window.location.reload();
      }
    };
    walletProvider._onChainChanged = () => {
      if (isTrading) {
        console.warn('Chain changed during transaction - will reload after completion');
        window._pendingReload = true;
      } else {
        window.location.reload();
      }
    };
    walletProvider.on('accountsChanged', walletProvider._onAccountsChanged);
    walletProvider.on('chainChanged', walletProvider._onChainChanged);

    localStorage.setItem('ethpm_wallet', walletKey);

    // Load positions after wallet connect
    await loadPositions();
    loadResolutionStatus();
    loadPriceChart();

  } catch (error) {
    console.error('Connection failed:', error);
    const msg = (error.message || '').toLowerCase();
    if (!msg.includes('user rejected') && !msg.includes('user denied')) {
      alert('Connection failed: ' + (error.message || 'Unknown error'));
    }
  } finally {
    isConnecting = false;
  }
}

function disconnectWallet() {
  // Remove wallet event listeners to prevent memory leaks
  if (connectedWalletProvider) {
    try {
      if (connectedWalletProvider._onAccountsChanged) {
        connectedWalletProvider.removeListener('accountsChanged', connectedWalletProvider._onAccountsChanged);
      }
      if (connectedWalletProvider._onChainChanged) {
        connectedWalletProvider.removeListener('chainChanged', connectedWalletProvider._onChainChanged);
      }
    } catch (e) {}
  }
  if (walletConnectProvider) {
    try { walletConnectProvider.disconnect(); } catch (e) {}
    walletConnectProvider = null;
  }
  provider = null;
  signer = null;
  connectedAddress = null;
  connectedWalletProvider = null;
  resetWalletCapabilities();
  userPositions = { yes: 0n, no: 0n };
  galleryClaimableCache.clear(); // Clear claimable cache on disconnect
  $('wallet').textContent = 'connect';
  $('positions').style.display = 'none';
  closeWalletModal();
  localStorage.removeItem('ethpm_wallet');
}

function toggleTheme() {
  dark = !dark;
  document.documentElement.dataset.theme = dark ? 'dark' : '';
  $('theme').textContent = dark ? 'light' : 'dark';
  localStorage.theme = dark ? 'dark' : 'light';
}

document.addEventListener('click', e => { if (!e.target.closest('.odds')) closeDrop(); });

// ======================== LP MODAL ========================
let lpAllocation = { yes: 0, no: 0, amm: 100 };

function showLPModal() {
  const m = markets[currentIndex];
  if (!m?.marketId) {
    alert('No market selected');
    return;
  }
  if (m.resolved) {
    alert('Cannot provide liquidity to a resolved market');
    return;
  }

  // Set market info in modal based on market type
  const isUniPM = m.description && (m.description.startsWith('V4 Protocol') || m.description.startsWith('UNI '));
  if (isUniPM) {
    // For uniPM markets, show shortened question
    const shortQ = m.q.replace(/<[^>]*>/g, '').slice(0, 30) + (m.q.length > 30 ? '...' : '');
    $('lpMarketName').textContent = shortQ;
  } else if (m.threshold) {
    // For ETH price markets, show price target
    const priceStr = m.threshold >= 1000 ? `$${(m.threshold/1000).toFixed(0)}K` : `$${m.threshold}`;
    $('lpMarketName').textContent = `ETH ${priceStr}`;
  } else {
    // Fallback to short question
    const shortQ = m.q.replace(/<[^>]*>/g, '').slice(0, 30) + (m.q.length > 30 ? '...' : '');
    $('lpMarketName').textContent = shortQ;
  }

  // Load TVL and collateral price
  loadMarketTVL(m.marketId);
  loadCollateralPrice(m.collateral);

  // Reset allocation to default
  lpAllocation = { yes: 0, no: 0, amm: 100 };
  $('lpYesSlider').value = 0;
  $('lpNoSlider').value = 0;
  $('lpAmmSlider').value = 100;
  $('lpYesPct').textContent = '0%';
  $('lpNoPct').textContent = '0%';
  $('lpAmmPct').textContent = '100%';
  $('lpAmount').value = '';
  updateLPPreview();

  // Show/hide vault options based on market type
  // Legacy markets only support AMM LP
  const isLabeled = isOurLabeledMarket(m.description);
  $('lpVaultOptions').style.display = isLabeled ? '' : 'none';
  $('lpPreviewVaultRows').style.display = isLabeled ? '' : 'none';

  // Disable AMM slider for legacy markets (must be 100%)
  $('lpAmmSlider').disabled = !isLabeled;

  // Update all labels and placeholders with collateral symbol
  const collateralSym = getCollateralSymbol(m.collateral);
  $('lpAmountLabel').textContent = `AMOUNT (${collateralSym})`;

  // Set placeholder to ETH-equivalent minimum (0.01 ETH worth)
  const minCollateral = ethToCollateral(MIN_ETH.LP_ADD, m.collateral);
  const placeholderAmt = formatCollateralAmount(Math.max(minCollateral, 0.01));
  $('lpAmount').placeholder = `${placeholderAmt} ${collateralSym}`;
  $('lpAmount').min = formatCollateralAmount(ethToCollateral(MIN_ETH.DUST, m.collateral));

  $('lpModal').classList.add('active');
}

function closeLPModal() {
  $('lpModal').classList.remove('active');
}

async function loadMarketTVL(marketId) {
  try {
    const rpc = provider || await getRpc();
    const pamm = new ethers.Contract(CONTRACTS.PAMM, PAMM_ABI, rpc);
    const quoter = new ethers.Contract(CONTRACTS.QUOTER, QUOTER_ABI, rpc);

    // Get locked collateral + bid pool depths for both sides
    const [market, yesBreakdown, noBreakdown] = await Promise.all([
      pamm.markets(BigInt(marketId)),
      quoter.getLiquidityBreakdown(BigInt(marketId), true, { gasLimit: 5000000 }).catch(() => null),
      quoter.getLiquidityBreakdown(BigInt(marketId), false, { gasLimit: 5000000 }).catch(() => null)
    ]);

    const lockedAmt = Number(market.collateralLocked) / 1e18;
    const yesBidDepth = yesBreakdown ? Number(yesBreakdown.poolBidDepth) / 1e18 : 0;
    const noBidDepth = noBreakdown ? Number(noBreakdown.poolBidDepth) / 1e18 : 0;
    const totalTvl = lockedAmt + yesBidDepth + noBidDepth;

    const collateralSym = getCollateralSymbol(market.collateral);
    const tvlStr = totalTvl < 1 ? totalTvl.toFixed(4) : totalTvl.toFixed(2);
    $('lpTvl').textContent = `${tvlStr} ${collateralSym}`;
  } catch (e) {
    const m = markets[currentIndex];
    const collateralSym = getCollateralSymbol(m?.collateral);
    $('lpTvl').textContent = `-- ${collateralSym}`;
  }
}

// Load and display collateral price in ETH (for non-ETH collateral)
async function loadCollateralPrice(collateralAddress) {
  const priceRow = $('lpPriceRow');
  const priceEl = $('lpCollateralPrice');

  // Hide for ETH collateral
  if (!collateralAddress || collateralAddress === ethers.ZeroAddress) {
    priceRow.style.display = 'none';
    return;
  }

  // Show loading state
  priceRow.style.display = '';
  const sym = getCollateralSymbol(collateralAddress);
  priceEl.textContent = `1 ${sym} = ...`;

  try {
    const priceInETH = await getCollateralPriceInETH(collateralAddress);
    if (priceInETH !== null) {
      const priceStr = priceInETH < 0.001 ? priceInETH.toFixed(6) : priceInETH < 1 ? priceInETH.toFixed(4) : priceInETH.toFixed(3);
      priceEl.innerHTML = `1 ${sym} = ${priceStr} ${TOKEN_LOGOS['eth']}ETH`;
    } else {
      priceRow.style.display = 'none';
    }
  } catch (e) {
    console.warn('Failed to load collateral price:', e);
    priceRow.style.display = 'none';
  }
}

function updateLPAllocation(changed) {
  const newVal = parseInt($(`lp${changed.charAt(0).toUpperCase() + changed.slice(1)}Slider`).value);
  lpAllocation[changed] = newVal;

  // Calculate remaining for other two sliders
  const remaining = 100 - newVal;
  const others = ['yes', 'no', 'amm'].filter(k => k !== changed);

  // Distribute remaining proportionally, or evenly if both were 0
  const otherSum = lpAllocation[others[0]] + lpAllocation[others[1]];
  if (otherSum > 0 && remaining > 0) {
    lpAllocation[others[0]] = Math.round(lpAllocation[others[0]] * remaining / otherSum);
    lpAllocation[others[1]] = remaining - lpAllocation[others[0]];
  } else if (remaining > 0) {
    lpAllocation[others[0]] = Math.floor(remaining / 2);
    lpAllocation[others[1]] = remaining - lpAllocation[others[0]];
  } else {
    lpAllocation[others[0]] = 0;
    lpAllocation[others[1]] = 0;
  }

  // Update sliders and percentages
  $('lpYesSlider').value = lpAllocation.yes;
  $('lpNoSlider').value = lpAllocation.no;
  $('lpAmmSlider').value = lpAllocation.amm;
  $('lpYesPct').textContent = lpAllocation.yes + '%';
  $('lpNoPct').textContent = lpAllocation.no + '%';
  $('lpAmmPct').textContent = lpAllocation.amm + '%';

  updateLPPreview();
}

function updateLPPreview() {
  const amount = parseFloat($('lpAmount').value) || 0;

  // Calculate allocation amounts (collateral going to each)
  const yesAmount = amount * lpAllocation.yes / 100;
  const noAmount = amount * lpAllocation.no / 100;
  const ammCollateral = amount * lpAllocation.amm / 100;

  // For AMM LP: collateral is split 1:1 into YES/NO shares, then added as liquidity
  // LP tokens received depends on pool state:
  // - Empty pool: LP = sqrt(yes * no) = shares (when equal)
  // - Existing pool: LP = shares * totalSupply / max(yesReserve, noReserve)
  let ammLpTokens = ammCollateral; // Default for empty pool
  if (poolStats.totalSupply > 0n && (poolStats.yesReserve > 0n || poolStats.noReserve > 0n)) {
    const sharesWei = BigInt(Math.floor(ammCollateral * 1e18));
    const maxReserve = poolStats.yesReserve > poolStats.noReserve ? poolStats.yesReserve : poolStats.noReserve;
    if (maxReserve > 0n) {
      const lpWei = sharesWei * poolStats.totalSupply / maxReserve;
      ammLpTokens = Number(lpWei) / 1e18;
    }
  }

  // Preview values
  $('lpPreviewYes').textContent = yesAmount > 0 ? yesAmount.toFixed(4) : '0';
  $('lpPreviewNo').textContent = noAmount > 0 ? noAmount.toFixed(4) : '0';
  $('lpPreviewAmm').textContent = ammLpTokens > 0 ? ammLpTokens.toFixed(4) : '0';
}

async function provideLiquidity() {
  if (!connectedAddress) {
    closeLPModal();
    return toggleWallet();
  }

  const m = markets[currentIndex];
  if (!m?.marketId) {
    alert('No market selected.');
    return;
  }

  const amount = parseFloat($('lpAmount').value);
  if (!amount || amount <= 0) {
    alert('Enter an amount');
    return;
  }

  // Calculate allocation in wei (use toFixed to avoid floating point precision issues)
  const collateralWei = ethers.parseEther(amount.toFixed(18));
  const yesWei = ethers.parseEther((amount * lpAllocation.yes / 100).toFixed(18));
  const noWei = ethers.parseEther((amount * lpAllocation.no / 100).toFixed(18));
  const ammWei = ethers.parseEther((amount * lpAllocation.amm / 100).toFixed(18));

  const deadline = Math.floor(Date.now() / 1000) + 3600;

  // Detect if market uses ERC20 collateral
  const useETH = isETHCollateral(m.collateral);

  $('lpBtn').disabled = true;
  $('lpBtn').textContent = 'PROVIDING...';

  try {
    const pamm = new ethers.Contract(CONTRACTS.PAMM, PAMM_ABI, signer);
    const isLabeled = isOurLabeledMarket(m.description);
    let tx;

    // For legacy/external markets, use direct PAMM.splitAndAddLiquidity (AMM only)
    if (!isLabeled) {
      // Legacy markets only support AMM LP via splitAndAddLiquidity
      if (lpAllocation.yes > 0 || lpAllocation.no > 0) {
        alert('Legacy markets only support AMM LP. Set YES/NO vault allocation to 0%.');
        return;
      }

      const pammInterface = new ethers.Interface(PAMM_ABI);
      const tokenInterface = new ethers.Interface(ERC20_ABI);

      // Check if we need approval
      let needsApproval = false;
      if (!useETH) {
        const token = new ethers.Contract(m.collateral, ERC20_ABI, provider);
        const allowance = await token.allowance(connectedAddress, CONTRACTS.PAMM);
        needsApproval = allowance < collateralWei;
      }

      // Build LP calldata
      const lpCalldata = pammInterface.encodeFunctionData('splitAndAddLiquidity', [
        BigInt(m.marketId), collateralWei, LEGACY_FEE_BPS, 0, 0, 0, connectedAddress, deadline
      ]);

      // Try EIP-5792 atomic batching first
      if (needsApproval && await supportsAtomicBatch()) {
        showToast('Confirm approval + LP in your wallet...', 'pending');

        const approveCalldata = tokenInterface.encodeFunctionData('approve', [
          CONTRACTS.PAMM, collateralWei
        ]);

        const batchResult = await sendBatchedCalls([
          { to: m.collateral, data: approveCalldata },
          { to: CONTRACTS.PAMM, data: lpCalldata }
        ]);

        if (batchResult.success) {
          tx = { hash: batchResult.hash, wait: async () => provider.getTransactionReceipt(batchResult.hash) };
        } else {
          throw new Error(batchResult.error || 'Batch transaction failed');
        }
      } else if (needsApproval) {
        await ensureERC20Approval(m.collateral, CONTRACTS.PAMM, collateralWei);
        tx = await pamm.splitAndAddLiquidity(BigInt(m.marketId), collateralWei, LEGACY_FEE_BPS, 0, 0, 0, connectedAddress, deadline);
      } else {
        tx = await pamm.splitAndAddLiquidity(
          BigInt(m.marketId), collateralWei, LEGACY_FEE_BPS, 0, 0, 0, connectedAddress, deadline,
          useETH ? { value: collateralWei } : {}
        );
      }
    } else {
      // Check operator approval for MasterRouter
      const isOp = await pamm.isOperator(connectedAddress, CONTRACTS.MASTER_ROUTER);
      if (!isOp) {
        const approveTx = await pamm.setOperator(CONTRACTS.MASTER_ROUTER, true);
        await approveTx.wait();
      }

      const router = new ethers.Contract(CONTRACTS.MASTER_ROUTER, MASTER_ROUTER_ABI, signer);
      const routerInterface = new ethers.Interface(MASTER_ROUTER_ABI);
      const tokenInterface = new ethers.Interface(ERC20_ABI);

      // Check if we need approval
      let needsApproval = false;
      if (!useETH) {
        const token = new ethers.Contract(m.collateral, ERC20_ABI, provider);
        const allowance = await token.allowance(connectedAddress, CONTRACTS.MASTER_ROUTER);
        needsApproval = allowance < collateralWei;
      }

      // Build the LP calldata
      const lpCalldata = routerInterface.encodeFunctionData('provideLiquidity', [
        m.marketId, collateralWei, yesWei, noWei, ammWei, 0, 0, connectedAddress, deadline
      ]);

      // Try EIP-5792 atomic batching first (single popup for approve + LP)
      if (needsApproval && await supportsAtomicBatch()) {
        showToast('Confirm approval + LP in your wallet...', 'pending');

        const approveCalldata = tokenInterface.encodeFunctionData('approve', [
          CONTRACTS.MASTER_ROUTER, collateralWei
        ]);

        const batchResult = await sendBatchedCalls([
          { to: m.collateral, data: approveCalldata },
          { to: CONTRACTS.MASTER_ROUTER, data: lpCalldata }
        ]);

        if (batchResult.success) {
          tx = { hash: batchResult.hash, wait: async () => provider.getTransactionReceipt(batchResult.hash) };
        } else {
          throw new Error(batchResult.error || 'Batch transaction failed');
        }
      } else if (needsApproval) {
        // Fall back to permit signature + multicall or approve tx + LP tx
        const approval = await ensureERC20Approval(m.collateral, CONTRACTS.MASTER_ROUTER, collateralWei);

        if (approval.usePermit) {
          // Use multicall: permit + provideLiquidity
          const permitCalldata = routerInterface.encodeFunctionData('permit', [
            m.collateral, connectedAddress, approval.permitData.amount, approval.permitData.deadline,
            approval.permitData.v, approval.permitData.r, approval.permitData.s
          ]);
          tx = await router.multicall([permitCalldata, lpCalldata]);
        } else {
          // Traditional flow: approval already done, just do LP
          tx = await router.provideLiquidity(m.marketId, collateralWei, yesWei, noWei, ammWei, 0, 0, connectedAddress, deadline);
        }
      } else {
        // No approval needed - just do the LP
        tx = await router.provideLiquidity(
          m.marketId, collateralWei, yesWei, noWei, ammWei, 0, 0, connectedAddress, deadline,
          useETH ? { value: collateralWei } : {}
        );
      }
    }

    showTxPending(tx.hash);
    const receipt = await tx.wait();
    console.log('Provide liquidity tx:', receipt.hash);

    // Show success immediately after confirmation
    closeLPModal();
    showTxSuccess('Liquidity provided!', receipt.hash);

    // Refresh market data (don't block success toast)
    try {
      m.y = await loadMarketOdds(m.marketId);
      await loadPositions();
      render();
    } catch (refreshErr) {
      console.warn('State refresh after LP failed:', refreshErr);
    }

  } catch (e) {
    console.error('Provide liquidity failed:', e);
    const msg = e.reason || e.message || 'Unknown error';
    if (!msg.toLowerCase().includes('user rejected')) {
      showTxError('Provide liquidity failed: ' + msg);
    } else {
      hideToast(); // Hide pending toast on user rejection
    }
  } finally {
    $('lpBtn').disabled = false;
    $('lpBtn').textContent = 'PROVIDE LIQUIDITY';
  }
}

// ======================== ORDERS MODAL ========================
function showOrdersModal() {
  const m = markets[currentIndex];
  if (!m?.marketId) {
    alert('No market selected');
    return;
  }
  if (m.resolved) {
    alert('Cannot place orders on a resolved market');
    return;
  }
  if (!isOurLabeledMarket(m.description)) {
    alert('Limit orders only work on ethPM/uniPM markets');
    return;
  }

  // Set market name
  const isUniPM = m.description && (m.description.startsWith('V4 Protocol') || m.description.startsWith('UNI '));
  if (isUniPM) {
    const shortQ = m.q.replace(/<[^>]*>/g, '').slice(0, 25) + (m.q.length > 25 ? '...' : '');
    $('ordersMarketName').textContent = shortQ;
  } else if (m.threshold) {
    const priceStr = m.threshold >= 1000 ? `$${(m.threshold/1000).toFixed(0)}K` : `$${m.threshold}`;
    $('ordersMarketName').textContent = `ETH ${priceStr}`;
  } else {
    const shortQ = m.q.replace(/<[^>]*>/g, '').slice(0, 25) + (m.q.length > 25 ? '...' : '');
    $('ordersMarketName').textContent = shortQ;
  }

  // Update shares balance display
  const yBal = formatShares(userPositions.yes || 0);
  const nBal = formatShares(userPositions.no || 0);
  $('ordersSharesBalance').innerHTML = `<span style="color:#0F0">${yBal} Y</span> / <span style="color:#F00">${nBal} N</span>`;

  // Reset inputs
  const collateralSym = getCollateralSymbol(m.collateral);
  $('orderPrice').value = '';
  $('orderAmount').value = '';
  $('orderPreview').style.display = 'none';

  // Reset to BUY YES
  setOrderType('buy');
  setOrderSide('yes');
  updateOrderLabels();

  $('ordersModal').classList.add('active');
}

function closeOrdersModal() {
  $('ordersModal').classList.remove('active');
}

function setOrderType(type) {
  $('orderType').value = type;
  document.querySelectorAll('.order-type-btn').forEach(btn => {
    btn.classList.remove('active');
    if (btn.classList.contains(type)) btn.classList.add('active');
  });
  updateOrderLabels();
  updateOrderPreview();
}

function setOrderSide(side) {
  $('orderSide').value = side;
  document.querySelectorAll('#ordersModal .bid-side-btn').forEach(btn => {
    btn.classList.remove('active');
    if (btn.classList.contains(side)) btn.classList.add('active');
  });
  updateOrderPreview();
}

function updateOrderLabels() {
  const m = markets[currentIndex];
  const collateralSym = getCollateralSymbol(m?.collateral);
  const isBuy = $('orderType').value === 'buy';

  $('orderSideLabel').textContent = isBuy ? 'Buy which side?' : 'Sell which side?';
  $('orderAmountLabel').textContent = isBuy ? `Spend (${collateralSym})` : 'Shares to sell';

  // Set placeholder to ETH-equivalent minimum for buy orders
  if (isBuy) {
    const minCollateral = ethToCollateral(MIN_ETH.ORDER, m?.collateral);
    const placeholderAmt = formatCollateralAmount(Math.max(minCollateral, 0.01));
    $('orderAmount').placeholder = `${placeholderAmt} ${collateralSym}`;
    $('orderAmount').min = formatCollateralAmount(ethToCollateral(MIN_ETH.DUST, m?.collateral));
  } else {
    $('orderAmount').placeholder = '10 shares';
    $('orderAmount').min = '1';
  }

  // Update button color
  const btn = $('orderBtn');
  if (isBuy) {
    btn.style.background = 'linear-gradient(135deg, #0F0 0%, #0A0 100%)';
    btn.textContent = 'PLACE BUY ORDER';
  } else {
    btn.style.background = 'linear-gradient(135deg, #F66 0%, #C44 100%)';
    btn.textContent = 'PLACE SELL ORDER';
  }
}

function updateOrderPreview() {
  const previewEl = $('orderPreview');
  const descEl = $('orderPreviewDesc');
  const winEl = $('orderPreviewWin');
  const loseEl = $('orderPreviewLose');

  const pricePercent = parseFloat($('orderPrice').value);
  const amount = parseFloat($('orderAmount').value);
  const isBuy = $('orderType').value === 'buy';
  const isYes = $('orderSide').value === 'yes';

  if (!pricePercent || !amount || pricePercent < 1 || pricePercent > 99 || amount <= 0) {
    previewEl.style.display = 'none';
    return;
  }

  const m = markets[currentIndex];
  const collateralSym = getCollateralSymbol(m?.collateral);
  const side = isYes ? 'YES' : 'NO';
  const sideColor = isYes ? '#0F0' : '#F00';
  const pricePerShare = pricePercent / 100;

  previewEl.style.display = 'block';

  if (isBuy) {
    // BUY: spending collateral to get shares
    const expectedShares = amount / pricePerShare;
    const winPayout = expectedShares; // shares redeem at 1
    const winProfit = winPayout - amount;
    const lossAmount = amount;

    descEl.innerHTML = `Buy <span class="shares" style="color:${sideColor}">${expectedShares.toFixed(2)} ${side}</span> @ ${pricePercent}% (<span class="collateral">${pricePerShare.toFixed(2)} ${collateralSym}</span>/share)`;
    winEl.innerHTML = `✓ If <span style="color:${sideColor}">${side}</span> wins: get <span class="collateral">${winPayout.toFixed(2)} ${collateralSym}</span> (+${winProfit.toFixed(2)} profit)`;
    loseEl.innerHTML = `✗ If <span style="color:${isYes ? '#F00' : '#0F0'}">${isYes ? 'NO' : 'YES'}</span> wins: lose <span class="collateral">${lossAmount.toFixed(2)} ${collateralSym}</span>`;
  } else {
    // SELL: selling shares to get collateral
    const shares = amount;
    const expectedCollateral = shares * pricePerShare;
    const opportunityCost = shares - expectedCollateral; // what you'd get if your side wins vs selling now

    descEl.innerHTML = `Sell <span class="shares" style="color:${sideColor}">${shares.toFixed(2)} ${side}</span> @ ${pricePercent}% → get <span class="collateral">${expectedCollateral.toFixed(2)} ${collateralSym}</span>`;
    winEl.innerHTML = `✓ Locked in: <span class="collateral">${expectedCollateral.toFixed(2)} ${collateralSym}</span> regardless of outcome`;
    loseEl.innerHTML = `⚠ If ${side} wins: would have gotten ${shares.toFixed(2)} instead (opportunity cost: ${opportunityCost.toFixed(2)})`;
  }
}

async function placeOrder() {
  if (!connectedAddress) {
    closeOrdersModal();
    return toggleWallet();
  }

  const m = markets[currentIndex];
  if (!m?.marketId) {
    alert('No market selected');
    return;
  }

  const isBuy = $('orderType').value === 'buy';
  const isYes = $('orderSide').value === 'yes';
  const pricePercent = parseFloat($('orderPrice').value);
  const amount = parseFloat($('orderAmount').value);

  if (!pricePercent || pricePercent < 1 || pricePercent > 99) {
    alert('Price must be between 1% and 99%');
    return;
  }

  if (!amount || amount <= 0) {
    alert('Enter an amount');
    return;
  }

  const priceInBps = Math.round(pricePercent * 100);
  const amountWei = ethers.parseEther(amount.toString());
  const useETH = isETHCollateral(m.collateral);

  $('orderBtn').disabled = true;
  $('orderBtn').textContent = isBuy ? 'PLACING BUY...' : 'PLACING SELL...';

  try {
    const masterRouter = new ethers.Contract(CONTRACTS.MASTER_ROUTER, MASTER_ROUTER_ABI, signer);
    let tx;

    if (isBuy) {
      // BUY order = deposit to bid pool
      if (!useETH) {
        const token = new ethers.Contract(m.collateral, ERC20_ABI, provider);
        const allowance = await token.allowance(connectedAddress, CONTRACTS.MASTER_ROUTER);
        if (allowance < amountWei) {
          await ensureERC20Approval(m.collateral, CONTRACTS.MASTER_ROUTER, amountWei);
        }
      }
      showToast('Confirm buy order...', 'pending');
      tx = await masterRouter.depositToBidPool(
        m.marketId, isYes, priceInBps, amountWei, connectedAddress,
        useETH ? { value: amountWei } : {}
      );
    } else {
      // SELL order = deposit to ask pool (shares)
      // Need PAMM approval for shares
      const pamm = new ethers.Contract(CONTRACTS.PAMM, PAMM_ABI, signer);
      const isApproved = await pamm.isApprovedForAll(connectedAddress, CONTRACTS.MASTER_ROUTER);
      if (!isApproved) {
        showToast('Approve PAMM for share transfers...', 'pending');
        const approveTx = await pamm.setApprovalForAll(CONTRACTS.MASTER_ROUTER, true);
        await approveTx.wait();
      }
      showToast('Confirm sell order...', 'pending');
      tx = await masterRouter.depositToPool(
        m.marketId, isYes, priceInBps, amountWei, connectedAddress
      );
    }

    showTxPending(tx.hash);
    const receipt = await tx.wait();

    closeOrdersModal();
    const side = isYes ? 'YES' : 'NO';
    showTxSuccess(`${isBuy ? 'Buy' : 'Sell'} order placed: ${side} @ ${pricePercent}%`, receipt.hash);

    // Refresh
    try {
      await loadAllMarketData();
      render();
    } catch (e) {
      console.warn('Refresh after order failed:', e);
    }

  } catch (e) {
    console.error('Place order failed:', e);
    const msg = e.reason || e.message || 'Unknown error';
    if (!msg.toLowerCase().includes('user rejected')) {
      showTxError('Order failed: ' + msg);
    } else {
      hideToast();
    }
  } finally {
    $('orderBtn').disabled = false;
    updateOrderLabels();
  }
}

// ======================== WITHDRAW LIQUIDITY ========================
async function withdrawVault(isYes) {
  if (!connectedAddress) return toggleWallet();

  const m = markets[currentIndex];
  if (!m?.marketId) {
    alert('No market selected');
    return;
  }

  const vaultShares = isYes ? lpPositions.yesVault : lpPositions.noVault;
  if (vaultShares <= 0n) {
    alert(`No ${isYes ? 'YES' : 'NO'} vault shares to withdraw`);
    return;
  }

  const btnId = isYes ? 'yesVaultWithdrawBtn' : 'noVaultWithdrawBtn';
  $(btnId).disabled = true;
  $(btnId).textContent = '...';

  try {
    const hookRouter = new ethers.Contract(CONTRACTS.PM_HOOK_ROUTER, PM_HOOK_ROUTER_ABI, signer);
    const deadline = Math.floor(Date.now() / 1000) + 3600;

    const tx = await hookRouter.withdrawFromVault(
      m.marketId,
      isYes,
      vaultShares,  // Withdraw all
      connectedAddress,
      deadline
    );

    showTxPending(tx.hash);
    const receipt = await tx.wait();
    console.log('Withdraw vault tx:', receipt.hash);

    // Show success immediately after confirmation
    showTxSuccess(`Withdrew ${isYes ? 'YES' : 'NO'} vault!`, receipt.hash);

    // Refresh positions and UI (don't block success toast)
    try {
      await loadPositions();
      render();
    } catch (refreshErr) {
      console.warn('Refresh after withdraw failed:', refreshErr);
    }

  } catch (e) {
    console.error('Withdraw vault failed:', e);
    const msg = e.reason || e.message || 'Unknown error';
    if (!msg.toLowerCase().includes('user rejected')) {
      showTxError('Withdraw failed: ' + msg);
    } else {
      hideToast();
    }
  } finally {
    $(btnId).disabled = false;
    $(btnId).textContent = 'WITHDRAW';
  }
}

async function harvestFees(isYes) {
  if (!connectedAddress) return toggleWallet();

  const m = markets[currentIndex];
  if (!m?.marketId) {
    alert('No market selected');
    return;
  }

  const pendingFees = isYes ? lpPositions.yesFees : lpPositions.noFees;
  if (pendingFees <= 0n) {
    alert(`No ${isYes ? 'YES' : 'NO'} vault fees to harvest`);
    return;
  }

  const btnId = isYes ? 'yesHarvestBtn' : 'noHarvestBtn';
  $(btnId).disabled = true;
  $(btnId).textContent = '...';

  try {
    const hookRouter = new ethers.Contract(CONTRACTS.PM_HOOK_ROUTER, PM_HOOK_ROUTER_ABI, signer);

    const tx = await hookRouter.harvestVaultFees(m.marketId, isYes);

    showTxPending(tx.hash);
    const receipt = await tx.wait();
    console.log('Harvest fees tx:', receipt.hash);

    // Show success immediately after confirmation
    const harvestedAmt = formatFees(pendingFees, m.collateral);
    showTxSuccess(`Harvested ${harvestedAmt}!`, receipt.hash);

    // Refresh positions and UI (don't block success toast)
    try {
      await loadPositions();
      render();
    } catch (refreshErr) {
      console.warn('Refresh after harvest failed:', refreshErr);
    }

  } catch (e) {
    console.error('Harvest fees failed:', e);
    const msg = e.reason || e.message || 'Unknown error';
    if (!msg.toLowerCase().includes('user rejected')) {
      showTxError('Harvest failed: ' + msg);
    } else {
      hideToast();
    }
  } finally {
    $(btnId).disabled = false;
    $(btnId).textContent = 'HARVEST';
  }
}

async function withdrawAmmLP() {
  if (!connectedAddress) return toggleWallet();

  const m = markets[currentIndex];
  if (!m?.marketId) {
    alert('No market selected');
    return;
  }

  if (lpPositions.ammLP <= 0n) {
    alert('No AMM LP to withdraw');
    return;
  }

  $('ammLpWithdrawBtn').disabled = true;
  $('ammLpWithdrawBtn').textContent = '...';

  try {
    // First approve ZAMM operator for PAMM if needed
    const zamm = new ethers.Contract(CONTRACTS.ZAMM, ZAMM_ABI, signer);
    const isOp = await zamm.isOperator(connectedAddress, CONTRACTS.PAMM);
    if (!isOp) {
      const approveTx = await zamm.setOperator(CONTRACTS.PAMM, true);
      await approveTx.wait();
    }

    // Call PAMM.removeLiquidityToCollateral
    const pamm = new ethers.Contract(CONTRACTS.PAMM, PAMM_ABI, signer);
    const deadline = Math.floor(Date.now() / 1000) + 3600;

    // Determine feeOrHook based on market type
    // For hooked pools, feeOrHook = hookAddress | FLAG_BEFORE | FLAG_AFTER
    const isLabeled = isOurLabeledMarket(m.description);
    const feeOrHook = isLabeled
      ? (BigInt(CONTRACTS.PM_FEE_HOOK) | FLAG_BEFORE | FLAG_AFTER)
      : BigInt(LEGACY_FEE_BPS);

    const tx = await pamm.removeLiquidityToCollateral(
      m.marketId,
      feeOrHook,                 // feeOrHook (hook with flags for our markets, 30 bps for legacy)
      lpPositions.ammLP,         // liquidity
      0,                          // amount0Min
      0,                          // amount1Min
      0,                          // minCollateralOut
      connectedAddress,
      deadline
    );

    showTxPending(tx.hash);
    const receipt = await tx.wait();
    console.log('Withdraw AMM LP tx:', receipt.hash);

    // Show success immediately after confirmation
    showTxSuccess('Withdrew AMM LP!', receipt.hash);

    // Refresh positions and UI (don't block success toast)
    try {
      await loadPositions();
      render();
    } catch (refreshErr) {
      console.warn('Refresh after AMM LP withdraw failed:', refreshErr);
    }

  } catch (e) {
    console.error('Withdraw AMM LP failed:', e);
    const msg = e.reason || e.message || 'Unknown error';
    if (!msg.toLowerCase().includes('user rejected')) {
      showTxError('Withdraw failed: ' + msg);
    } else {
      hideToast();
    }
  } finally {
    $('ammLpWithdrawBtn').disabled = false;
    $('ammLpWithdrawBtn').textContent = 'WITHDRAW';
  }
}

// ======================== MARKET BROWSER ========================
let browserFilter = 'all';    // 'all', 'price', 'balance'
let browserStatus = 'open';   // 'open', 'resolved', 'all'
let browserSearch = '';
let browserOddsRefreshing = false;

function showBrowserModal() {
  $('browserModal').classList.add('active');
  $('browserSearch').value = '';
  browserSearch = '';
  renderBrowserList();
  // Refresh odds for visible markets in background
  refreshBrowserOdds();
}

// Refresh odds for markets displayed in browser modal using multicall
async function refreshBrowserOdds() {
  if (browserOddsRefreshing) return;
  browserOddsRefreshing = true;

  try {
    const rpc = provider || await getRpc();

    // Get markets that are displayed (matching filters) - refresh ALL for accuracy
    const visibleMarkets = markets.filter(m => {
      if (browserStatus === 'open' && m.resolved) return false;
      if (browserStatus === 'resolved' && !m.resolved) return false;
      if (browserFilter !== 'all') {
        const type = getMarketType(m);
        if (type !== browserFilter) return false;
      }
      if (browserSearch) {
        const text = (stripHtml(m.q) + ' ' + (m.marketId || '')).toLowerCase();
        if (!text.includes(browserSearch)) return false;
      }
      return !m.resolved; // Refresh all open markets
    });

    // Limit to first 30 (multicall can handle more efficiently)
    const marketsToRefresh = visibleMarkets.slice(0, 30);
    if (!marketsToRefresh.length) {
      browserOddsRefreshing = false;
      return;
    }

    // Force refresh (clear oddsLoaded to ensure fresh fetch)
    marketsToRefresh.forEach(m => m.oddsLoaded = false);

    // Use multicall for batched fetching
    await batchFetchOdds(marketsToRefresh, rpc);

    // Re-render browser list with updated odds
    const modal = $('browserModal');
    if (modal && modal.classList.contains('active')) {
      renderBrowserList();
    }
  } catch (e) {
    console.warn('Failed to refresh browser odds:', e);
  } finally {
    browserOddsRefreshing = false;
  }
}

function closeBrowserModal() {
  $('browserModal').classList.remove('active');
}

function setBrowserFilter(f) {
  browserFilter = f;
  // Update active state on buttons
  document.querySelectorAll('.market-filter').forEach((btn, i) => {
    const filters = ['all', 'price', 'balance', 'supply'];
    btn.classList.toggle('active', filters[i] === f);
  });
  renderBrowserList();
}

function setBrowserStatus(s) {
  browserStatus = s;
  // Update active state on buttons
  document.querySelectorAll('.market-status-filter').forEach((btn, i) => {
    const statuses = ['open', 'resolved', 'all'];
    btn.classList.toggle('active', statuses[i] === s);
  });
  renderBrowserList();
}

function onBrowserSearch(e) {
  browserSearch = e.target.value.toLowerCase();
  renderBrowserList();
}

function getMarketType(m) {
  // Determine type from description or parsed data
  if (!m.q) return 'unknown';
  const q = m.q.toLowerCase();
  if (q.includes('gas') || q.includes('gwei')) return 'gas';
  if (q.includes('supply')) return 'supply';
  if (q.includes('0x') && (q.includes('eth') || q.includes('bal'))) return 'balance';
  if (q.includes('$') || q.includes('price') || q.includes('hit') || q.includes('drop')) return 'price';
  // Check the raw description if available
  if (m.description) {
    if (m.description.startsWith('GAS|')) return 'gas';
    if (m.description.startsWith('SUPPLY|')) return 'supply';
    if (m.description.startsWith('ETHBAL|') || m.description.startsWith('TOKBAL|') || m.description.startsWith('LEGACY|')) return 'balance';
    if (m.description.startsWith('PRICE|')) return 'price';
  }
  return 'price'; // default
}

function stripHtml(html) {
  const tmp = document.createElement('div');
  tmp.innerHTML = html;
  return tmp.textContent || tmp.innerText || '';
}

function renderBrowserList() {
  const listEl = $('browserList');

  // Filter markets
  let filtered = markets.filter(m => {
    // Status filter
    if (browserStatus === 'open' && m.resolved) return false;
    if (browserStatus === 'resolved' && !m.resolved) return false;

    // Type filter
    if (browserFilter !== 'all') {
      const type = getMarketType(m);
      if (type !== browserFilter) return false;
    }

    // Search filter
    if (browserSearch) {
      const text = (stripHtml(m.q) + ' ' + (m.marketId || '')).toLowerCase();
      if (!text.includes(browserSearch)) return false;
    }

    return true;
  });

  // Render
  if (filtered.length === 0) {
    listEl.innerHTML = '<div class="market-empty">No markets found</div>';
    return;
  }

  listEl.innerHTML = filtered.map((m, idx) => {
    const type = getMarketType(m);
    const question = stripHtml(m.q || '');
    const shortQ = question.length > 50 ? question.slice(0, 47) + '...' : question;
    const pct = typeof m.y === 'number' ? m.y : 50;
    const pctDisplay = pct.toFixed(2); // Match main page precision (2 decimals)
    const idShort = m.marketId ? '#' + m.marketId.slice(0, 8) : '';
    const collateralSym = getCollateralSymbol(m.collateral);
    const tvl = m.tvl ? m.tvl.toFixed(2) + ` ${collateralSym}` : '--';
    const countdown = m.resolved ? 'RESOLVED' : formatCountdown(m.close);

    // Find the actual index in the main markets array
    const realIdx = markets.indexOf(m);

    return `
      <div class="market-item" onclick="selectMarket(${realIdx})">
        <span class="market-item-pct">${pctDisplay}%</span>
        <div class="market-item-q">
          <span class="market-type-dot ${type}"></span>${shortQ}
        </div>
        <div class="market-item-meta">${idShort} | ${tvl} | ${countdown}</div>
      </div>
    `;
  }).join('');
}

function selectMarket(idx) {
  currentIndex = idx;
  closeBrowserModal();
  closeGallery();
  closeDrop();
  resetResolvePanel();
  render();
  loadAllMarketData(); // Combined loader syncs odds regardless of panel state
}

// ======================== MARKET GALLERY ========================
let gallerySearch = '';
let galleryStatus = 'open'; // 'open', 'resolved', 'all'
let galleryClaimableCache = new Map(); // marketId -> { hasWinning: bool, amount: bigint }

function showGallery(updateHash = true) {
  $('marketGallery').classList.add('active');
  document.querySelector('.main').style.display = 'none';
  $('navPrev').style.display = 'none';
  $('navNext').style.display = 'none';
  // Update logo to link to landing page
  $('logo').setAttribute('onclick', 'goToLanding()');
  $('gallerySearch').value = '';
  gallerySearch = '';
  // Only reset to 'open' if not already set by deep link
  if (!window.location.hash.includes('browse/')) {
    galleryStatus = 'open';
  }
  // Reset filter button states
  document.querySelectorAll('.gallery-filter').forEach((btn, i) => {
    const statuses = ['open', 'resolved', 'all'];
    btn.classList.toggle('active', statuses[i] === galleryStatus);
  });
  // Update URL hash
  if (updateHash) {
    const newHash = galleryStatus === 'open' ? '#browse' : `#browse/${galleryStatus}`;
    if (window.location.hash !== newHash) {
      window.history.pushState({}, '', newHash);
    }
  }
  renderGallery();
  refreshGalleryOdds();
}

function setGalleryStatus(status, updateHash = true) {
  galleryStatus = status;
  // Update filter button states
  document.querySelectorAll('.gallery-filter').forEach((btn, i) => {
    const statuses = ['open', 'resolved', 'all'];
    btn.classList.toggle('active', statuses[i] === status);
  });
  // Update URL hash
  if (updateHash) {
    const newHash = status === 'open' ? '#browse' : `#browse/${status}`;
    if (window.location.hash !== newHash) {
      window.history.pushState({}, '', newHash);
    }
  }
  renderGallery();
  // Check claimable positions when showing resolved markets
  if ((status === 'resolved' || status === 'all') && connectedAddress) {
    checkGalleryClaimable();
  }
}

function closeGallery() {
  $('marketGallery').classList.remove('active');
  document.querySelector('.main').style.display = '';
  $('navPrev').style.display = '';
  $('navNext').style.display = '';
  // Restore logo to open gallery
  $('logo').setAttribute('onclick', 'showGallery()');
  // Clear browse hash if present (but don't trigger hashchange loop)
  if (window.location.hash.startsWith('#browse') || window.location.hash.startsWith('#gallery')) {
    const m = markets[currentIndex];
    const newHash = m?.marketId ? `#${m.marketId}` : '';
    window.history.pushState({}, '', newHash || window.location.pathname);
  }
}

function goToLanding() {
  currentIndex = 0;
  const m = markets[0];
  if (m?.marketId) {
    window.history.pushState({}, '', `#${m.marketId}`);
  }
  closeGallery();
  closeDrop();
  resetResolvePanel();
  render();
  loadAllMarketData();
}

function onGallerySearch(e) {
  gallerySearch = e.target.value.toLowerCase();
  renderGallery();
}

async function refreshGalleryOdds() {
  try {
    const rpc = provider || await getRpc();

    // Get open markets sorted by TVL - refresh ALL visible markets for accuracy
    const openMarkets = allMarkets.filter(m => !m.resolved);
    const sortedByTvl = [...openMarkets].sort((a, b) => (b.tvl || 0) - (a.tvl || 0));
    const marketsToRefresh = sortedByTvl.slice(0, 30);

    if (!marketsToRefresh.length) return;

    // Force refresh all visible markets (clear oddsLoaded to ensure fresh fetch)
    marketsToRefresh.forEach(m => m.oddsLoaded = false);

    // Use multicall for batched fetching
    await batchFetchOdds(marketsToRefresh, rpc);

    // Re-render if gallery still open
    if ($('marketGallery').classList.contains('active')) {
      renderGallery();
    }
  } catch (e) {
    console.warn('Failed to refresh gallery odds:', e);
  }
}

function renderGallery() {
  const gridEl = $('galleryGrid');

  // Filter markets based on status and search
  let filtered = allMarkets.filter(m => {
    // Status filter
    if (galleryStatus === 'open' && m.resolved) return false;
    if (galleryStatus === 'resolved' && !m.resolved) return false;
    // Search filter
    if (gallerySearch) {
      const text = (stripHtml(m.q) + ' ' + (m.marketId || '')).toLowerCase();
      if (!text.includes(gallerySearch)) return false;
    }
    return true;
  });

  // Sort: resolved by most recent close, open by TVL
  filtered.sort((a, b) => {
    if (a.resolved !== b.resolved) return a.resolved ? 1 : -1; // Open first
    if (a.resolved) return (b.close || 0) - (a.close || 0); // Resolved: newest first
    return (b.tvl || 0) - (a.tvl || 0); // Open: highest TVL first
  });

  if (filtered.length === 0) {
    gridEl.innerHTML = '<div class="market-empty">No markets found</div>';
    return;
  }

  gridEl.innerHTML = filtered.map(m => {
    const question = stripHtml(m.q || '');
    // Truncate question for card display
    const shortQ = question.length > 60 ? question.slice(0, 57) + '...' : question;
    const collateralSym = getCollateralSymbol(m.collateral);
    const collateralIcon = getCollateralLogo(m.collateral);
    const tvl = m.tvl ? (m.tvl < 1 ? m.tvl.toFixed(4) : m.tvl.toFixed(2)) + ` ${collateralSym}` : '--';
    const idShort = m.marketId ? '#' + m.marketId.slice(0, 8) : '';

    // Find index in main markets array (for navigation)
    const realIdx = markets.indexOf(m);
    const allIdx = allMarkets.indexOf(m);

    if (m.resolved) {
      // Resolved market card
      const outcomeClass = m.outcome ? 'yes' : 'no';
      const outcomeText = m.outcome ? 'YES' : 'NO';
      const claimable = galleryClaimableCache.get(m.marketId);
      let claimBtn = '';
      if (connectedAddress && claimable?.hasWinning) {
        const amt = Number(claimable.amount) / 1e18;
        const amtStr = amt < 1 ? amt.toFixed(4) : amt.toFixed(2);
        claimBtn = `<button class="market-card-claim" onclick="event.stopPropagation();claimFromGallery('${m.marketId}', this)">CLAIM ${amtStr} ${collateralSym}</button>`;
      } else if (connectedAddress && claimable === undefined) {
        claimBtn = `<button class="market-card-claim checking" disabled>checking...</button>`;
      }
      return `
        <div class="market-card resolved" onclick="selectMarketFromGalleryAll(${allIdx})" title="${question.replace(/"/g, '&quot;')}">
          <div class="market-card-q">${shortQ}<span class="market-card-outcome ${outcomeClass}">${outcomeText} WINS</span></div>
          <div class="market-card-meta">
            <span>${idShort}</span>
            <span class="market-card-tvl">${collateralIcon}${tvl}</span>
          </div>
          ${claimBtn}
        </div>
      `;
    }

    // Open market card
    const oddsReady = m.oddsLoaded && typeof m.y === 'number';
    const pct = oddsReady ? m.y : 50;
    // Match main page precision: 2 decimal places
    const yesPct = oddsReady ? pct.toFixed(2) : '...';
    const noPct = oddsReady ? (100 - pct).toFixed(2) : '...';

    return `
      <div class="market-card" onclick="selectMarketFromGallery(${realIdx})" title="${question.replace(/"/g, '&quot;')}">
        <div class="market-card-q">${shortQ}</div>
        <div class="market-card-odds${oddsReady ? '' : ' loading'}">
          <div class="y" style="width: ${Math.max(pct, 10)}%">Y ${yesPct}${oddsReady ? '%' : ''}</div>
          <div class="n">N ${noPct}${oddsReady ? '%' : ''}</div>
        </div>
        <div class="market-card-meta">
          <span>${idShort}</span>
          <span class="market-card-tvl">${collateralIcon}${tvl}</span>
        </div>
      </div>
    `;
  }).join('');
}

function selectMarketFromGallery(idx) {
  currentIndex = idx;
  const m = markets[idx];
  if (m?.marketId) {
    window.history.pushState({}, '', `#${m.marketId}`);
  }
  closeGallery();
  closeDrop();
  resetMarketState();
  resetResolvePanel();
  render();
  loadAllMarketData();
}

// Select from allMarkets (includes resolved) - adds to main markets if needed
function selectMarketFromGalleryAll(allIdx) {
  const m = allMarkets[allIdx];
  if (!m) return;

  // Check if it's already in main markets
  let idx = markets.findIndex(x => x.marketId === m.marketId);
  if (idx === -1) {
    // Add resolved market to front of main markets temporarily
    markets.unshift(m);
    idx = 0;
  }
  currentIndex = idx;
  if (m.marketId) {
    window.history.pushState({}, '', `#${m.marketId}`);
  }
  closeGallery();
  closeDrop();
  resetMarketState();
  resetResolvePanel();
  render();
  loadAllMarketData();
}

// Check which resolved markets have claimable shares for connected user
async function checkGalleryClaimable() {
  if (!connectedAddress) return;

  const rpc = provider || await getRpc();
  const pamm = new ethers.Contract(CONTRACTS.PAMM, PAMM_ABI, rpc);

  // Get resolved markets
  const resolvedMarkets = allMarkets.filter(m => m.resolved);
  if (!resolvedMarkets.length) return;

  // Build multicall to check balances
  const pammInterface = new ethers.Interface(PAMM_ABI);
  const calls = [];

  for (const m of resolvedMarkets) {
    const marketId = BigInt(m.marketId);
    const noId = BigInt(ethers.keccak256(ethers.solidityPacked(['string', 'uint256'], ['PMARKET:NO', marketId])));

    // Check winning side balance
    const winningId = m.outcome ? marketId : noId;
    calls.push({
      target: CONTRACTS.PAMM,
      callData: pammInterface.encodeFunctionData('balanceOf', [connectedAddress, winningId]),
      decode: (data) => pammInterface.decodeFunctionResult('balanceOf', data),
      market: m
    });
  }

  try {
    const results = await multicall(calls, rpc);

    for (let i = 0; i < results.length; i++) {
      const result = results[i];
      const m = calls[i].market;

      if (result.success) {
        try {
          const balance = result.decode()[0];
          galleryClaimableCache.set(m.marketId, {
            hasWinning: balance > 0n,
            amount: balance
          });
        } catch (e) {
          galleryClaimableCache.set(m.marketId, { hasWinning: false, amount: 0n });
        }
      } else {
        galleryClaimableCache.set(m.marketId, { hasWinning: false, amount: 0n });
      }
    }

    // Re-render gallery to show claim buttons
    if ($('marketGallery').classList.contains('active')) {
      renderGallery();
    }
  } catch (e) {
    console.warn('Failed to check claimable:', e);
  }
}

// Claim shares from gallery view
async function claimFromGallery(marketId, btn) {
  if (!connectedAddress) return toggleWallet();

  const m = allMarkets.find(x => x.marketId === marketId);
  if (!m?.resolved) return;

  const originalText = btn.textContent;
  btn.disabled = true;
  btn.textContent = 'CLAIMING...';

  try {
    const pamm = new ethers.Contract(CONTRACTS.PAMM, PAMM_ABI, signer);

    showToast('Confirm claim in wallet...', 'pending', 0);
    const tx = await pamm.claim(BigInt(marketId), connectedAddress);
    showTxPending(tx.hash);

    const receipt = await tx.wait();

    // Update cache immediately after confirmation
    galleryClaimableCache.set(marketId, { hasWinning: false, amount: 0n });

    // Update button to show claimed state before re-render
    btn.textContent = 'CLAIMED!';
    btn.classList.add('claimed');

    showTxSuccess('Claimed!', receipt.hash);

    // Re-render after short delay to let user see "CLAIMED!" state
    setTimeout(() => {
      if ($('marketGallery').classList.contains('active')) {
        renderGallery();
      }
    }, 1500);

  } catch (e) {
    console.error('Claim failed:', e);
    const msg = e.reason || e.message || 'Unknown error';
    if (!msg.toLowerCase().includes('user rejected')) {
      showTxError('Claim failed: ' + msg);
    } else {
      hideToast();
    }
    // Restore button state on error
    btn.disabled = false;
    btn.textContent = originalText;
  }
}

// Initialize on load
init();
</script>
</body>
</html>
