<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<title>PM</title>
<meta property="og:title" content="PREDICT">
<meta property="og:description" content="The open onchain prediction market">
<meta property="og:type" content="website">
<meta property="og:url" content="">
<meta property="og:image" content="">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="PREDICT">
<meta name="twitter:description" content="The open onchain prediction market">
<meta name="twitter:image" content="">
<link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 400 400' width='400' height='400'%3E%3Crect width='400' height='400' fill='%23000'/%3E%3CclipPath id='frame'%3E%3Crect width='400' height='400'/%3E%3C/clipPath%3E%3Cg clip-path='url(%23frame)'%3E%3Cpath d='M-60-20L460-20L460 90L80 310L460 310L460 420L-60 420L-60 310L320 90L-60 90Z' fill='white'/%3E%3C/g%3E%3C/svg%3E" type="image/svg+xml">
<script>
(function(){var d=localStorage.getItem('dark');if(d==='1'||(d===null&&matchMedia('(prefers-color-scheme:dark)').matches))document.documentElement.classList.add('dark')})();
</script>
<style>
.zorg-bg{fill:#fff}.zorg-fg{fill:#000}
.dark .zorg-bg{fill:#000}.dark .zorg-fg{fill:#fff}
* { margin:0; padding:0; box-sizing:border-box; -webkit-tap-highlight-color:transparent; }
:root {
  --bg:#fff;--fg:#000;--fg-muted:#666;--fg-dim:#999;
  --border:#000;--border-muted:#ddd;
  --surface:#f9f9f9;--surface-hover:#f5f5f5;
  --btn-bg:#000;--btn-fg:#fff;--btn-hover:#333;
  --btn-dis-bg:transparent;--btn-dis-border:#ccc;--btn-dis-fg:#999;
  --status-error:#fff0f0;--status-success:#f0fff0;
  --link-fg:inherit;
  --modal-overlay:rgba(0,0,0,0.8);--modal-bg:#fff;--modal-border:#000;
  --card-border:#ccc;
  --green:#22c55e;--red:#ef4444;--yes:#22c55e;--no:#ef4444;
}
.dark {
  --bg:#0a0a0a;--fg:#e8e8e0;--fg-muted:#888;--fg-dim:#666;
  --border:#333;--border-muted:#333;
  --surface:#111;--surface-hover:#151515;
  --btn-bg:#e8e8e0;--btn-fg:#0a0a0a;--btn-hover:#ccc;
  --btn-dis-bg:transparent;--btn-dis-border:#444;--btn-dis-fg:#666;
  --status-error:#1a0000;--status-success:#001a00;
  --link-fg:#e8e8e0;
  --modal-overlay:rgba(0,0,0,0.85);--modal-bg:#111;--modal-border:#333;
  --card-border:#333;
  --green:#22c55e;--red:#ef4444;--yes:#22c55e;--no:#ef4444;
}
body {
  font-family:Helvetica,Arial,sans-serif;
  background:var(--bg);color:var(--fg);
  min-height:100vh;padding:60px 20px 20px;
  max-width:480px;margin:0 auto;
  overflow-x:hidden;
}
a { color:var(--link-fg); }
button {
  display:inline-block;font-family:inherit;cursor:pointer;
  border:1px solid var(--btn-bg);border-radius:0;
  background:var(--btn-bg);color:var(--btn-fg);
  padding:12px 24px;font-size:12px;font-weight:600;
  letter-spacing:0.1em;text-transform:uppercase;
  transition:background 0.2s, border-color 0.2s, color 0.2s;
}
button:hover { background:var(--btn-hover); }
button:disabled { background:var(--btn-dis-bg);border:1px solid var(--btn-dis-border);color:var(--btn-dis-fg);cursor:not-allowed; }
input {
  font-family:inherit;font-size:14px;background:transparent;color:var(--fg);
  border:none;border-bottom:1.5px solid var(--border);outline:none;
  padding:8px 0;width:100%;
}
.header {
  display:flex;justify-content:space-between;align-items:center;margin-bottom:24px;
}
.header h1 {
  font-size:14px;font-weight:400;letter-spacing:0.1em;text-transform:uppercase;
}
.back-link { font-size:12px;color:var(--fg-muted);text-decoration:none;margin-bottom:16px;display:inline-block; }
.back-link:hover { color:var(--fg); }

/* Search */
.market-search {
  width:100%;padding:10px 0;font-size:13px;border:none;border-bottom:1px solid var(--border);
  outline:none;background:transparent;color:var(--fg);margin-bottom:20px;
}
.market-search::placeholder { color:var(--fg-dim); }

/* Gallery */
.market-grid {
  display:flex;flex-direction:column;gap:14px;
}
.market-card {
  border:1px solid var(--border-muted);padding:18px 16px;
  cursor:pointer;transition:background 0.15s, border-color 0.15s;text-decoration:none;color:var(--fg);display:block;
}
.market-card:hover { background:var(--surface-hover);border-color:var(--fg-muted); }
.market-card:active { opacity:0.8; }
.market-card-question {
  font-size:clamp(12.5px, 3.5vw, 14px);font-weight:600;line-height:1.55;margin-bottom:12px;
  display:-webkit-box;-webkit-line-clamp:2;-webkit-box-orient:vertical;overflow:hidden;
}
.market-card-odds-label {
  display:flex;justify-content:space-between;font-size:11px;font-weight:600;margin-bottom:4px;
}
.market-card-odds-label .yes-label { color:var(--yes); }
.market-card-odds-label .no-label { color:var(--no); }
.market-card-odds {
  display:flex;height:3px;overflow:hidden;margin-bottom:10px;gap:1px;
}
.market-card-yes {
  background:var(--yes);transition:width 0.3s;
}
.market-card-no {
  background:var(--no);flex:1;transition:width 0.3s;
}
.market-card-meta {
  font-size:clamp(10.5px, 2.8vw, 12px);color:var(--fg-muted);display:flex;justify-content:space-between;padding-top:10px;border-top:1px solid var(--border-muted);
}
.market-card.resolved { opacity:0.6; }
.market-card.resolved .market-card-question { color:var(--fg-muted); }
.market-card.resolved .market-card-question::after {
  content:attr(data-outcome);font-size:11px;font-weight:700;margin-left:6px;
  padding:2px 6px;vertical-align:middle;
}
.market-card[data-won="yes"] .market-card-question::after { background:var(--yes);color:#000; }
.market-card[data-won="no"] .market-card-question::after { background:var(--no);color:#fff; }

/* Filter tabs */
.filter-tabs {
  display:flex;gap:0;margin-bottom:16px;
}
.filter-tab {
  flex:1;padding:10px 4px;font-size:12px;font-weight:600;letter-spacing:0.08em;text-transform:uppercase;
  border:none;border-bottom:2px solid transparent;border-radius:0;
  background:transparent;color:var(--fg-muted);
  cursor:pointer;font-family:inherit;transition:color 0.15s,border-color 0.15s;
}
.filter-tab:hover { color:var(--fg); }
.filter-tab.active { color:var(--fg);border-bottom-color:var(--fg); }

/* Detail page */
.section-card {
  border:1px solid var(--border-muted);padding:16px;margin-bottom:16px;
}
.section-title {
  font-size:10px;font-weight:600;letter-spacing:0.1em;text-transform:uppercase;
  color:var(--fg-dim);margin-bottom:10px;
}
.stat-row { display:flex;justify-content:space-between;align-items:center;font-size:12px;margin-bottom:4px; }
.stat-label { color:var(--fg-dim);font-size:11px; }
.stat-value { font-weight:500;overflow:hidden;text-overflow:ellipsis;min-width:0;color:var(--fg-muted); }

/* Odds bar (detail) */
.odds-label {
  display:flex;justify-content:space-between;margin-bottom:6px;
}
.odds-label span { font-size:20px;font-weight:700; }
.odds-label .yes-label { color:var(--yes); }
.odds-label .no-label { color:var(--no); }
.odds-bar {
  display:flex;height:4px;overflow:hidden;margin-bottom:16px;cursor:default;gap:1px;
}
.odds-yes {
  background:var(--yes);transition:width 0.3s;
}
.odds-no {
  background:var(--no);flex:1;transition:width 0.3s;
}

/* Trade panel */
.trade-dir { display:flex;gap:0;margin-bottom:14px; }
.trade-dir button {
  flex:1;padding:7px 0;font-size:11px;font-weight:600;letter-spacing:0.08em;text-transform:uppercase;
  border:1px solid var(--border-muted);border-radius:0;
  background:transparent;color:var(--fg-muted);
  cursor:pointer;font-family:inherit;transition:color 0.15s,background 0.15s,border-color 0.15s;margin:0;
}
.trade-dir button + button { border-left:none; }
.trade-dir button:hover { color:var(--fg); }
.trade-dir button.active { color:var(--btn-fg);background:var(--btn-bg);border-color:var(--btn-bg); }
.trade-side { display:flex;gap:6px;margin-bottom:14px; }
.trade-side button {
  flex:1;padding:7px 0;font-size:11px;font-weight:600;letter-spacing:0.08em;text-transform:uppercase;
  border:none;border-bottom:2px solid transparent;border-radius:0;
  background:transparent;color:var(--fg-muted);
  cursor:pointer;font-family:inherit;transition:color 0.15s,border-color 0.15s;margin:0;
}
.trade-side button:hover { color:var(--fg); }
.trade-side button.active { color:var(--fg);border-bottom-color:var(--fg); }
.trade-side button[data-side="yes"].active { color:var(--yes);border-bottom-color:var(--yes); }
.trade-side button[data-side="no"].active { color:var(--no);border-bottom-color:var(--no); }

.trade-section { margin-bottom:8px; }
.trade-section-head {
  display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;
}
.trade-section-head label {
  font-size:11px;font-weight:600;letter-spacing:0.05em;text-transform:uppercase;color:var(--fg-muted);margin:0;flex-shrink:0;
}
.trade-balance {
  font-size:11px;color:var(--fg-muted);cursor:pointer;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;
  flex:1;text-align:right;margin:0 8px;
}
.trade-balance:hover { color:var(--fg); }
.trade-section input {
  width:100%;padding:8px 0;font-size:22px;font-weight:400;font-family:inherit;
  border:none;border-bottom:1.5px solid var(--border);outline:none;background:transparent;color:var(--fg);
}
.trade-section input::placeholder { color:var(--fg-dim); }
.trade-section input:focus { border-bottom-width:2.5px;margin-bottom:-1px; }
.trade-quote { font-size:12px;color:var(--fg-muted);min-height:18px;margin-bottom:10px; }
.trade-pct-row { display:flex;gap:4px;margin-top:6px; }
.trade-pct-btn {
  flex:1;padding:3px 0;font-size:10px;font-weight:500;letter-spacing:0.04em;
  border:none;background:transparent;color:var(--fg-dim);
  cursor:pointer;font-family:inherit;transition:color 0.15s;
}
.trade-pct-btn:hover { color:var(--fg); }

/* Positions */
.pos-row { display:flex;justify-content:space-between;align-items:center;font-size:12px;padding:5px 0;border-bottom:none;gap:8px; }
.pos-row:last-child { border-bottom:none; }
.pos-side { font-weight:600;min-width:70px;flex-shrink:0; }
.pos-side.yes { color:var(--yes); }
.pos-side.no { color:var(--no); }
.pos-val { flex:1;text-align:right; }
.lp-withdraw-btn { padding:3px 8px;font-size:9px;font-weight:600;letter-spacing:0.5px;border:none;background:transparent;color:var(--fg-dim);cursor:pointer;flex-shrink:0;transition:color 0.15s; }
.lp-withdraw-btn:hover { color:var(--fg); }
.lp-withdraw-btn:disabled { opacity:0.3;cursor:not-allowed; }

/* Resolution */
.resolve-section { margin-top:16px; }
.resolve-toggle {
  display:flex;align-items:center;justify-content:space-between;
  padding:10px 0;border:none;border-top:1px solid var(--border-muted);
  cursor:pointer;font-size:10px;text-transform:uppercase;letter-spacing:1px;
  color:var(--fg-muted);transition:color 0.15s;
}
.resolve-toggle:hover { color:var(--fg); }
.resolve-toggle.expanded { color:var(--fg); }
.resolve-toggle-status { font-weight:bold; }
.resolve-toggle-status.pending { color:#F50; }
.resolve-toggle-status.ready { color:var(--yes); }
.resolve-toggle-status.resolved { color:#0FF; }
.resolve-details {
  display:none;padding:16px 0;border:none;
  background:transparent;
}
.resolve-details.expanded { display:block; }
.resolve-details.ready { background:transparent; }
.resolve-condition { font-size:13px;margin-bottom:16px;line-height:1.5; }
.resolve-condition-target { opacity:0.7;font-size:11px; }
.resolve-condition-val { font-weight:bold;color:#0FF; }
.resolve-condition-thresh { font-weight:bold;color:var(--yes); }
.resolve-progress { margin-bottom:16px;font-family:monospace; }
.resolve-progress-bar { font-size:14px;letter-spacing:1px;margin-bottom:4px;color:var(--fg); }
.resolve-progress-bar .filled { color:var(--yes); }
.resolve-progress-bar .empty { opacity:0.3; }
.resolve-progress-bar.met .filled { color:var(--yes); }
.resolve-progress-text { display:flex;justify-content:space-between;font-size:11px;opacity:0.7; }
.resolve-status {
  text-align:center;padding:12px;font-size:13px;
  background:var(--surface);margin-bottom:12px;
}
.resolve-btn {
  width:100%;padding:12px;font-size:13px;font-weight:600;
}
.resolve-btn:disabled { opacity:0.3;cursor:not-allowed; }
.resolve-hint { font-size:10px;opacity:0.5;margin-top:8px;text-align:center; }
.inspect-toggle {
  display:block;width:100%;margin-top:12px;padding:6px;background:none;border:none;
  color:inherit;font-size:10px;opacity:0.3;cursor:pointer;text-align:center;
}
.inspect-toggle:hover { opacity:0.6; }
.inspect-panel {
  display:none;margin-top:8px;padding:8px;
  background:var(--surface);border:1px solid var(--border-muted);
  font-size:10px;font-family:monospace;
}
.inspect-panel.expanded { display:block; }
.inspect-row { display:flex;justify-content:space-between;padding:4px 0;border-bottom:1px solid var(--border-muted); }
.inspect-row:last-child { border-bottom:none; }
.inspect-label { opacity:0.5; }
.inspect-value { word-break:break-all;text-align:right;max-width:70%;color:#0FF; }
.inspect-value a { color:#0FF;text-decoration:underline; }

/* Loading */
.loading { text-align:center;padding:40px;color:var(--fg-muted);font-size:13px; }
@keyframes spin { to { transform:rotate(360deg); } }
.spinner {
  display:inline-block;width:14px;height:14px;border:2px solid var(--border-muted);
  border-top:2px solid var(--fg);border-radius:50%;animation:spin 0.8s linear infinite;
  vertical-align:middle;margin-right:8px;
}
.progress-bar { height:6px;background:var(--border-muted);overflow:hidden;margin:8px 0; }
.progress-fill { height:100%;transition:width 0.3s; }

/* Modal */
.modal-overlay {
  display:none;position:fixed;inset:0;background:var(--modal-overlay);backdrop-filter:blur(4px);z-index:2000;
  justify-content:center;align-items:flex-start;padding:20px;padding-top:max(60px, env(safe-area-inset-top, 60px));
  overflow-y:auto;-webkit-overflow-scrolling:touch;
}
.modal-overlay.active { display:flex; }
body.modal-open { overflow:hidden; }
#createModal .modal, #lpModal .modal { max-width:480px; }
.modal {
  background:var(--modal-bg);border:1px solid var(--modal-border);
  width:100%;max-width:380px;padding:20px;position:relative;
  max-height:calc(100vh - 80px);max-height:calc(100dvh - 80px);
  display:flex;flex-direction:column;overflow:hidden;
}
.modal-header { display:flex;justify-content:space-between;align-items:center;margin-bottom:16px;flex-shrink:0; }
.modal-title { font-size:14px;font-weight:400;letter-spacing:0.1em;text-transform:uppercase; }
.modal-close {
  background:none;border:none;font-size:24px;color:var(--fg);cursor:pointer;line-height:1;
  padding:8px;margin:-8px;opacity:0.4;transition:opacity 0.15s;
}
.modal-close:hover { opacity:1; }
.modal-body { overflow-y:auto;-webkit-overflow-scrolling:touch; }
.pay-token-row { display:flex;gap:0;align-items:baseline; }
.pay-token-row input { flex:1;min-width:0; }
.pay-token-btn {
  background:none;border:none;color:var(--fg-muted);
  font-family:inherit;font-size:13px;padding:0 0 0 6px;cursor:pointer;white-space:nowrap;
  display:inline-flex;align-items:center;gap:3px;transition:color 0.15s;
  position:relative;top:-1px;
}
.pay-token-btn:hover { color:var(--fg); }
.pay-token-btn svg { position:relative;top:1px; }
.pay-token-list { list-style:none;padding:0;margin:0; }
.pay-token-list li {
  padding:10px 12px;cursor:pointer;font-size:13px;display:flex;align-items:center;gap:8px;
  border-bottom:1px solid var(--border-muted);transition:background 0.1s;
}
.pay-token-list li svg { flex-shrink:0; }
.pay-token-list li:last-child { border-bottom:none; }
.pay-token-list li:hover { background:var(--surface); }
.pay-token-list li.active { color:var(--green); }
.pay-token-list .tok-sym { font-weight:500; }
.pay-token-list .tok-note { font-size:11px;color:var(--fg-muted);margin-left:auto; }


.market-type-tabs { display:flex;gap:0;margin-bottom:20px; }
.market-type-tab {
  flex:1;padding:8px 4px;font-size:11px;font-weight:400;letter-spacing:0.1em;text-transform:uppercase;
  border:none;border-bottom:2px solid transparent;border-radius:0;
  background:transparent;color:var(--fg-muted);cursor:pointer;font-family:inherit;
  transition:color 0.15s,border-color 0.15s;
}
.market-type-tab:hover { color:var(--fg); }
.market-type-tab.active { color:var(--fg);border-bottom-color:var(--fg); }
.form-group { margin-bottom:16px; }
.form-label {
  display:block;font-size:11px;font-weight:400;letter-spacing:0.1em;text-transform:uppercase;
  color:var(--fg-muted);margin-bottom:6px;
}
.form-input {
  width:100%;padding:8px 0;font-size:16px;font-family:inherit;
  border:none;border-bottom:1.5px solid var(--border);outline:none;background:transparent;color:var(--fg);
}
.form-input:focus { border-bottom-width:2.5px;margin-bottom:-1px; }
.form-input::placeholder { color:var(--fg-dim); }
select.form-input { border-radius:0;-webkit-appearance:none;appearance:none;cursor:pointer; }
.form-preview {
  font-size:14px;font-weight:600;line-height:1.6;padding:12px 16px;
  background:var(--surface);margin-bottom:16px;text-align:center;
  border:1px solid var(--border-muted);border-left:3px solid var(--fg);
}
.form-hint { font-size:11px;color:var(--fg-dim);margin-top:4px; }
.form-hint.tab-hint { text-align:center;margin-bottom:16px;margin-top:0; }
.form-divider {
  font-size:11px;font-weight:400;letter-spacing:0.1em;text-transform:uppercase;
  color:var(--fg-muted);margin:20px 0 12px;padding-top:16px;border-top:1px solid var(--border-muted);
}
.form-divider.in-liq { border-top:none;margin:0 0 12px;padding-top:0; }
.liq-section {
  border:1px solid var(--border-muted);padding:16px;margin-top:20px;
}
.total-cost-display {
  font-size:12px;font-weight:600;color:var(--fg);text-align:center;margin:12px 0 4px;letter-spacing:0.02em;
}
#priceDirection button[data-dir="up"].active { color:var(--yes);border-bottom-color:var(--yes); }
#priceDirection button[data-dir="down"].active { color:var(--no);border-bottom-color:var(--no); }
.date-hint { font-size:11px;color:var(--fg-dim);margin-top:4px;display:block; }
.form-btn {
  width:100%;padding:14px;font-size:13px;font-weight:600;margin-top:12px;
  letter-spacing:0.02em;transition:all 0.2s;
}
.form-btn:hover:not(:disabled) { background:var(--btn-hover); }
.form-btn:disabled { background:var(--btn-dis-bg);border-color:var(--btn-dis-border);color:var(--btn-dis-fg);cursor:not-allowed; }
.liq-presets { display:flex;gap:6px;margin-bottom:10px; }
.liq-preset {
  flex:1;padding:6px 0;font-size:11px;font-weight:600;border:1px solid var(--border-muted);
  background:transparent;color:var(--fg-muted);cursor:pointer;font-family:inherit;
  transition:border-color 0.15s,color 0.15s,background 0.15s;
}
.liq-preset:hover { border-color:var(--fg);color:var(--fg); }
.liq-preset.active { border-color:var(--fg);color:var(--fg);background:var(--surface); }
.date-presets { display:flex;gap:4px;margin-top:6px; }
.date-preset {
  padding:4px 10px;font-size:10px;font-weight:600;border:1px solid var(--border-muted);
  background:transparent;color:var(--fg-muted);cursor:pointer;font-family:inherit;
  transition:border-color 0.15s,color 0.15s;
}
.date-preset:hover { border-color:var(--fg);color:var(--fg); }
.form-section { display:none; }
.form-section.active { display:block; }
.form-toggle-row { display:flex;align-items:center;gap:8px;margin-bottom:10px; }
.form-toggle-row label { font-size:11px;color:var(--fg-muted);cursor:pointer;user-select:none;margin:0;text-transform:none;letter-spacing:0; }
.form-toggle-row input[type="checkbox"] { accent-color:var(--fg);width:14px;height:14px; }
.balance-type-toggle { display:flex;gap:6px; }
.balance-type-btn {
  flex:1;padding:8px 0;font-size:11px;font-weight:600;letter-spacing:0.05em;
  border:1px solid var(--border-muted);background:transparent;color:var(--fg-muted);
  cursor:pointer;font-family:inherit;transition:border-color 0.15s,color 0.15s,background 0.15s;
}
.balance-type-btn.active { border-color:var(--fg);color:var(--fg);background:var(--surface); }
input[type="datetime-local"] { color-scheme:light; }
.dark input[type="datetime-local"] { color-scheme:dark; }

/* LP Modal extras */
.lp-alloc-row { display:flex;align-items:center;gap:8px;margin-bottom:4px; }
.lp-alloc-label { font-size:11px;font-weight:600;width:60px; }
.lp-alloc-label.yes { color:var(--yes); }
.lp-alloc-label.no { color:var(--no); }
.lp-alloc-label.amm { color:var(--fg-muted); }
.lp-alloc-slider { flex:1;accent-color:var(--fg); }
.lp-alloc-pct { font-size:11px;width:36px;text-align:right;color:var(--fg-muted); }
.lp-alloc-hint { font-size:10px;color:var(--fg-dim);margin:0 0 8px 68px; }

/* Odds chart drawer */
.market-chart-drawer {
  border-top:1px solid var(--border-muted);margin-bottom:0;overflow:hidden;
}
.market-chart-toggle-btn {
  display:flex;justify-content:space-between;align-items:center;width:100%;
  padding:10px 0;border:none;background:transparent;color:var(--fg-muted);cursor:pointer;
  font-family:inherit;font-size:10px;font-weight:600;letter-spacing:0.08em;text-transform:uppercase;
  transition:opacity 0.15s;
}
.market-chart-toggle-btn:hover { opacity:0.7; }
.market-chart-toggle-btn .arrow { transition:transform 0.2s;font-size:8px;opacity:0.4; }
.market-chart-drawer.open .market-chart-toggle-btn .arrow { transform:rotate(180deg); }
.market-chart {
  padding:0;
}
.market-chart-wrap {
  position:relative;width:100%;height:260px;
  background:var(--bg);overflow:hidden;
}
.market-chart-tabs {
  display:flex;gap:2px;padding:6px 0 4px;
}
.market-chart-tabs button {
  border:none;background:transparent;color:var(--fg-dim);
  font-family:inherit;font-size:10px;font-weight:600;padding:3px 8px;cursor:pointer;
  letter-spacing:0.03em;
}
.market-chart-tabs button:hover { color:var(--fg-muted); }
.market-chart-tabs button.active { color:var(--fg);border-bottom:1px solid var(--fg); }
.market-chart-wrap canvas {
  display:block;width:100%;height:100%;
}
.market-chart-empty {
  display:flex;align-items:center;justify-content:center;height:100%;
  font-size:12px;color:var(--fg-dim);
}
/* Pool activity drawer */
.pm-activity-table { width:100%;border-collapse:collapse;font-size:11px; }
.pm-activity-table th {
  text-align:left;padding:6px 10px;font-size:9px;font-weight:600;letter-spacing:0.06em;
  text-transform:uppercase;color:var(--fg-dim);border-bottom:none;
}
.pm-activity-table td { padding:4px 10px;border-bottom:none;white-space:nowrap;color:var(--fg-muted); }
.pm-activity-table tr:last-child td { border-bottom:none; }
.pm-activity-table .evt-buy-yes { color:var(--green); }
.pm-activity-table .evt-sell-yes { color:var(--red); }
.pm-activity-table .evt-buy-no { color:var(--red); }
.pm-activity-table .evt-sell-no { color:var(--green); }
.pm-activity-table .evt-liqadd { color:var(--green); }
.pm-activity-table .evt-liqrem { color:var(--red); }
.pm-activity-table .evt-type { font-weight:600;font-size:10px; }
.pm-activity-table a { color:var(--fg-muted);font-size:11px; }
.pm-activity-table a:hover { color:var(--fg); }
.pm-activity-more {
  display:block;width:100%;padding:8px;border:none;background:none;
  color:var(--fg-muted);font-size:11px;cursor:pointer;text-align:center;
}
.pm-activity-more:hover { color:var(--fg);background:var(--surface); }
.pm-activity-empty { padding:16px;text-align:center;font-size:12px;color:var(--fg-muted); }

/* Wallet */
.wallet {
  position:fixed;
  top:max(20px, env(safe-area-inset-top, 0px));
  right:max(20px, env(safe-area-inset-right, 0px));
  font-size:11px; text-transform:uppercase; letter-spacing:0.05em;
  z-index:100;
}
.wallet button { margin:0; padding:8px 16px; text-transform:none; }

/* Wallet options */
.wallet-option {
  display:flex;align-items:center;gap:12px;padding:14px 16px;
  background:var(--modal-bg);border:1px solid var(--border);color:var(--fg);
  cursor:pointer;margin-bottom:8px;transition:background 0.15s, color 0.15s;
}
.wallet-option:hover { background:var(--btn-bg); color:var(--btn-fg); }
.wallet-option:active { opacity:0.7; }
.wallet-option-icon { font-size:1.5rem; }
.wallet-option-name { font-weight:600;font-size:14px; }
.wallet-option.disconnect { border-color:#f00; color:#f00; justify-content:center;margin-top:4px; }
.wallet-option.disconnect:hover { background:#f00; color:#fff; }

/* Dark toggle */
.dark-toggle {
  position:fixed;bottom:max(20px, env(safe-area-inset-bottom, 0px));right:max(20px, env(safe-area-inset-right, 0px));
  border:none;cursor:pointer;padding:13px;margin:-13px;opacity:0.5;transition:opacity 0.2s;
  z-index:100;background:#000;border-radius:50%;width:40px;height:40px;background-clip:content-box;
}
:root.dark .dark-toggle { background:#fff; }
.dark-toggle:hover { opacity:1; }

.z-nav { position:fixed; top:max(16px, env(safe-area-inset-top)); left:max(16px, env(safe-area-inset-left)); z-index:200; }
.z-nav-btn { background:none; border:none; cursor:pointer; opacity:0.5; transition:opacity 0.2s; padding:6px; margin:-6px; line-height:0; }
.z-nav-btn:hover, .z-nav.open .z-nav-btn { opacity:1; }
.z-nav-menu { display:none; position:absolute; top:36px; left:0; background:var(--bg); border:1px solid var(--border); padding:8px 0; min-width:140px; max-height:calc(100vh - 60px); overflow-y:auto; }
.z-nav.open .z-nav-menu { display:block; }
.z-nav-menu a { display:block; padding:6px 16px; font-size:13px; color:var(--fg); text-decoration:none; letter-spacing:0.05em; }
.z-nav-menu a:hover { background:var(--surface); }
.z-nav-menu a.active { opacity:0.35; pointer-events:none; }
.z-nav-menu .z-nav-sep { border-top:1px solid var(--border); margin:6px 0; }

/* Mobile */
@media (max-width: 700px) {
  body { padding:80px 16px 20px; }
  .wallet { top:16px; right:16px; }
  .wallet button { padding:10px 14px; font-size:11px; }
  .header h1 { font-size:13px; }
  .market-card { padding:12px; }
  .market-search { font-size:14px; }
  .section-card { padding:12px; }
  .stat-row { font-size:12px; }
  .trade-section input { font-size:18px; }
  .trade-pct-btn { font-size:9px;padding:5px 0; }
  .odds-label span { font-size:20px; }
  .modal-overlay { padding:0;padding-top:0;align-items:flex-end; }
  .modal { max-width:100%;margin:0;border-left:none;border-right:none;border-bottom:none;max-height:85vh;max-height:85dvh;padding:16px;padding-bottom:max(16px, env(safe-area-inset-bottom)); }
  .wallet-option { padding:14px 16px; }
  .dark-toggle { bottom:16px;right:16px; }
  .z-nav { top:14px;left:14px; }
  .z-nav-btn { padding:4px;margin:-4px; }
  .z-nav-menu a { padding:10px 16px; }
  .market-type-tab { font-size:10px;padding:6px 2px; }
  .form-preview { font-size:12px;padding:10px 12px; }
  .form-group { margin-bottom:12px; }
}
@media (max-width: 380px) {
  body { padding:70px 12px 20px; }
  .section-card { padding:10px; }
  .market-type-tab { font-size:9px;letter-spacing:0.05em; }
  .form-input { font-size:16px; }
  .form-preview { font-size:11px;padding:8px 10px; }
  .stat-row { font-size:11px;flex-wrap:wrap;gap:2px; }
  .trade-section input { font-size:16px; }
  .trade-dir button { font-size:10px;padding:8px 0; }
  .trade-side button { font-size:10px;padding:8px 0; }
}
</style>
</head>
<body>
<div class="z-nav">
  <button class="z-nav-btn" onclick="this.parentElement.classList.toggle('open')" title="Menu">
    <svg width="28" height="28" viewBox="0 0 400 400" xmlns="http://www.w3.org/2000/svg"><rect class="zorg-bg" width="400" height="400"/><clipPath id="zh"><rect width="400" height="400"/></clipPath><g clip-path="url(#zh)"><path class="zorg-fg" d="M-60-20L460-20L460 90L80 310L460 310L460 420L-60 420L-60 310L320 90L-60 90Z"/></g></svg>
  </button>
  <div class="z-nav-menu">
    <a href="../">Swap</a>
    <a href="../coin/">Coin</a>
    <a href="./" class="active">Predict</a>
    <a id="navOrderbook" href="../orderbook/">Orderbook</a>
    <a href="../lp/">Liquidity</a>
    <a href="../domains/">Domain</a>
    <a href="../dao/">DAO</a>
    <div class="z-nav-sep"></div>
    <a href="../about/">About</a>
    <a href="https://github.com/z-fi/zFi" target="_blank" rel="noopener">GitHub</a>
  </div>
</div>
<button class="dark-toggle" onclick="toggleDark()" title="Toggle dark mode"></button>

<div class="wallet">
  <button id="walletBtn" onclick="toggleWallet()">connect</button>
</div>

<div class="modal-overlay" id="walletModal" onclick="if(event.target===this)closeWalletModal()">
  <div class="modal">
    <div class="modal-header">
      <div class="modal-title">Connect Wallet</div>
      <button class="modal-close" onclick="closeWalletModal()">&times;</button>
    </div>
    <div class="modal-body" id="walletOptions"></div>
  </div>
</div>

<div id="app"></div>

<!-- Create Market Modal -->
<div class="modal-overlay" id="createModal" onclick="if(event.target===this)closeCreateModal()">
  <div class="modal">
    <div class="modal-header">
      <div class="modal-title">Create Market</div>
      <button class="modal-close" onclick="closeCreateModal()">&times;</button>
    </div>
    <div class="market-type-tabs">
      <button class="market-type-tab active" onclick="switchMarketType('price')">Price</button>
      <button class="market-type-tab" onclick="switchMarketType('balance')">Balance</button>
      <button class="market-type-tab" onclick="switchMarketType('supply')">Supply</button>
      <button class="market-type-tab" onclick="switchMarketType('custom')">Question</button>
    </div>
    <div class="form-hint tab-hint" id="tabHint">Will an asset hit a target price?</div>

    <!-- PRICE FORM -->
    <div class="form-section active" id="priceForm">
      <div class="form-preview" id="pricePreview">Will ETH hit <b>$___</b> by <b>___</b>?</div>
      <div style="font-size:11px;color:var(--fg-muted);text-align:center;margin-bottom:10px">Current: ETH <b id="livePrice">...</b></div>
      <div class="form-group">
        <label class="form-label">Direction</label>
        <div class="trade-side" id="priceDirection">
          <button class="active" data-dir="up" onclick="setPriceDir('up')">Above</button>
          <button data-dir="down" onclick="setPriceDir('down')">Below</button>
        </div>
      </div>
      <div class="form-group">
        <label class="form-label">Target Price (USD)</label>
        <input class="form-input" id="targetPrice" type="text" inputmode="numeric" placeholder="e.g. 10000" oninput="fmtTargetPrice();updatePricePreview();updateCreateBtn()">
        <div class="date-presets" id="pricePresets">
          <button type="button" class="date-preset" onclick="setPricePreset(0)">current</button>
          <button type="button" class="date-preset" onclick="setPricePreset(5)">+5%</button>
          <button type="button" class="date-preset" onclick="setPricePreset(10)">+10%</button>
          <button type="button" class="date-preset" onclick="setPricePreset(100)">+100%</button>
        </div>
      </div>
      <div class="form-group">
        <label class="form-label">Resolution Date</label>
        <input class="form-input" id="closeDate" type="datetime-local" oninput="updatePricePreview();updateDateHint('closeDate');updateCreateBtn()">
        <span class="date-hint" id="closeDateHint"></span>
        <div class="date-presets">
          <button type="button" class="date-preset" onclick="setDatePreset(7,'closeDate')">1w</button>
          <button type="button" class="date-preset" onclick="setDatePreset(30,'closeDate')">1m</button>
          <button type="button" class="date-preset" onclick="setDatePreset(90,'closeDate')">3m</button>
          <button type="button" class="date-preset" onclick="setDatePreset(365,'closeDate')">1y</button>
        </div>
      </div>
    </div>

    <!-- BALANCE FORM -->
    <div class="form-section" id="balanceForm">
      <div class="form-preview" id="balancePreview">Will <b>address</b> hold &ge; <b>___</b> by <b>___</b>?</div>

      <div class="form-group">
        <label class="form-label">Asset Type</label>
        <div class="balance-type-toggle">
          <button type="button" class="balance-type-btn active" onclick="setBalanceType('eth')">ETH</button>
          <button type="button" class="balance-type-btn" onclick="setBalanceType('token')">Token</button>
        </div>
      </div>
      <div class="form-group">
        <label class="form-label">Direction</label>
        <div class="trade-side" id="balanceDirection">
          <button class="active" data-dir="above" onclick="setBalanceDir('above')">Above</button>
          <button data-dir="below" onclick="setBalanceDir('below')">Below</button>
        </div>
      </div>
      <div class="form-group" id="balTokenGroup" style="display:none">
        <label class="form-label">Token Contract</label>
        <input class="form-input" id="balTokenAddr" type="text" placeholder="0x... (ERC20)" oninput="loadBalTokenInfo()">
        <div class="form-hint" id="balTokenHint"></div>
      </div>
      <div class="form-group">
        <label class="form-label">Wallet Address</label>
        <input class="form-input" id="balWalletAddr" type="text" placeholder="0x address, name.wei, or name.eth" oninput="onBalWalletInput()">
        <div id="balWalletResolved" style="display:none;font-size:12px;margin-top:4px;color:var(--fg-muted);word-break:break-all"></div>
      </div>
      <div class="form-group">
        <label class="form-label">Threshold</label>
        <input class="form-input" id="balThreshold" type="number" placeholder="e.g. 100" step="any" min="0" oninput="updateBalPreview();updateCreateBtn()">
      </div>
      <div class="form-group">
        <label class="form-label">Resolution Date</label>
        <input class="form-input" id="balCloseDate" type="datetime-local" oninput="updateBalPreview();updateDateHint('balCloseDate');updateCreateBtn()">
        <span class="date-hint" id="balCloseDateHint"></span>
        <div class="date-presets">
          <button type="button" class="date-preset" onclick="setDatePreset(7,'balCloseDate')">1w</button>
          <button type="button" class="date-preset" onclick="setDatePreset(30,'balCloseDate')">1m</button>
          <button type="button" class="date-preset" onclick="setDatePreset(90,'balCloseDate')">3m</button>
          <button type="button" class="date-preset" onclick="setDatePreset(365,'balCloseDate')">1y</button>
        </div>
      </div>
    </div>

    <!-- SUPPLY FORM -->
    <div class="form-section" id="supplyForm">
      <div class="form-preview" id="supplyPreview">Will <b>token</b> supply reach <b>___</b> by <b>___</b>?</div>
      <div class="form-group">
        <label class="form-label">Token Contract</label>
        <input class="form-input" id="supplyTokenAddr" type="text" placeholder="0x... (ERC20)" oninput="loadSupplyTokenInfo();updateCreateBtn()">
        <div class="form-hint" id="supplyTokenHint"></div>
      </div>
      <div class="form-group">
        <label class="form-label">Condition</label>
        <select class="form-input" id="supplyOp" onchange="updateSupplyPreview()">
          <option value="3">Greater than or equal (&ge;)</option>
          <option value="2">Less than or equal (&le;)</option>
        </select>
      </div>
      <div class="form-group">
        <label class="form-label">Threshold</label>
        <input class="form-input" id="supplyThreshold" type="number" placeholder="e.g. 1000000" step="any" min="0" oninput="updateSupplyPreview();updateCreateBtn()">
      </div>
      <div class="form-group">
        <label class="form-label">Resolution Date</label>
        <input class="form-input" id="supplyCloseDate" type="datetime-local" oninput="updateSupplyPreview();updateDateHint('supplyCloseDate');updateCreateBtn()">
        <span class="date-hint" id="supplyCloseDateHint"></span>
        <div class="date-presets">
          <button type="button" class="date-preset" onclick="setDatePreset(7,'supplyCloseDate')">1w</button>
          <button type="button" class="date-preset" onclick="setDatePreset(30,'supplyCloseDate')">1m</button>
          <button type="button" class="date-preset" onclick="setDatePreset(90,'supplyCloseDate')">3m</button>
          <button type="button" class="date-preset" onclick="setDatePreset(365,'supplyCloseDate')">1y</button>
        </div>
      </div>
    </div>

    <!-- CUSTOM FORM -->
    <div class="form-section" id="customForm">
      <div class="form-preview" id="customPreview">Yes/No market with your own question and resolver</div>
      <div class="form-group">
        <label class="form-label">Question</label>
        <input class="form-input" id="customQuestion" type="text" placeholder="Will X happen by Y?" oninput="updateCustomPreview();updateCreateBtn()">
      </div>
      <div class="form-group">
        <label class="form-label">Resolver Address</label>
        <input class="form-input" id="customResolver" type="text" placeholder="0x address, name.wei, or name.eth" oninput="updateCreateDeeplink();updateCreateBtn()">
        <div id="customResolverResolved" style="display:none;font-size:12px;margin-top:4px;color:var(--fg-muted);word-break:break-all"></div>
        <div class="form-hint">The address that will be able to resolve this market as YES or NO</div>
        <div id="resolverFeeSection" style="display:none;margin-top:8px">
          <a href="#" style="font-size:12px;color:var(--fg-muted)" onclick="event.preventDefault();const b=this.nextElementSibling;b.style.display=b.style.display==='none'?'block':'none'">Set your resolver fee</a>
          <div style="display:none;margin-top:6px">
            <div id="resolverFeeCurrentLabel" style="font-size:11px;color:var(--fg-dim);margin-bottom:4px"></div>
            <div style="display:flex;align-items:center;gap:8px">
              <input class="form-input" id="resolverFeeInput" type="number" min="0" max="10" step="0.01" placeholder="0.00" style="width:80px;padding:6px 8px;font-size:13px" oninput="if(this.value>10)this.value=10">
              <span style="font-size:12px;color:var(--fg-muted)">%</span>
              <button class="btn" style="font-size:12px;padding:6px 12px;white-space:nowrap" onclick="submitResolverFee()">Set Fee</button>
            </div>
          </div>
        </div>
      </div>
      <div class="form-toggle-row">
        <input type="checkbox" id="customCanClose" checked onchange="updateCreateDeeplink()">
        <label for="customCanClose">Can close early (resolver can resolve before close date)</label>
      </div>
      <div class="form-group">
        <label class="form-label">Resolution Date</label>
        <input class="form-input" id="customCloseDate" type="datetime-local" oninput="updateCustomPreview();updateDateHint('customCloseDate');updateCreateBtn()">
        <span class="date-hint" id="customCloseDateHint"></span>
        <div class="date-presets">
          <button type="button" class="date-preset" onclick="setDatePreset(7,'customCloseDate')">1w</button>
          <button type="button" class="date-preset" onclick="setDatePreset(30,'customCloseDate')">1m</button>
          <button type="button" class="date-preset" onclick="setDatePreset(90,'customCloseDate')">3m</button>
          <button type="button" class="date-preset" onclick="setDatePreset(365,'customCloseDate')">1y</button>
        </div>
      </div>
    </div>

    <!-- SEED LIQUIDITY -->
    <div class="liq-section">
      <div class="form-label" style="margin-bottom:12px">Seed Liquidity (ETH)</div>
      <div class="liq-presets">
        <button type="button" class="liq-preset active" onclick="setLiqPreset(0.01)">0.01</button>
        <button type="button" class="liq-preset" onclick="setLiqPreset(0.1)">0.1</button>
        <button type="button" class="liq-preset" onclick="setLiqPreset(0.5)">0.5</button>
        <button type="button" class="liq-preset" onclick="setLiqPreset(1)">1.0</button>
      </div>
      <input class="form-input" id="totalLiquidity" type="number" placeholder="0.01" step="0.001" min="0.001" value="0.01" oninput="updateLiqSplit()" style="margin-bottom:10px">
      <div class="total-cost-display" id="totalCostDisplay">Total: 0.01 ETH</div>
      <button class="form-btn" id="createBtn" onclick="createMarket()" disabled>Enter target price</button>
    </div>
  </div>
</div>

<!-- LP Modal -->
<div class="modal-overlay" id="lpModal" onclick="if(event.target===this)closeLPModal()">
  <div class="modal">
    <div class="modal-header">
      <div class="modal-title">Provide Liquidity</div>
      <button class="modal-close" onclick="closeLPModal()">&times;</button>
    </div>
    <div class="form-preview" id="lpMarketName">...</div>
    <div class="form-group">
      <label class="form-label" id="lpAmountLabel">Amount (ETH)</label>
      <input class="form-input" id="lpAmount" type="number" placeholder="0.1" step="0.01" min="0.001">
    </div>
    <div style="margin:12px 0;padding:10px;font-size:12px;color:var(--fg-muted);background:var(--surface);text-align:center">
      Splits collateral into YES + NO shares and adds to AMM pool. You earn swap fees from trades.
    </div>
    <button class="form-btn" id="lpBtn" onclick="provideLiquidity()">Provide Liquidity</button>
  </div>
</div>


<!-- Pay Token Modal -->
<div class="modal-overlay" id="payTokenModal" onclick="if(event.target===this)closePayTokenModal()">
  <div class="modal" style="max-width:340px">
    <div class="modal-header">
      <div class="modal-title">Pay With</div>
      <button class="modal-close" onclick="closePayTokenModal()">&times;</button>
    </div>
    <div class="modal-body">
      <input type="text" id="payTokenSearch" class="form-input" placeholder="Search tokens..." oninput="renderPayTokenList()" style="margin-bottom:8px;font-size:13px;padding:8px 10px">
      <ul class="pay-token-list" id="payTokenList"></ul>
      <div style="border-top:1px solid var(--border-muted);padding-top:10px;margin-top:8px;display:flex;gap:8px;align-items:center">
        <input type="text" id="payTokenCustomAddr" class="form-input" placeholder="Paste token address" style="margin:0;flex:1;font-size:12px;padding:6px 8px">
        <button style="white-space:nowrap;font-size:12px;padding:6px 12px;background:var(--surface);border:1px solid var(--border-muted);color:var(--fg);cursor:pointer;font-family:inherit" onclick="addPredictCustomToken()">Add</button>
      </div>
      <div id="payTokenCustomStatus" style="font-size:11px;color:var(--fg-muted);margin-top:4px;min-height:16px"></div>
    </div>
  </div>
</div>

<script src="../ethers.min.js"></script>
<script src="../walletconnect.min.js"></script>
<script>
document.addEventListener('click', e => { if (!e.target.closest('.z-nav')) document.querySelector('.z-nav')?.classList.remove('open'); });
function toggleDark() {
  const on = document.documentElement.classList.toggle('dark');
  localStorage.setItem('dark', on ? '1' : '0');
  // Redraw odds chart with new theme colors
  const chart = document.getElementById('marketChart');
  if (chart) {
    const canvas = chart.querySelector('canvas');
    if (canvas && canvas._oddsPoints) drawOddsChart(canvas, canvas._oddsPoints);
  }
}
// ==================== CHART ====================

const FLAG_BEFORE = 1n << 255n;
const FLAG_AFTER = 1n << 254n;

function computePredictionPoolId(marketId, isLabeled) {
  const yesId = BigInt(marketId);
  const noId = BigInt(ethers.keccak256(ethers.solidityPacked(['string', 'uint256'], ['PMARKET:NO', yesId])));
  const yesIsToken0 = yesId < noId;
  const [id0, id1] = yesIsToken0 ? [yesId, noId] : [noId, yesId];
  const feeOrHook = isLabeled
    ? BigInt(CONTRACTS.PM_FEE_HOOK) | FLAG_BEFORE | FLAG_AFTER
    : BigInt(LEGACY_FEE_BPS);
  const toBytes32 = v => { let h = BigInt(v).toString(16); if (h.length > 64) h = h.slice(-64); return h.padStart(64, '0'); };
  const addrBytes32 = a => a.slice(2).toLowerCase().padStart(64, '0');
  const encoded = '0x' + toBytes32(id0) + toBytes32(id1) + addrBytes32(CONTRACTS.PAMM) + addrBytes32(CONTRACTS.PAMM) + toBytes32(feeOrHook);
  return { poolId: BigInt(ethers.keccak256(encoded)).toString(), yesIsToken0 };
}

const INDEXER = 'https://coinchan-indexer-production.up.railway.app';

async function fetchAllEvents(poolId) {
  const all = [];
  let cursor = null;
  for (let i = 0; i < 20; i++) {
    let url = INDEXER + '/api/events?poolId=' + poolId + '&limit=100';
    if (cursor) url += '&cursor=' + cursor;
    const res = await fetch(url);
    const json = await res.json();
    if (!json.data || !json.data.length) break;
    all.push(...json.data);
    if (!json.nextCursor) break;
    cursor = json.nextCursor;
  }
  return all.reverse(); // chronological order
}

// roundRect polyfill for older browsers
if (!CanvasRenderingContext2D.prototype.roundRect) {
  CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
    if (typeof r === 'number') r = [r, r, r, r];
    const [tl, tr, br, bl] = r;
    this.moveTo(x + tl, y);
    this.lineTo(x + w - tr, y); this.arcTo(x + w, y, x + w, y + tr, tr);
    this.lineTo(x + w, y + h - br); this.arcTo(x + w, y + h, x + w - br, y + h, br);
    this.lineTo(x + bl, y + h); this.arcTo(x, y + h, x, y + h - bl, bl);
    this.lineTo(x, y + tl); this.arcTo(x, y, x + tl, y, tl);
    this.closePath();
  };
}

function _chartTooltip(canvas, e) {
  const rect = canvas.getBoundingClientRect();
  canvas._tooltip = { cx: e.clientX - rect.left, cy: e.clientY - rect.top };
  drawOddsChart(canvas, canvas._oddsPoints);
}

function _monotoneCurve(ctx, pts) {
  // Attempt monotone cubic spline through pts [{x,y}]
  const n = pts.length;
  if (n < 2) return;
  ctx.moveTo(pts[0].x, pts[0].y);
  if (n === 2) { ctx.lineTo(pts[1].x, pts[1].y); return; }
  // Compute tangents (Fritsch-Carlson monotone)
  const dx = [], dy = [], m = [], d = [];
  for (let i = 0; i < n - 1; i++) {
    dx[i] = pts[i+1].x - pts[i].x;
    dy[i] = pts[i+1].y - pts[i].y;
    d[i] = dx[i] === 0 ? 0 : dy[i] / dx[i];
  }
  m[0] = d[0];
  for (let i = 1; i < n - 1; i++) {
    if (d[i-1] * d[i] <= 0) m[i] = 0;
    else m[i] = (d[i-1] + d[i]) / 2;
  }
  m[n-1] = d[n-2];
  // Monotonicity constraints
  for (let i = 0; i < n - 1; i++) {
    if (Math.abs(d[i]) < 1e-10) { m[i] = 0; m[i+1] = 0; continue; }
    const a = m[i] / d[i], b = m[i+1] / d[i];
    const s = a * a + b * b;
    if (s > 9) { const t = 3 / Math.sqrt(s); m[i] = t * a * d[i]; m[i+1] = t * b * d[i]; }
  }
  for (let i = 0; i < n - 1; i++) {
    const c1x = pts[i].x + dx[i] / 3;
    const c1y = pts[i].y + m[i] * dx[i] / 3;
    const c2x = pts[i+1].x - dx[i] / 3;
    const c2y = pts[i+1].y - m[i+1] * dx[i] / 3;
    ctx.bezierCurveTo(c1x, c1y, c2x, c2y, pts[i+1].x, pts[i+1].y);
  }
}

function drawOddsChart(canvas, points) {
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;
  const ctx = canvas.getContext('2d');
  ctx.scale(dpr, dpr);
  const W = rect.width, H = rect.height;
  const pad = { top: 20, right: 64, bottom: 26, left: 36 };
  const cW = W - pad.left - pad.right;
  const cH = H - pad.top - pad.bottom;

  const cs = getComputedStyle(document.documentElement);
  const yesColor = cs.getPropertyValue('--yes').trim() || '#22c55e';
  const noColor = cs.getPropertyValue('--no').trim() || '#ef4444';
  const fgMuted = cs.getPropertyValue('--fg-muted').trim() || '#666';
  const fgDim = cs.getPropertyValue('--fg-dim').trim() || '#999';
  const borderColor = cs.getPropertyValue('--border-muted').trim() || '#eee';
  const bgColor = cs.getPropertyValue('--bg').trim() || '#fff';

  const yOf = pct => pad.top + cH - (pct / 100) * cH;

  // Horizontal gridlines
  ctx.strokeStyle = borderColor;
  ctx.lineWidth = 0.5;
  ctx.fillStyle = fgDim;
  ctx.font = '9px Helvetica, Arial, sans-serif';
  ctx.textAlign = 'right';
  for (let p = 0; p <= 100; p += 25) {
    const y = yOf(p);
    ctx.beginPath();
    ctx.moveTo(pad.left, y);
    ctx.lineTo(W - pad.right, y);
    ctx.stroke();
    if (p === 50) continue; // drawn separately below
    // Show as leading-side probability: above 50 = Yes %, below 50 = No %
    const label = p > 50 ? p + '%' : (100 - p) + '%';
    ctx.fillText(label, pad.left - 5, y + 3);
  }

  // 50% center line (emphasized) with label
  ctx.save();
  ctx.strokeStyle = fgDim;
  ctx.lineWidth = 0.7;
  ctx.setLineDash([3, 3]);
  ctx.beginPath();
  ctx.moveTo(pad.left, yOf(50));
  ctx.lineTo(W - pad.right, yOf(50));
  ctx.stroke();
  ctx.restore();
  ctx.fillStyle = fgDim;
  ctx.font = '9px Helvetica, Arial, sans-serif';
  ctx.textAlign = 'right';
  ctx.fillText('50%', pad.left - 5, yOf(50) + 3);

  // Single data point
  if (points.length < 2) {
    if (points.length === 1) {
      const yVal = points[0].yesPct;
      const cx = pad.left + cW / 2;
      const cy = yOf(yVal);
      const _dotColor = yVal >= 50 ? yesColor : noColor;
      const glow = ctx.createRadialGradient(cx, cy, 0, cx, cy, 20);
      glow.addColorStop(0, _dotColor + '40');
      glow.addColorStop(1, _dotColor + '00');
      ctx.fillStyle = glow;
      ctx.fillRect(cx - 20, cy - 20, 40, 40);
      ctx.beginPath(); ctx.arc(cx, cy, 4, 0, Math.PI * 2);
      ctx.fillStyle = _dotColor; ctx.fill();
      ctx.strokeStyle = bgColor; ctx.lineWidth = 1.5; ctx.stroke();
      const _lPct = Math.max(Math.round(yVal), Math.round(100 - yVal));
      const _lYes = Math.round(yVal) >= 50;
      ctx.font = 'bold 11px Helvetica, Arial, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillStyle = _lYes ? yesColor : noColor;
      ctx.fillText(_lPct + '% ' + (_lYes ? 'Yes' : 'No'), cx, cy - 12);
    }
    return;
  }

  // Time range
  const tMin = points[0].t, tMax = points[points.length - 1].t;
  const tRange = tMax - tMin || 1;
  const xOf = t => pad.left + ((t - tMin) / tRange) * cW;

  // Build curve points
  const curvePoints = points.map(p => ({ x: xOf(p.t), y: yOf(p.yesPct) }));
  // Extend to right edge
  curvePoints.push({ x: W - pad.right, y: yOf(points[points.length - 1].yesPct) });
  const useSmooth = points.length > 3;

  // Helper to trace curve path (line or smooth)
  const traceCurve = () => {
    if (useSmooth) {
      _monotoneCurve(ctx, curvePoints);
    } else {
      ctx.moveTo(curvePoints[0].x, curvePoints[0].y);
      for (let i = 1; i < curvePoints.length; i++) ctx.lineTo(curvePoints[i].x, curvePoints[i].y);
    }
  };

  // Gradient fill  green glow below line when YES leads, red glow above when NO leads
  const midY = yOf(50);
  const lastPct = points[points.length - 1].yesPct;
  const lastLeadColor = lastPct >= 50 ? yesColor : noColor;

  // Fill from line down to bottom (YES/green territory)
  const fillGrad = ctx.createLinearGradient(0, midY, 0, pad.top + cH);
  fillGrad.addColorStop(0, yesColor + '00');
  fillGrad.addColorStop(0.3, yesColor + '20');
  fillGrad.addColorStop(1, yesColor + '00');
  ctx.beginPath();
  traceCurve();
  ctx.lineTo(W - pad.right, pad.top + cH);
  ctx.lineTo(curvePoints[0].x, pad.top + cH);
  ctx.closePath();
  ctx.fillStyle = fillGrad;
  ctx.fill();

  // Fill from line up to top (NO/red territory)
  const fillGrad2 = ctx.createLinearGradient(0, pad.top, 0, midY);
  fillGrad2.addColorStop(0, noColor + '00');
  fillGrad2.addColorStop(0.7, noColor + '20');
  fillGrad2.addColorStop(1, noColor + '00');
  ctx.beginPath();
  traceCurve();
  ctx.lineTo(W - pad.right, pad.top);
  ctx.lineTo(curvePoints[0].x, pad.top);
  ctx.closePath();
  ctx.fillStyle = fillGrad2;
  ctx.fill();

  // Main curve line  color reflects current leading side
  ctx.beginPath();
  traceCurve();
  ctx.strokeStyle = lastLeadColor;
  ctx.lineWidth = 2;
  ctx.lineJoin = 'round';
  ctx.lineCap = 'round';
  ctx.stroke();

  // Data point dots (skip if too many)  colored by side at that point
  if (points.length <= 40) {
    for (const p of points) {
      const px = xOf(p.t), py = yOf(p.yesPct);
      ctx.beginPath(); ctx.arc(px, py, 2.5, 0, Math.PI * 2);
      ctx.fillStyle = p.yesPct >= 50 ? yesColor : noColor; ctx.fill();
    }
  }

  // Current price indicator  single leading-side pill on right edge
  const last = points[points.length - 1];
  const lastY = yOf(last.yesPct);
  const yesPctR = Math.round(last.yesPct);
  const noPctR = 100 - yesPctR;
  const leadIsYes = yesPctR >= noPctR;
  const leadPct = Math.max(yesPctR, noPctR);
  const leadLabel = leadPct + '% ' + (leadIsYes ? 'Yes' : 'No');
  const leadColor = leadIsYes ? yesColor : noColor;

  // Dashed line to right edge
  ctx.save();
  ctx.setLineDash([2, 2]);
  ctx.strokeStyle = leadColor + '60';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(xOf(last.t), lastY);
  ctx.lineTo(W - pad.right, lastY);
  ctx.stroke();
  ctx.restore();

  // Single pill
  const pillW = 54, pillH = 18, pillR = 4;
  const pillX = W - pad.right + 4;
  const pillY = Math.max(pad.top, Math.min(lastY - pillH / 2, H - pad.bottom - pillH));
  ctx.fillStyle = leadColor;
  ctx.beginPath(); ctx.roundRect(pillX, pillY, pillW, pillH, pillR); ctx.fill();
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 11px Helvetica, Arial, sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText(leadLabel, pillX + pillW / 2, pillY + pillH / 2 + 4);

  // X axis dates  smarter formatting
  ctx.fillStyle = fgDim;
  ctx.font = '9px Helvetica, Arial, sans-serif';
  const fmtDate = t => { const d = new Date(t * 1000); return (d.getMonth()+1) + '/' + d.getDate(); };
  const fmtTime = t => { const d = new Date(t * 1000); return d.getHours() + ':' + String(d.getMinutes()).padStart(2, '0'); };
  const span = tMax - tMin;
  const fmt = span < 86400 ? fmtTime : span < 86400 * 30 ? t => fmtDate(t) + ' ' + fmtTime(t) : fmtDate;
  const numLabels = Math.min(Math.floor(cW / 70), 5);
  for (let i = 0; i <= numLabels; i++) {
    const t = tMin + (tRange * i) / numLabels;
    const lx = xOf(t);
    ctx.textAlign = i === 0 ? 'left' : i === numLabels ? 'right' : 'center';
    ctx.fillText(fmt(t), lx, H - 6);
  }

  // Hover crosshair tooltip
  const tip = canvas._tooltip;
  if (tip && tip.cx >= pad.left && tip.cx <= W - pad.right) {
    // Find nearest point via linear scan (fast enough for typical data)
    const hoverT = tMin + ((tip.cx - pad.left) / cW) * tRange;
    let nearest = points[0], minDist = Math.abs(points[0].t - hoverT);
    for (let i = 1; i < points.length; i++) {
      const dist = Math.abs(points[i].t - hoverT);
      if (dist < minDist) { minDist = dist; nearest = points[i]; }
    }
    const nx = xOf(nearest.t), ny = yOf(nearest.yesPct);

    // Vertical crosshair
    ctx.save();
    ctx.setLineDash([4, 3]);
    ctx.strokeStyle = fgMuted + '80';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(nx, pad.top);
    ctx.lineTo(nx, pad.top + cH);
    ctx.stroke();
    ctx.restore();

    // Dot on curve  colored by side
    const dotColor = nearest.yesPct >= 50 ? yesColor : noColor;
    ctx.beginPath(); ctx.arc(nx, ny, 4, 0, Math.PI * 2);
    ctx.fillStyle = dotColor; ctx.fill();
    ctx.strokeStyle = bgColor; ctx.lineWidth = 2; ctx.stroke();

    // Tooltip box  single leading probability
    const tipYesPct = Math.round(nearest.yesPct);
    const tipLeadIsYes = tipYesPct >= 50;
    const tipLeadPct = tipLeadIsYes ? tipYesPct : 100 - tipYesPct;
    const tipColor = tipLeadIsYes ? yesColor : noColor;
    const d = new Date(nearest.t * 1000);
    const timeStr = (d.getMonth()+1) + '/' + d.getDate() + ' ' + d.getHours() + ':' + String(d.getMinutes()).padStart(2, '0');
    const line1 = timeStr;
    const line2 = tipLeadPct + '% ' + (tipLeadIsYes ? 'Yes' : 'No');
    ctx.font = 'bold 11px Helvetica, Arial, sans-serif';
    const tw = Math.max(ctx.measureText(line1).width, ctx.measureText(line2).width) + 16;
    const th = 34;
    let tx = nx + 10, ty = ny - th - 8;
    if (tx + tw > W - pad.right) tx = nx - tw - 10;
    if (ty < pad.top) ty = ny + 10;
    ctx.fillStyle = bgColor + 'e0';
    ctx.strokeStyle = borderColor;
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.roundRect(tx, ty, tw, th, 4); ctx.fill(); ctx.stroke();
    ctx.fillStyle = fgDim;
    ctx.font = '9px Helvetica, Arial, sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText(line1, tx + 8, ty + 13);
    ctx.fillStyle = tipColor;
    ctx.font = 'bold 11px Helvetica, Arial, sans-serif';
    ctx.fillText(line2, tx + 8, ty + 27);
  }
}

function toggleDrawer(id) {
  const drawer = document.getElementById(id);
  if (!drawer) return;
  drawer.classList.toggle('open');
  const body = drawer.querySelector('.drawer-body');
  if (body) body.style.display = drawer.classList.contains('open') ? '' : 'none';
}

var _chartLoaded = false;
var _chartEventsCache = null;
function toggleMarketChart() {
  const drawer = document.getElementById('marketChartDrawer');
  if (!drawer) return;
  drawer.classList.toggle('open');
  const chart = document.getElementById('marketChart');
  if (!chart) return;
  const isOpen = drawer.classList.contains('open');
  chart.style.display = isOpen ? '' : 'none';
  if (isOpen && !_chartLoaded) {
    _chartLoaded = true;
    const poolId = chart.dataset.poolId;
    const yesIsToken0 = chart.dataset.yesIsToken0 === '1';
    loadMarketChart(poolId, yesIsToken0);
  } else if (isOpen) {
    const canvas = chart.querySelector('canvas');
    if (canvas && canvas._oddsPoints) drawOddsChart(canvas, canvas._oddsPoints);
  }
}

function loadMarketChart(poolId, yesIsToken0) {
  const el = document.getElementById('marketChart');
  if (!el) return;
  el.dataset.poolId = poolId;
  el.innerHTML = `<div class="market-chart-wrap"><div class="market-chart-empty">Loading chart...</div></div>`;

  const cached = _chartEventsCache;
  _chartEventsCache = null;
  (cached ? Promise.resolve(cached) : fetchAllEvents(poolId)).then(events => {
    const cur = document.getElementById('marketChart');
    if (!cur || cur.dataset.poolId !== poolId) return;
    // No swap events  no trading activity  hide entire drawer
    const hasSwaps = events.some(ev => ev.category === 'SWAP');
    if (!hasSwaps) {
      cur.innerHTML = '';
      const drawer = document.getElementById('marketChartDrawer');
      if (drawer) drawer.style.display = 'none';
      return;
    }

    // Reconstruct reserves from all events, but only plot swap points
    let r0 = 0, r1 = 0;
    const allPoints = [];
    for (const ev of events) {
      const a0in = Number(ev.amount0_in || 0);
      const a1in = Number(ev.amount1_in || 0);
      const a0out = Number(ev.amount0_out || 0);
      const a1out = Number(ev.amount1_out || 0);
      r0 += a0in - a0out;
      r1 += a1in - a1out;
      if (r0 + r1 <= 0) continue;
      // Only plot swaps  LP adds/removes shift reserves but aren't price actions
      if (ev.category !== 'SWAP') continue;
      // YES price = noReserve / total (CPMM formula)
      const yesPct = yesIsToken0
        ? (r1 / (r0 + r1)) * 100
        : (r0 / (r0 + r1)) * 100;
      allPoints.push({ t: Number(ev.timestamp), yesPct });
    }

    if (!allPoints.length) { cur.innerHTML = ''; return; }

    // Build tabs + chart container
    cur.innerHTML = `<div class="market-chart-tabs" id="chartTabs">
      <button data-range="1">1D</button><button data-range="7" class="active">7D</button>
      <button data-range="30">1M</button><button data-range="0">ALL</button>
    </div><div class="market-chart-wrap"><canvas></canvas></div>`;
    const canvas = cur.querySelector('canvas');
    canvas._allPoints = allPoints;

    function filterPoints(rangeDays) {
      if (rangeDays === 0) return allPoints.slice(); // ALL
      const now = Math.floor(Date.now() / 1000);
      const cutoff = now - rangeDays * 86400;
      let pts = allPoints.filter(p => p.t >= cutoff);
      if (!pts.length) {
        const lastT = allPoints[allPoints.length - 1].t;
        pts = allPoints.filter(p => p.t >= lastT - rangeDays * 86400);
      }
      // Prepend carry-forward point
      if (pts.length && pts[0] !== allPoints[0]) {
        const idx = allPoints.indexOf(pts[0]);
        if (idx > 0) pts = [{ t: pts[0].t, yesPct: allPoints[idx - 1].yesPct }, ...pts];
      }
      return pts;
    }

    function setRange(rangeDays) {
      const pts = filterPoints(rangeDays);
      canvas._oddsPoints = pts;
      canvas._tooltip = null;
      drawOddsChart(canvas, pts);
      cur.querySelectorAll('.market-chart-tabs button').forEach(b => {
        b.classList.toggle('active', Number(b.dataset.range) === rangeDays);
      });
    }
    cur.querySelector('.market-chart-tabs').addEventListener('click', e => {
      const btn = e.target.closest('button[data-range]');
      if (btn) setRange(Number(btn.dataset.range));
    });

    setRange(7); // default 7D

    // Hover/touch crosshair
    canvas.addEventListener('mousemove', e => { _chartTooltip(canvas, e); });
    canvas.addEventListener('mouseleave', () => { canvas._tooltip = null; drawOddsChart(canvas, canvas._oddsPoints); });
    canvas.addEventListener('touchmove', e => { e.preventDefault(); _chartTooltip(canvas, e.touches[0]); }, { passive: false });
    canvas.addEventListener('touchend', () => { canvas._tooltip = null; drawOddsChart(canvas, canvas._oddsPoints); });

    // Redraw on resize
    const ro = new ResizeObserver(() => drawOddsChart(canvas, canvas._oddsPoints));
    ro.observe(canvas.parentElement);
  }).catch(() => {
    const cur = document.getElementById('marketChart');
    if (cur && cur.dataset.poolId === poolId) cur.innerHTML = '';
  });
}

// ==================== POOL ACTIVITY ====================

var _pmActivityCursor = null;
var _pmActivityInterval = null;

function togglePoolActivity() {
  const el = $('pmActivityDrawer');
  if (!el) return;
  el.classList.toggle('open');
  const body = el.querySelector('.pm-activity-body');
  if (body) body.style.display = el.classList.contains('open') ? '' : 'none';
  if (el.classList.contains('open') && !el.dataset.loaded) {
    el.dataset.loaded = '1';
    loadPoolActivity(el.dataset.poolId);
    _pmActivityInterval = setInterval(() => refreshPoolActivity(el.dataset.poolId), 30000);
  } else if (!el.classList.contains('open') && _pmActivityInterval) {
    clearInterval(_pmActivityInterval);
    _pmActivityInterval = null;
  }
}

function pmFmtWei(wei) {
  if (!wei || wei === '0') return '0';
  const s = wei.padStart(19, '0');
  const whole = s.slice(0, s.length - 18) || '0';
  const frac = s.slice(s.length - 18, s.length - 14);
  return whole + '.' + frac;
}

function pmFmtAge(ts) {
  const diff = Math.floor(Date.now() / 1000) - ts;
  if (diff < 60) return diff + 's ago';
  if (diff < 3600) return Math.floor(diff / 60) + 'm ago';
  if (diff < 86400) return Math.floor(diff / 3600) + 'h ago';
  return Math.floor(diff / 86400) + 'd ago';
}

function pmActivityRow(e, yesIsToken0) {
  let label, cls, amount;
  if (e.category === 'SWAP') {
    // Determine direction from actual token flows
    const a0out = BigInt(e.amount0_out || 0), a1out = BigInt(e.amount1_out || 0);
    const a0in = BigInt(e.amount0_in || 0), a1in = BigInt(e.amount1_in || 0);
    // Pool perspective: token_out = what user is buying, token_in = what user is selling
    // In CPMM: Buy NO  YES flows in, NO flows out. Buy YES  NO flows in, YES flows out.
    const yesOut = yesIsToken0 ? a0out : a1out;
    const yesIn = yesIsToken0 ? a0in : a1in;
    const noOut = yesIsToken0 ? a1out : a0out;
    const noIn = yesIsToken0 ? a1in : a0in;
    if (yesOut > 0n && noIn > 0n) {
      label = 'Buy YES'; cls = 'evt-buy-yes';
      amount = pmFmtWei(yesOut.toString());
    } else if (noOut > 0n && yesIn > 0n) {
      label = 'Buy NO'; cls = 'evt-buy-no';
      amount = pmFmtWei(noOut.toString());
    } else if (yesOut > 0n) {
      label = 'Sell NO'; cls = 'evt-sell-no';
      amount = pmFmtWei(yesOut.toString());
    } else if (noOut > 0n) {
      label = 'Sell YES'; cls = 'evt-sell-yes';
      amount = pmFmtWei(noOut.toString());
    } else {
      label = 'Swap'; cls = '';
      amount = '-';
    }
  } else if (e.type === 'LIQADD') {
    label = '+LP'; cls = 'evt-liqadd';
    amount = pmFmtWei(e.amount0_in || '0');
  } else if (e.type === 'LIQREM') {
    label = '-LP'; cls = 'evt-liqrem';
    amount = pmFmtWei(e.amount0_out || '0');
  } else {
    label = e.type; cls = '';
    amount = '-';
  }
  const txShort = e.txhash.slice(0, 6) + '\u2026' + e.txhash.slice(-4);
  return `<tr class="${cls}">
    <td>${pmFmtAge(Number(e.timestamp))}</td>
    <td class="evt-type">${label}</td>
    <td>${amount}</td>
    <td><a href="https://etherscan.io/tx/${e.txhash}" target="_blank" rel="noopener">${txShort}</a></td>
  </tr>`;
}

function _getYesIsToken0() {
  const el = $('pmActivityDrawer');
  return el ? el.dataset.yesIsToken0 === '1' : true;
}

function renderPmActivityTable(events, append) {
  const content = $('pmActivityContent');
  if (!content) return;
  if (!events.length && !append) {
    content.innerHTML = '<div class="pm-activity-empty">No activity yet</div>';
    return;
  }
  const y0 = _getYesIsToken0();
  const rows = events.map(e => pmActivityRow(e, y0)).join('');
  if (append) {
    const tbody = content.querySelector('tbody');
    if (tbody) tbody.insertAdjacentHTML('beforeend', rows);
  } else {
    content.innerHTML = `<table class="pm-activity-table">
      <thead><tr><th>Age</th><th>Type</th><th>Amount</th><th>Tx</th></tr></thead>
      <tbody>${rows}</tbody>
    </table>` + (_pmActivityCursor ? `<button class="pm-activity-more" onclick="loadMorePmActivity()">Load More</button>` : '');
  }
}

async function loadPoolActivity(poolId) {
  try {
    const res = await fetch(INDEXER + '/api/events?poolId=' + poolId + '&limit=30');
    const json = await res.json();
    _pmActivityCursor = json.nextCursor || null;
    renderPmActivityTable(json.data, false);
  } catch(e) {
    const content = $('pmActivityContent');
    if (content) content.innerHTML = '<div class="pm-activity-empty">Failed to load activity</div>';
  }
}

async function refreshPoolActivity(poolId) {
  try {
    const res = await fetch(INDEXER + '/api/events?poolId=' + poolId + '&limit=30');
    const json = await res.json();
    _pmActivityCursor = json.nextCursor || null;
    renderPmActivityTable(json.data, false);
  } catch(e) {}
}

async function loadMorePmActivity() {
  if (!_pmActivityCursor) return;
  const el = $('pmActivityDrawer');
  if (!el) return;
  const poolId = el.dataset.poolId;
  const btn = el.querySelector('.pm-activity-more');
  if (btn) { btn.textContent = 'Loading...'; btn.disabled = true; }
  try {
    const res = await fetch(INDEXER + '/api/events?poolId=' + poolId + '&limit=30&before=' + _pmActivityCursor);
    const json = await res.json();
    _pmActivityCursor = json.nextCursor || null;
    renderPmActivityTable(json.data, true);
    if (!_pmActivityCursor && btn) btn.remove();
    else if (btn) { btn.textContent = 'Load More'; btn.disabled = false; }
  } catch(e) {
    if (btn) { btn.textContent = 'Load More'; btn.disabled = false; }
  }
}

const $ = id => document.getElementById(id);
const _escTextMap = { '&': '&amp;', '<': '&lt;', '>': '&gt;' };
function escText(s) { return String(s).replace(/[&<>]/g, m => _escTextMap[m]); }
function escAttr(s) { return escText(s).replace(/"/g, '&quot;').replace(/'/g, '&#39;'); }

function zfiLoadingSVG(s=48){
return `<svg width="${s}" height="${s}" viewBox="0 0 400 400" xmlns="http://www.w3.org/2000/svg" style="display:block;margin:0 auto 8px"><g><polygon points="200,80 155,160 200,135" fill="#FF6B9D" stroke="#000" stroke-width="2"/><polygon points="200,80 200,135 245,160" fill="#00D4FF" stroke="#000" stroke-width="2"/><polygon points="155,160 200,135 200,160" fill="#FFE066" stroke="#000" stroke-width="2"/><polygon points="200,135 245,160 200,160" fill="#66D9A6" stroke="#000" stroke-width="2"/><polygon points="155,160 200,160 200,240" fill="#FF9F40" stroke="#000" stroke-width="2"/><polygon points="200,160 245,160 200,240" fill="#B967DB" stroke="#000" stroke-width="2"/><line x1="200" y1="80" x2="200" y2="240" stroke="#000" stroke-width="2"/><line x1="155" y1="160" x2="245" y2="160" stroke="#000" stroke-width="2"/><animate attributeName="opacity" values="1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0" dur="3.2s" repeatCount="indefinite"/></g><g opacity="0"><polygon points="200,80 160,160 200,132" fill="#FF6B9D" stroke="#000" stroke-width="2"/><polygon points="200,80 200,132 240,160" fill="#00D4FF" stroke="#000" stroke-width="2"/><polygon points="160,160 200,132 200,160" fill="#FFE066" stroke="#000" stroke-width="2"/><polygon points="200,132 240,160 200,160" fill="#66D9A6" stroke="#000" stroke-width="2"/><polygon points="160,160 200,160 200,240" fill="#FF9F40" stroke="#000" stroke-width="2"/><polygon points="200,160 240,160 200,240" fill="#B967DB" stroke="#000" stroke-width="2"/><line x1="200" y1="80" x2="200" y2="240" stroke="#000" stroke-width="2"/><line x1="160" y1="160" x2="240" y2="160" stroke="#000" stroke-width="2"/><animate attributeName="opacity" values="0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0" dur="3.2s" repeatCount="indefinite"/></g><g opacity="0"><polygon points="200,80 170,160 200,130" fill="#FF6B9D" stroke="#000" stroke-width="2"/><polygon points="200,80 200,130 235,160" fill="#00D4FF" stroke="#000" stroke-width="2"/><polygon points="200,130 235,160 200,160" fill="#66D9A6" stroke="#000" stroke-width="2"/><polygon points="170,160 200,160 200,240" fill="#FF9F40" stroke="#000" stroke-width="2"/><polygon points="200,160 235,160 200,240" fill="#B967DB" stroke="#000" stroke-width="2"/><line x1="200" y1="80" x2="200" y2="240" stroke="#000" stroke-width="2"/><line x1="170" y1="160" x2="235" y2="160" stroke="#000" stroke-width="2"/><animate attributeName="opacity" values="0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0" dur="3.2s" repeatCount="indefinite"/></g><g opacity="0"><polygon points="200,80 180,160 200,135" fill="#FF6B9D" stroke="#000" stroke-width="2"/><polygon points="200,80 200,135 220,160" fill="#00D4FF" stroke="#000" stroke-width="2"/><polygon points="200,135 220,160 200,160" fill="#66D9A6" stroke="#000" stroke-width="2"/><polygon points="180,160 200,160 200,240" fill="#FF9F40" stroke="#000" stroke-width="2"/><polygon points="200,160 220,160 200,240" fill="#B967DB" stroke="#000" stroke-width="2"/><line x1="200" y1="80" x2="200" y2="240" stroke="#000" stroke-width="2"/><line x1="180" y1="160" x2="220" y2="160" stroke="#000" stroke-width="2"/><animate attributeName="opacity" values="0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0" dur="3.2s" repeatCount="indefinite"/></g><g opacity="0"><polygon points="200,80 195,160 200,140" fill="#00D4FF" stroke="#000" stroke-width="2"/><polygon points="200,80 200,140 205,160" fill="#66D9A6" stroke="#000" stroke-width="2"/><polygon points="195,160 200,160 200,240" fill="#B967DB" stroke="#000" stroke-width="2"/><polygon points="200,160 205,160 200,240" fill="#B967DB" stroke="#000" stroke-width="2"/><line x1="200" y1="80" x2="200" y2="240" stroke="#000" stroke-width="2"/><line x1="195" y1="160" x2="205" y2="160" stroke="#000" stroke-width="2"/><animate attributeName="opacity" values="0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0" dur="3.2s" repeatCount="indefinite"/></g><g opacity="0"><polygon points="200,80 180,160 200,135" fill="#66D9A6" stroke="#000" stroke-width="2"/><polygon points="200,80 200,135 220,160" fill="#FFE066" stroke="#000" stroke-width="2"/><polygon points="180,160 200,135 200,160" fill="#66D9A6" stroke="#000" stroke-width="2"/><polygon points="180,160 200,160 200,240" fill="#B967DB" stroke="#000" stroke-width="2"/><polygon points="200,160 220,160 200,240" fill="#FF9F40" stroke="#000" stroke-width="2"/><line x1="200" y1="80" x2="200" y2="240" stroke="#000" stroke-width="2"/><line x1="180" y1="160" x2="220" y2="160" stroke="#000" stroke-width="2"/><animate attributeName="opacity" values="0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0" dur="3.2s" repeatCount="indefinite"/></g><g opacity="0"><polygon points="200,80 165,160 200,130" fill="#66D9A6" stroke="#000" stroke-width="2"/><polygon points="200,80 200,130 230,160" fill="#FFE066" stroke="#000" stroke-width="2"/><polygon points="165,160 200,130 200,160" fill="#66D9A6" stroke="#000" stroke-width="2"/><polygon points="165,160 200,160 200,240" fill="#B967DB" stroke="#000" stroke-width="2"/><polygon points="200,160 230,160 200,240" fill="#FF9F40" stroke="#000" stroke-width="2"/><line x1="200" y1="80" x2="200" y2="240" stroke="#000" stroke-width="2"/><line x1="165" y1="160" x2="230" y2="160" stroke="#000" stroke-width="2"/><animate attributeName="opacity" values="0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0" dur="3.2s" repeatCount="indefinite"/></g><g opacity="0"><polygon points="200,80 160,160 200,132" fill="#66D9A6" stroke="#000" stroke-width="2"/><polygon points="200,80 200,132 240,160" fill="#FFE066" stroke="#000" stroke-width="2"/><polygon points="160,160 200,132 200,160" fill="#66D9A6" stroke="#000" stroke-width="2"/><polygon points="200,132 240,160 200,160" fill="#FFE066" stroke="#000" stroke-width="2"/><polygon points="160,160 200,160 200,240" fill="#B967DB" stroke="#000" stroke-width="2"/><polygon points="200,160 240,160 200,240" fill="#FF9F40" stroke="#000" stroke-width="2"/><line x1="200" y1="80" x2="200" y2="240" stroke="#000" stroke-width="2"/><line x1="160" y1="160" x2="240" y2="160" stroke="#000" stroke-width="2"/><animate attributeName="opacity" values="0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0" dur="3.2s" repeatCount="indefinite"/></g><g opacity="0"><polygon points="200,80 155,160 200,135" fill="#66D9A6" stroke="#000" stroke-width="2"/><polygon points="200,80 200,135 245,160" fill="#FFE066" stroke="#000" stroke-width="2"/><polygon points="155,160 200,135 200,160" fill="#66D9A6" stroke="#000" stroke-width="2"/><polygon points="200,135 245,160 200,160" fill="#FFE066" stroke="#000" stroke-width="2"/><polygon points="155,160 200,160 200,240" fill="#B967DB" stroke="#000" stroke-width="2"/><polygon points="200,160 245,160 200,240" fill="#FF9F40" stroke="#000" stroke-width="2"/><line x1="200" y1="80" x2="200" y2="240" stroke="#000" stroke-width="2"/><line x1="155" y1="160" x2="245" y2="160" stroke="#000" stroke-width="2"/><animate attributeName="opacity" values="0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0" dur="3.2s" repeatCount="indefinite"/></g><g opacity="0"><polygon points="200,80 160,160 200,132" fill="#FFE066" stroke="#000" stroke-width="2"/><polygon points="200,80 200,132 240,160" fill="#66D9A6" stroke="#000" stroke-width="2"/><polygon points="160,160 200,132 200,160" fill="#FFE066" stroke="#000" stroke-width="2"/><polygon points="200,132 240,160 200,160" fill="#66D9A6" stroke="#000" stroke-width="2"/><polygon points="160,160 200,160 200,240" fill="#FF9F40" stroke="#000" stroke-width="2"/><polygon points="200,160 240,160 200,240" fill="#B967DB" stroke="#000" stroke-width="2"/><line x1="200" y1="80" x2="200" y2="240" stroke="#000" stroke-width="2"/><line x1="160" y1="160" x2="240" y2="160" stroke="#000" stroke-width="2"/><animate attributeName="opacity" values="0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0" dur="3.2s" repeatCount="indefinite"/></g><g opacity="0"><polygon points="200,80 170,160 200,130" fill="#FFE066" stroke="#000" stroke-width="2"/><polygon points="200,80 200,130 235,160" fill="#66D9A6" stroke="#000" stroke-width="2"/><polygon points="200,130 235,160 200,160" fill="#66D9A6" stroke="#000" stroke-width="2"/><polygon points="170,160 200,160 200,240" fill="#FF9F40" stroke="#000" stroke-width="2"/><polygon points="200,160 235,160 200,240" fill="#B967DB" stroke="#000" stroke-width="2"/><line x1="200" y1="80" x2="200" y2="240" stroke="#000" stroke-width="2"/><line x1="170" y1="160" x2="235" y2="160" stroke="#000" stroke-width="2"/><animate attributeName="opacity" values="0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0" dur="3.2s" repeatCount="indefinite"/></g><g opacity="0"><polygon points="200,80 180,160 200,135" fill="#FFE066" stroke="#000" stroke-width="2"/><polygon points="200,80 200,135 220,160" fill="#66D9A6" stroke="#000" stroke-width="2"/><polygon points="200,135 220,160 200,160" fill="#66D9A6" stroke="#000" stroke-width="2"/><polygon points="180,160 200,160 200,240" fill="#FF9F40" stroke="#000" stroke-width="2"/><polygon points="200,160 220,160 200,240" fill="#B967DB" stroke="#000" stroke-width="2"/><line x1="200" y1="80" x2="200" y2="240" stroke="#000" stroke-width="2"/><line x1="180" y1="160" x2="220" y2="160" stroke="#000" stroke-width="2"/><animate attributeName="opacity" values="0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0" dur="3.2s" repeatCount="indefinite"/></g><g opacity="0"><polygon points="200,80 195,160 200,140" fill="#FFE066" stroke="#000" stroke-width="2"/><polygon points="200,80 200,140 205,160" fill="#66D9A6" stroke="#000" stroke-width="2"/><polygon points="195,160 200,160 200,240" fill="#FF9F40" stroke="#000" stroke-width="2"/><polygon points="200,160 205,160 200,240" fill="#FF9F40" stroke="#000" stroke-width="2"/><line x1="200" y1="80" x2="200" y2="240" stroke="#000" stroke-width="2"/><line x1="195" y1="160" x2="205" y2="160" stroke="#000" stroke-width="2"/><animate attributeName="opacity" values="0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0" dur="3.2s" repeatCount="indefinite"/></g><g opacity="0"><polygon points="200,80 180,160 200,135" fill="#00D4FF" stroke="#000" stroke-width="2"/><polygon points="200,80 200,135 220,160" fill="#FFE066" stroke="#000" stroke-width="2"/><polygon points="200,135 220,160 200,160" fill="#FFE066" stroke="#000" stroke-width="2"/><polygon points="180,160 200,160 200,240" fill="#B967DB" stroke="#000" stroke-width="2"/><polygon points="200,160 220,160 200,240" fill="#FF9F40" stroke="#000" stroke-width="2"/><line x1="200" y1="80" x2="200" y2="240" stroke="#000" stroke-width="2"/><line x1="180" y1="160" x2="220" y2="160" stroke="#000" stroke-width="2"/><animate attributeName="opacity" values="0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0" dur="3.2s" repeatCount="indefinite"/></g><g opacity="0"><polygon points="200,80 170,160 200,130" fill="#00D4FF" stroke="#000" stroke-width="2"/><polygon points="200,80 200,130 235,160" fill="#FFE066" stroke="#000" stroke-width="2"/><polygon points="200,130 235,160 200,160" fill="#FFE066" stroke="#000" stroke-width="2"/><polygon points="170,160 200,160 200,240" fill="#B967DB" stroke="#000" stroke-width="2"/><polygon points="200,160 235,160 200,240" fill="#FF9F40" stroke="#000" stroke-width="2"/><line x1="200" y1="80" x2="200" y2="240" stroke="#000" stroke-width="2"/><line x1="170" y1="160" x2="235" y2="160" stroke="#000" stroke-width="2"/><animate attributeName="opacity" values="0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0" dur="3.2s" repeatCount="indefinite"/></g><g opacity="0"><polygon points="200,80 160,160 200,132" fill="#00D4FF" stroke="#000" stroke-width="2"/><polygon points="200,80 200,132 240,160" fill="#FF6B9D" stroke="#000" stroke-width="2"/><polygon points="160,160 200,132 200,160" fill="#66D9A6" stroke="#000" stroke-width="2"/><polygon points="200,132 240,160 200,160" fill="#FF6B9D" stroke="#000" stroke-width="2"/><polygon points="160,160 200,160 200,240" fill="#B967DB" stroke="#000" stroke-width="2"/><polygon points="200,160 240,160 200,240" fill="#FF9F40" stroke="#000" stroke-width="2"/><line x1="200" y1="80" x2="200" y2="240" stroke="#000" stroke-width="2"/><line x1="160" y1="160" x2="240" y2="160" stroke="#000" stroke-width="2"/><animate attributeName="opacity" values="0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1" dur="3.2s" repeatCount="indefinite"/></g></svg>`;}


// ==================== CONFIG ====================

const RPCS = [
  'https://ethereum.publicnode.com',
  'https://1rpc.io/eth',
  'https://eth.drpc.org',
  'https://eth.llamarpc.com'
];

const WEINS = "0x0000000000696760E15f265e828DB644A0c242EB";
const WEINS_ABI = ["function reverseResolve(address) view returns (string)", "function computeId(string) pure returns (uint256)", "function ownerOf(uint256) view returns (address)"];

const CONTRACTS = {
  PAMM: '0x000000000044bfe6c2BBFeD8862973E0612f07C0',
  ZAMM: '0x000000000000040470635EB91b7CE4D132D616eD',
  MASTER_ROUTER: '0x000000000088Ec6Ab5CA97A354Ce4C57dBA5B88a',
  RESOLVER: '0x0000000000FF0Dc62d07e220F273fe8cDd324127',
  PM_FEE_HOOK: '0x0000000000116D81CDDC3574e26eEa7b79410E80',
  QUOTER: '0x8F4283c327afF696789e23589c8c79306909B2Be',
  PM_HOOK_ROUTER: '0x0000000000Ff22a7FFEf88639d95C03183c5093C',
  CHAINLINK_ETH_USD: '0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419',
  BOOTSTRAPPER: '0x51157306D13fdc57a81B4b3574E04ad2e039CC88',
  GASPM: '0x0000000000ee3d4294438093EaA34308f47Bc0b4',
  LEGACY_RESOLVER: '0x9a70ca659D5E7eB41bB94a8eE56e254c9ec6b79c',
  PM_ROUTER: '0x000000000055ff709f26efb262fba8b0ae8c35dc'
};

const ZORG_TOKEN = '0x00a6bA94BBb5474725515De88fE04F854f2dCb12';
const ZORG_VERIFY_THRESHOLD = 100000n * 10n**18n; // 100k tokens (18 decimals)
const VERIFIED_BADGE = `<svg width="12" height="12" viewBox="0 0 16 16" style="vertical-align:middle;margin-left:3px"><circle cx="8" cy="8" r="7.5" fill="#1d9bf0"/><path d="M5 8.2l2 2 4-4.4" stroke="#fff" stroke-width="1.8" fill="none" stroke-linecap="round" stroke-linejoin="round"/></svg>`;

// Op enum: 0=LT, 1=GT, 2=LTE, 3=GTE, 4=EQ, 5=NEQ
const OP = { LT: 0, GT: 1, LTE: 2, GTE: 3, EQ: 4, NEQ: 5 };

const LEGACY_FEE_BPS = 30; // 0.3% fee for legacy (non-hooked) markets

const LEGACY_MARKETS = [
  {
    marketId: '56383978532102149659860873469210631142629299157140399402201151455176223336684',
    poolId: '17419310335243632136948884904978804426555201669398494770540125786404925384443',
    collateral: '0x0000000000000000000000000000000000000000',
    close: 1775001600
  }
];

const MULTICALL3 = '0xcA11bde05977b3631167028862bE2a173976CA11';

// ==================== ABIs ====================

const PAMM_ABI = [
  'function markets(uint256) view returns (address resolver, bool resolved, bool outcome, bool canClose, uint64 close, address collateral, uint256 collateralLocked)',
  'function totalSupplyId(uint256) view returns (uint256)',
  'function getMarketId(string description, address resolver, address collateral) pure returns (uint256)',
  'function getNoId(uint256 marketId) pure returns (uint256)',
  'function balanceOf(address, uint256) view returns (uint256)',
  'function setOperator(address, bool)',
  'function isOperator(address, address) view returns (bool)',
  'function claim(uint256 marketId, address to) returns (uint256 shares, uint256 payout)',
  'function claimMany(uint256[] marketIds, address to) returns (uint256 totalPayout)',
  'function getMarkets(uint256 start, uint256 count) view returns (uint256[] marketIds, address[] resolvers, address[] collaterals, uint8[] states, uint64[] closes, uint256[] collateralAmounts, uint256[] yesSupplies, uint256[] noSupplies, string[] descs, uint256 next)',
  'function getPoolState(uint256 marketId, uint256 feeOrHook) view returns (uint256 rYes, uint256 rNo, uint256 pYesNum, uint256 pYesDen)',
  'function getMarket(uint256 marketId) view returns (address resolver, address collateral, bool resolved, bool outcome, bool canClose, uint64 close, uint256 collateralLocked, uint256 yesSupply, uint256 noSupply, string description)',
  'function splitAndAddLiquidity(uint256 marketId, uint256 collateralIn, uint256 feeOrHook, uint256 amount0Min, uint256 amount1Min, uint256 minLiquidity, address to, uint256 deadline) payable returns (uint256 liquidity)',
  'function removeLiquidityToCollateral(uint256 marketId, uint256 feeOrHook, uint256 liquidity, uint256 amount0Min, uint256 amount1Min, uint256 minCollateralOut, address to, uint256 deadline) returns (uint256 collateralOut, uint256 leftoverYes, uint256 leftoverNo)',
  'function resolverFeeBps(address) view returns (uint16)',
  'function setResolverFeeBps(uint16 bps)'
];

const QUOTER_ABI = [
  'function getTWAPPrice(uint256 marketId) view returns (uint256 twapBps)',
  'function getMarketSummary(uint256 marketId) view returns (uint112 ammYesReserve, uint112 ammNoReserve, uint256 ammPriceYesBps, uint256 feeBps, uint112 vaultYesShares, uint112 vaultNoShares, uint256 totalYesVaultLP, uint256 totalNoVaultLP, uint256 vaultBudget, uint256 twapPriceYesBps, uint64 closeTime, bool resolved, bool inCloseWindow)',
  'function getUserFullPosition(uint256 marketId, address user) view returns (uint256 yesShareBalance, uint256 noShareBalance, uint112 yesVaultLP, uint112 noVaultLP, uint256 pendingYesCollateral, uint256 pendingNoCollateral)',
  'function quoteBuyWithSweep(uint256 marketId, bool buyYes, uint256 collateralIn, uint256 maxPriceBps) view returns (uint256 totalSharesOut, uint256 poolSharesOut, uint256 poolLevelsFilled, uint256 pmSharesOut, bytes4 pmSource)',
  'function quoteSellWithSweep(uint256 marketId, bool sellYes, uint256 sharesIn, uint256 minPriceBps) view returns (uint256 totalCollateralOut, uint256 poolCollateralOut, uint256 poolLevelsFilled, uint256 pmCollateralOut, bytes4 pmSource)'
];

const ZAMM_ABI = [
  'function balanceOf(address, uint256) view returns (uint256)',
  'function pools(uint256) view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast, uint256 price0CumulativeLast, uint256 price1CumulativeLast, uint256 kLast, uint256 supply)',
  'function isOperator(address, address) view returns (bool)',
  'function setOperator(address, bool)'
];

const MASTER_ROUTER_ABI = [
  'function buyWithSweep(uint256 marketId, bool buyYes, uint256 collateralIn, uint256 minSharesOut, uint256 maxPriceBps, address to, uint256 deadline) payable returns (uint256 totalSharesOut, uint256 poolSharesOut, uint256 poolLevelsFilled, bytes4[] sources)',
  'function sellWithSweep(uint256 marketId, bool sellYes, uint256 sharesIn, uint256 minCollateralOut, uint256 minPriceBps, address to, uint256 deadline) returns (uint256 totalCollateralOut, uint256 poolCollateralOut, uint256 poolLevelsFilled, bytes4[] sources)',
  'function multicall(bytes[] data) payable returns (bytes[] results)',
  'function permit(address token, address owner, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)'
];


// ==================== zRouter integration (buy with any token) ====================

const ZROUTER_ADDRESS = '0x000000000000FB114709235f1ccBFfb925F600e4';
const ZQUOTER_ADDRESS = '0x10D7e794518b45ced364FF38C0D48dfdC586f0Ef';
const WETH_ADDRESS = '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2';
const ZERO_ADDRESS = '0x0000000000000000000000000000000000000000';

const ZQUOTER_IFACE = new ethers.Interface([
  'function buildBestSwapViaETHMulticall(address to,address refundTo,bool exactOut,address tokenIn,address tokenOut,uint256 swapAmount,uint256 slippageBps,uint256 deadline,uint24 hookPoolFee,int24 hookTickSpacing,address hookAddress) view returns (tuple(uint8 source,uint256 feeBps,uint256 amountIn,uint256 amountOut) a, tuple(uint8 source,uint256 feeBps,uint256 amountIn,uint256 amountOut) b, bytes[] calls, bytes multicall, uint256 msgValue)'
]);

const ZROUTER_IFACE = new ethers.Interface([
  'function execute(address,uint256,bytes) payable returns (bytes)',
  'function multicall(bytes[]) payable returns (bytes[])',
  'function sweep(address,uint256,uint256,address) payable',
  'function unwrap(uint256) payable',
  'function permit(address token, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)',
  'function permitDAI(uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s)',
  'function permit2TransferFrom(address token, uint256 amount, uint256 nonce, uint256 deadline, bytes signature)'
]);

const MASTER_ROUTER_IFACE = new ethers.Interface(MASTER_ROUTER_ABI);

// ---- Permit support for zRouter pay tokens ----
const PERMIT2_ADDRESS = '0x000000000022D473030F116dDEE9F6B43aC78BA3';

const _predictPermitIface = new ethers.Interface([
  'function eip712Domain() view returns (bytes1 fields, string name, string version, uint256 chainId, address verifyingContract, bytes32 salt, uint256[] extensions)',
  'function nonces(address) view returns (uint256)',
  'function DOMAIN_SEPARATOR() view returns (bytes32)',
  'function name() view returns (string)',
  'function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)',
]);

const _predictPermitConfig = {
  '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48': { type: 'eip2612', domain: { name: 'USD Coin', version: '2', chainId: 1, verifyingContract: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48' } },
  '0x6b175474e89094c44da98b954eedeac495271d0f': { type: 'dai', domain: { name: 'Dai Stablecoin', version: '1', chainId: 1, verifyingContract: '0x6B175474E89094C44Da98b954EedeAC495271d0F' } },
  '0x6440f144b7e50d6a8439336510312d2f54beb01d': { type: 'eip2612', domain: { name: 'BOLD Stablecoin', version: '1', chainId: 1, verifyingContract: '0x6440f144b7e50D6a8439336510312d2F54beB01D' } },
};
const _predictPermitCache = new Map();

async function _predictStaticCall(tokenAddr, data) {
  return await withRPC(async (rpc) => rpc.call({ to: tokenAddr, data }));
}

async function predictDetectPermit(tokenAddress) {
  const key = tokenAddress.toLowerCase();
  if (_predictPermitConfig[key]) return _predictPermitConfig[key];
  if (_predictPermitCache.has(key)) return _predictPermitCache.get(key);
  try {
    const [nonceRes, dsRes] = await Promise.all([
      _predictStaticCall(tokenAddress, _predictPermitIface.encodeFunctionData('nonces', [ZERO_ADDRESS])),
      _predictStaticCall(tokenAddress, _predictPermitIface.encodeFunctionData('DOMAIN_SEPARATOR')),
    ]);
    if (!nonceRes || nonceRes === '0x' || !dsRes || dsRes === '0x') throw new Error('no permit');
    let domainName, domainVersion;
    try {
      const domRes = await _predictStaticCall(tokenAddress, _predictPermitIface.encodeFunctionData('eip712Domain'));
      const decoded = _predictPermitIface.decodeFunctionResult('eip712Domain', domRes);
      domainName = decoded[1]; domainVersion = decoded[2];
    } catch (_) {
      const nameRes = await _predictStaticCall(tokenAddress, _predictPermitIface.encodeFunctionData('name'));
      domainName = _predictPermitIface.decodeFunctionResult('name', nameRes)[0];
      domainVersion = '1';
    }
    const candidateDomain = { name: domainName, version: domainVersion, chainId: 1, verifyingContract: tokenAddress };
    const computed = ethers.TypedDataEncoder.hashDomain(candidateDomain);
    const onchain = ethers.AbiCoder.defaultAbiCoder().decode(['bytes32'], dsRes)[0];
    if (computed !== onchain) {
      candidateDomain.version = '2';
      if (ethers.TypedDataEncoder.hashDomain(candidateDomain) !== onchain) {
        _predictPermitCache.set(key, null); return null;
      }
    }
    const config = { type: 'eip2612', domain: candidateDomain };
    _predictPermitCache.set(key, config);
    return config;
  } catch (_) { _predictPermitCache.set(key, null); return null; }
}

async function predictGetPermitConfig(tokenAddress) {
  const key = tokenAddress.toLowerCase();
  if (_predictPermitConfig[key]) return _predictPermitConfig[key];
  return await predictDetectPermit(tokenAddress);
}

async function predictSignPermit(config, tokenAddress) {
  const deadline = BigInt(Math.trunc(Date.now() / 1000) + 3600);
  const owner = _connectedAddress;
  const spender = ZROUTER_ADDRESS;
  const nonceData = _predictPermitIface.encodeFunctionData('nonces', [owner]);
  const nonceResult = await _walletProvider.call({ to: tokenAddress, data: nonceData });
  const nonce = _predictPermitIface.decodeFunctionResult('nonces', nonceResult)[0];
  let types, values;
  if (config.type === 'dai') {
    types = { Permit: [{ name: 'holder', type: 'address' }, { name: 'spender', type: 'address' }, { name: 'nonce', type: 'uint256' }, { name: 'expiry', type: 'uint256' }, { name: 'allowed', type: 'bool' }] };
    values = { holder: owner, spender, nonce, expiry: deadline, allowed: true };
  } else {
    types = { Permit: [{ name: 'owner', type: 'address' }, { name: 'spender', type: 'address' }, { name: 'value', type: 'uint256' }, { name: 'nonce', type: 'uint256' }, { name: 'deadline', type: 'uint256' }] };
    values = { owner, spender, value: ethers.MaxUint256, nonce, deadline };
  }
  const sig = await _signer.signTypedData(config.domain, types, values);
  const { v, r, s } = ethers.Signature.from(sig);
  return { v, r, s, nonce, deadline, config, tokenAddress };
}

async function predictCheckPermit2Allowance(tokenAddress) {
  const token = new ethers.Contract(tokenAddress, ERC20_ABI, _walletProvider);
  return await token.allowance(_connectedAddress, PERMIT2_ADDRESS);
}

async function predictSignPermit2(tokenAddress, amount) {
  const deadline = BigInt(Math.trunc(Date.now() / 1000) + 3600);
  const _nb = new Uint8Array(8); crypto.getRandomValues(_nb);
  const nonce = _nb.reduce((n, b) => (n << 8n) | BigInt(b), 0n);
  const values = { permitted: { token: tokenAddress, amount }, spender: ZROUTER_ADDRESS, nonce, deadline };
  const types = {
    PermitTransferFrom: [{ name: 'permitted', type: 'TokenPermissions' }, { name: 'spender', type: 'address' }, { name: 'nonce', type: 'uint256' }, { name: 'deadline', type: 'uint256' }],
    TokenPermissions: [{ name: 'token', type: 'address' }, { name: 'amount', type: 'uint256' }],
  };
  const sig = await _signer.signTypedData({ name: 'Permit2', chainId: 1, verifyingContract: PERMIT2_ADDRESS }, types, values);
  return { signature: sig, nonce, deadline, token: tokenAddress, amount };
}

function predictBuildPermitCall(permitData) {
  if (permitData.config.type === 'dai') {
    return ZROUTER_IFACE.encodeFunctionData('permitDAI', [permitData.nonce, permitData.deadline, permitData.v, permitData.r, permitData.s]);
  }
  return ZROUTER_IFACE.encodeFunctionData('permit', [permitData.tokenAddress, ethers.MaxUint256, permitData.deadline, permitData.v, permitData.r, permitData.s]);
}

function predictBuildPermit2Call(p2) {
  return ZROUTER_IFACE.encodeFunctionData('permit2TransferFrom', [p2.token, p2.amount, p2.nonce, p2.deadline, p2.signature]);
}

const PREDICT_TOKENS = {
  ETH:    { address: ZERO_ADDRESS, symbol: 'ETH', decimals: 18 },
  WETH:   { address: '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2', symbol: 'WETH', decimals: 18 },
  USDC:   { address: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48', symbol: 'USDC', decimals: 6 },
  USDT:   { address: '0xdAC17F958D2ee523a2206206994597C13D831ec7', symbol: 'USDT', decimals: 6 },
  DAI:    { address: '0x6B175474E89094C44Da98b954EedeAC495271d0F', symbol: 'DAI', decimals: 18 },
  WBTC:   { address: '0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599', symbol: 'WBTC', decimals: 8 },
  stETH:  { address: '0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84', symbol: 'stETH', decimals: 18 },
  wstETH: { address: '0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0', symbol: 'wstETH', decimals: 18 },
  rETH:   { address: '0xae78736Cd615f374D3085123A210448E74Fc6393', symbol: 'rETH', decimals: 18 },
  BOLD:   { address: '0x6440f144b7e50D6a8439336510312d2F54beB01D', symbol: 'BOLD', decimals: 18 },
  LUSD:   { address: '0x5f98805A4E8be255a32880FDeC7F6728C6568bA0', symbol: 'LUSD', decimals: 18 },
  PNKSTR: { address: '0xc50673EDb3A7b94E8CAD8a7d4E0cD68864E33eDF', symbol: 'PNKSTR', decimals: 18 },
};

const _predictBuiltinAddrs = new Set(Object.values(PREDICT_TOKENS).map(t => t.address.toLowerCase()));

// Custom tokens from swap page (shared localStorage)
const _predictCustomTokens = {};
try {
  const saved = JSON.parse(localStorage.getItem('zswap_custom_tokens') || '[]');
  for (const t of saved) {
    if (t.address && t.symbol && t.decimals != null && !PREDICT_TOKENS[t.symbol]) {
      _predictCustomTokens[t.symbol] = { address: t.address, symbol: t.symbol, decimals: t.decimals };
    }
  }
} catch (_) {}

function _savePredictCustomTokens() {
  try {
    const all = [];
    // Merge with existing swap custom tokens to not lose them
    try {
      const existing = JSON.parse(localStorage.getItem('zswap_custom_tokens') || '[]');
      for (const t of existing) all.push(t);
    } catch (_) {}
    for (const t of Object.values(_predictCustomTokens)) {
      if (!all.some(x => x.address.toLowerCase() === t.address.toLowerCase())) {
        all.push({ address: t.address, symbol: t.symbol, decimals: t.decimals });
      }
    }
    localStorage.setItem('zswap_custom_tokens', JSON.stringify(all));
  } catch (_) {}
}

function getAllPayTokens() {
  return { ...PREDICT_TOKENS, ..._predictCustomTokens };
}

function findPayTokenByAddress(addr) {
  const lc = addr.toLowerCase();
  const all = getAllPayTokens();
  for (const t of Object.values(all)) {
    if (t.address.toLowerCase() === lc) return t;
  }
  return null;
}

const PAY_TOKEN_ICONS = {
  ETH: '<svg width="20" height="20" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><polygon fill="#80D8FF" points="7.62,18.83 16.01,30.5 16.01,24.1"/><polygon fill="#42A5F5" points="16.01,30.5 24.38,18.78 16.01,24.1"/><polygon fill="#FFF176" points="16.01,1.5 7.62,16.23 16.01,12.3"/><polygon fill="#FF8A80" points="24.38,16.18 16.01,1.5 16.01,12.3"/><polygon fill="#C1AEE1" points="16.01,21.5 24.38,16.18 16.01,12.3"/><polygon fill="#55FB9B" points="16.01,12.3 7.62,16.23 16.01,21.5"/></svg>',
  WETH: '<svg width="20" height="20" viewBox="0 0 36 36" xmlns="http://www.w3.org/2000/svg"><circle cx="18" cy="18" r="17" fill="none" stroke="#90CAF9" stroke-width="1.5" stroke-dasharray="4 2.5"/><g transform="translate(2,2)"><polygon fill="#80D8FF" points="7.62,18.83 16.01,30.5 16.01,24.1"/><polygon fill="#42A5F5" points="16.01,30.5 24.38,18.78 16.01,24.1"/><polygon fill="#FFF176" points="16.01,1.5 7.62,16.23 16.01,12.3"/><polygon fill="#FF8A80" points="24.38,16.18 16.01,1.5 16.01,12.3"/><polygon fill="#C1AEE1" points="16.01,21.5 24.38,16.18 16.01,12.3"/><polygon fill="#55FB9B" points="16.01,12.3 7.62,16.23 16.01,21.5"/></g></svg>',
  USDC: '<svg width="20" height="20" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><g fill="none"><circle fill="#2775CA" cx="16" cy="16" r="16"/><g fill="#FFF"><path d="M20.022 18.124c0-2.124-1.28-2.852-3.84-3.156-1.828-.243-2.193-.728-2.193-1.578 0-.85.61-1.396 1.828-1.396 1.097 0 1.707.364 2.011 1.275a.458.458 0 00.427.303h.975a.416.416 0 00.427-.425v-.06a3.04 3.04 0 00-2.743-2.489V9.142c0-.243-.183-.425-.487-.486h-.915c-.243 0-.426.182-.487.486v1.396c-1.829.242-2.986 1.456-2.986 2.974 0 2.002 1.218 2.791 3.778 3.095 1.707.303 2.255.668 2.255 1.639 0 .97-.853 1.638-2.011 1.638-1.585 0-2.133-.667-2.316-1.578-.06-.242-.244-.364-.427-.364h-1.036a.416.416 0 00-.426.425v.06c.243 1.518 1.219 2.61 3.23 2.914v1.457c0 .242.183.425.487.485h.915c.243 0 .426-.182.487-.485V21.34c1.829-.303 3.047-1.578 3.047-3.217z"/><path d="M12.892 24.497c-4.754-1.7-7.192-6.98-5.424-11.653.914-2.55 2.925-4.491 5.424-5.402.244-.121.365-.303.365-.607v-.85c0-.242-.121-.424-.365-.485-.061 0-.183 0-.244.06a10.895 10.895 0 00-7.13 13.717c1.096 3.4 3.717 6.01 7.13 7.102.244.121.488 0 .548-.243.061-.06.061-.122.061-.243v-.85c0-.182-.182-.424-.365-.546zm6.46-18.936c-.244-.122-.488 0-.548.242-.061.061-.061.122-.061.243v.85c0 .243.182.485.365.607 4.754 1.7 7.192 6.98 5.424 11.653-.914 2.55-2.925 4.491-5.424 5.402-.244.121-.365.303-.365.607v.85c0 .242.121.424.365.485.061 0 .183 0 .244-.06a10.895 10.895 0 007.13-13.717c-1.096-3.46-3.778-6.07-7.13-7.162z"/></g></g></svg>',
  USDT: '<svg width="20" height="20" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><g fill="none" fill-rule="evenodd"><circle cx="16" cy="16" r="16" fill="#26A17B"/><path fill="#FFF" d="M17.922 17.383v-.002c-.11.008-.677.042-1.942.042-1.01 0-1.721-.03-1.971-.042v.003c-3.888-.171-6.79-.848-6.79-1.658 0-.809 2.902-1.486 6.79-1.66v2.644c.254.018.982.061 1.988.061 1.207 0 1.812-.05 1.925-.06v-2.643c3.88.173 6.775.85 6.775 1.658 0 .81-2.895 1.485-6.775 1.657m0-3.59v-2.366h5.414V7.819H8.595v3.608h5.414v2.365c-4.4.202-7.709 1.074-7.709 2.118 0 1.044 3.309 1.915 7.709 2.118v7.582h3.913v-7.584c4.393-.202 7.694-1.073 7.694-2.116 0-1.043-3.301-1.914-7.694-2.117"/></g></svg>',
  DAI: '<svg width="20" height="20" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><g fill="none" fill-rule="evenodd"><circle fill="#F4B731" fill-rule="nonzero" cx="16" cy="16" r="16"/><path d="M9.277 8h6.552c3.985 0 7.006 2.116 8.13 5.194H26v1.861h-1.611c.031.294.047.594.047.898v.046c0 .342-.02.68-.06 1.01H26v1.86h-2.08C22.767 21.905 19.77 24 15.83 24H9.277v-5.131H7v-1.86h2.277v-1.954H7v-1.86h2.277V8zm1.831 10.869v3.462h4.72c2.914 0 5.078-1.387 6.085-3.462H11.108zm11.366-1.86H11.108v-1.954h11.37c.041.307.063.622.063.944v.045c0 .329-.023.65-.067.964zM15.83 9.665c2.926 0 5.097 1.424 6.098 3.528h-10.82V9.666h4.72z" fill="#FFF"/></g></svg>',
  WBTC: '<svg width="20" height="20" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><g fill="none" fill-rule="evenodd"><circle cx="16" cy="16" r="16" fill="#F7931A"/><path fill="#FFF" fill-rule="nonzero" d="M23.189 14.02c.314-2.096-1.283-3.223-3.465-3.975l.708-2.84-1.728-.43-.69 2.765c-.454-.114-.92-.22-1.385-.326l.695-2.783L15.596 6l-.708 2.839c-.376-.086-.746-.17-1.104-.26l.002-.009-2.384-.595-.46 1.846s1.283.294 1.256.312c.7.175.826.638.805 1.006l-.806 3.235c.048.012.11.03.18.057l-.183-.045-1.13 4.532c-.086.212-.303.531-.793.41.018.025-1.256-.313-1.256-.313l-.858 1.978 2.25.561c.418.105.828.215 1.231.318l-.715 2.872 1.727.43.708-2.84c.472.127.93.245 1.378.357l-.706 2.828 1.728.43.715-2.866c2.948.558 5.164.333 6.097-2.333.752-2.146-.037-3.385-1.588-4.192 1.13-.26 1.98-1.003 2.207-2.538zm-3.95 5.538c-.533 2.147-4.148.986-5.32.695l.95-3.805c1.172.293 4.929.872 4.37 3.11zm.535-5.569c-.487 1.953-3.495.96-4.47.717l.86-3.45c.975.243 4.118.696 3.61 2.733z"/></g></svg>',
  stETH: '<svg width="20" height="20" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><g fill="none"><circle fill="#00A3FF" cx="16" cy="16" r="16"/><path d="M16.005 4.805l-5.655 8.668 5.655-3.233V4.805z" fill="#FFF"/><path opacity=".6" d="M16.004 10.238l5.658 3.23-5.658-8.674v5.444z" fill="#FFF"/><path opacity=".6" d="M16.005 10.239l-5.655 3.229 5.655 3.23v-6.46z" fill="#FFF"/><path opacity=".2" d="M16.004 10.239v6.459l5.654-3.23-5.654-3.229z" fill="#FFF"/><path d="M10.35 14.864c-2.048 3.097-1.603 7.253 1.034 9.824 1.561 1.521 3.622 2.353 5.683 2.353 2.061 0 4.122-.832 5.683-2.353 2.637-2.571 3.082-6.727 1.034-9.824L16.067 18.611 10.35 14.864z" fill="#FFF" opacity=".6"/></g></svg>',
  wstETH: '<svg width="20" height="20" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><g fill="none"><circle fill="#00A3FF" cx="16" cy="16" r="16"/><path d="M9.437 14.864l-.181.275c-2.048 3.097-1.603 7.253 1.034 9.824 1.561 1.521 3.622 2.353 5.683 2.353 0 0 0 0-6.536-12.452z" fill="#FFF"/><path opacity=".6" d="M15.997 18.611l-6.56-3.747c6.56 12.452 6.56 12.452 6.56 12.452 0-2.683 0-5.623 0-8.705z" fill="#FFF"/><path opacity=".6" d="M22.563 14.864l.181.275c2.048 3.097 1.603 7.253-1.034 9.824-1.561 1.521-3.622 2.353-5.683 2.353 0 0 0 0 6.536-12.452z" fill="#FFF"/><path opacity=".2" d="M16.003 18.611l6.56-3.747c-6.56 12.452-6.56 12.452-6.56 12.452 0-2.683 0-5.623 0-8.705z" fill="#FFF"/><path opacity=".2" d="M16.004 10.239v6.459l5.654-3.23-5.654-3.229z" fill="#FFF"/><path opacity=".6" d="M16.005 10.239l-5.655 3.229 5.655 3.23v-6.46z" fill="#FFF"/><path d="M16.005 4.805l-5.655 8.668 5.655-3.233V4.805z" fill="#FFF"/><path opacity=".6" d="M16.004 10.238l5.658 3.23-5.658-8.674v5.444z" fill="#FFF"/></g></svg>',
  BOLD: '<svg width="20" height="20" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_1_6)"><path d="M32 16C32 7.16406 24.8359 0 16 0C7.16406 0 0 7.16406 0 16C0 24.8359 7.16406 32 16 32C24.8359 32 32 24.8359 32 16Z" fill="#63D77D"/><path fill-rule="evenodd" clip-rule="evenodd" d="M12.1719 4.56641H8.58203V26.1016H15.7617V25.2422C16.8398 25.793 18.0586 26.1055 19.3555 26.1055C23.7148 26.1055 27.25 22.5703 27.25 18.207C27.25 13.8438 23.7148 10.3086 19.3555 10.3086C18.0586 10.3086 16.8398 10.6211 15.7617 11.1719V4.56641H12.1719ZM15.7617 11.1719C13.207 12.4805 11.457 15.1406 11.457 18.207C11.457 21.2734 13.207 23.9336 15.7617 25.2422V11.1719Z" fill="#1C1D4F"/></g><defs><clipPath id="clip0_1_6"><rect width="32" height="32" fill="white"/></clipPath></defs></svg>',
  LUSD: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 256" width="20" height="20"><circle cx="128" cy="132" r="102" fill="#29C9EB"/><rect x="110" y="4" width="36" height="32" rx="9" fill="#29C9EB"/><rect x="110" y="228" width="36" height="24" rx="9" fill="#29C9EB"/><path d="M 128 30 A 102 102 0 0 1 128 234 Z" fill="#7B6AD6"/><path d="M 128 4 L 137 4 Q 146 4 146 13 L 146 36 L 128 36 Z" fill="#7B6AD6"/><path d="M 128 228 L 146 228 L 146 243 Q 146 252 137 252 L 128 252 Z" fill="#7B6AD6"/><g fill="none" stroke="white" stroke-width="26" stroke-linecap="round" stroke-linejoin="round"><path d="M 154 90 C 146 78, 134 72, 120 74 C 98 78, 82 94, 82 112 C 82 132, 98 142, 128 150 C 158 158, 174 168, 174 186 C 174 206, 158 218, 136 220 C 120 222, 106 216, 98 204"/><line x1="128" y1="74" x2="128" y2="15"/><line x1="128" y1="220" x2="128" y2="241"/></g></svg>',
  rETH: '<svg width="20" height="20" viewBox="0 0 33 32" fill="none" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#pt_reth_c)"><path d="M16.5 32C25.3365 32 32.5 24.8365 32.5 16C32.5 7.16347 25.3365 0 16.5 0C7.66347 0 0.5 7.16347 0.5 16C0.5 24.8365 7.66347 32 16.5 32Z" fill="url(#pt_reth_g)"/><path d="M16.4763 19.4523L10.3889 15.8513L16.4763 5.75293L22.5583 15.8513L16.4763 19.4523Z" fill="white"/><path d="M16.4763 25.5835L10.3889 17.0098L16.4763 20.6054L22.5638 17.0098L16.4763 25.5835Z" fill="white"/></g><defs><radialGradient id="pt_reth_g" cx="0" cy="0" r="1" gradientUnits="userSpaceOnUse" gradientTransform="translate(10.9533 7.65333) rotate(54.1675) scale(26.511)"><stop stop-color="#FFD794"/><stop offset="1" stop-color="#ED5A37"/></radialGradient><clipPath id="pt_reth_c"><rect width="32" height="32" fill="white" transform="translate(0.5)"/></clipPath></defs></svg>',
  PNKSTR: '<svg width="20" height="20" viewBox="0 0 296 296" xmlns="http://www.w3.org/2000/svg"><circle r="148" transform="translate(148 148)" fill="#0d0d0d"/><path d="M141.692,120.865v-43.1014h11.213v43.1014h-11.213ZM125.299,78.8923v-9.4526h43.857v9.4526h-43.857Zm53.228,41.9727L164.05,69.4397h11.425l9.51,39.2913h-.923l10.007-39.2913h10.716l9.864,39.2913h-.852l9.581-39.2913h11.567L220.184,120.865h-12.135l-9.084-36.0472h.994l-9.155,36.0472h-12.277Z" fill="#fff"/><g transform="translate(135.33781,207.03926)"><circle cx="0" cy="0" r="17.5" fill="#d2dbed"/><path d="M-7.12,-12.9l14.24,0l0,5.8l-8.05,13l8.05,0l0,6.05l-14.24,0l0-5.8l8.04-13l-8.04,0Z" fill="#0d0d0d"/></g></svg>',
};

function _makeLetterIcon(sym, size) {
  size = size || 20;
  const clean = String(sym || '').replace(/[^A-Za-z0-9]/g, '') || '?';
  const show = clean.length <= 5 ? clean : clean.slice(0, 4) + '\u2026';
  const L = show.length;
  const fontSize = L <= 1 ? 10 : L === 2 ? 8.5 : L === 3 ? 7 : L === 4 ? 6 : 5;
  let hash = 0;
  for (let i = 0; i < clean.length; i++) hash = ((hash << 5) - hash + clean.charCodeAt(i)) | 0;
  const hue = ((hash % 360) + 360) % 360;
  return `<svg width="${size}" height="${size}" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">` +
    `<circle cx="12" cy="12" r="11" fill="hsl(${hue},50%,50%)" stroke="hsl(${hue},35%,38%)" stroke-width="1"/>` +
    `<text x="12" y="12.3" text-anchor="middle" dominant-baseline="middle" font-family="Helvetica,Arial,sans-serif" font-size="${fontSize}" font-weight="700" fill="#fff">${escText(show)}</text></svg>`;
}

function payTokenIcon(sym) {
  return PAY_TOKEN_ICONS[sym] || _makeLetterIcon(sym, 20);
}

let _selectedPayToken = null; // null = use market collateral (default)

function safeParseUnits(valStr, decimals) {
  const s = String(valStr).trim();
  if (!s) throw new Error('Empty amount');
  const m = s.match(/^(\d+)(?:\.(\d+))?$/);
  if (!m) throw new Error('Invalid number');
  const frac = m[2] || '';
  if (frac.length > decimals) throw new Error(`Too many decimals (max ${decimals})`);
  return ethers.parseUnits(s, decimals);
}

const PM_ROUTER_ABI = [
  'function buy(uint256 marketId, bool isYes, uint256 collateralIn, uint256 minSharesOut, uint256 feeOrHook, address to, uint256 deadline) payable returns (uint256)',
  'function sell(uint256 marketId, bool isYes, uint256 sharesIn, uint256 minCollateralOut, uint256 feeOrHook, address to, uint256 deadline) returns (uint256)'
];

const RESOLVER_ABI = [
  'function resolveMarket(uint256 marketId)',
  'function preview(uint256 marketId) view returns (uint256 value, bool condTrue, bool ready)',
  'function conditions(uint256) view returns (address targetA, address targetB, uint8 op, bool isRatio, uint256 threshold, uint256 threshold2, bytes callDataA, bytes callDataB)',
  'function createNumericMarket(string observable, address collateral, address target, bytes callData, uint8 op, uint256 threshold, uint64 close, bool canClose) returns (uint256 marketId, uint256 noId)'
];

const LEGACY_RESOLVER_ABI = [
  'function preview(uint256 marketId) view returns (uint256 value, bool condTrue, bool ready)',
  'function conditions(uint256) view returns (address targetA, address targetB, uint8 op, bool isRatio, uint256 threshold, bytes callDataA, bytes callDataB)',
  'function resolveMarket(uint256 marketId)'
];

const BOOTSTRAPPER_ABI = [
  'function bootstrapMarket(string description, address resolverAddr, address collateral, uint64 close, bool canClose, address hook, uint256 collateralForLP, bool buyYes, uint256 collateralForBuy, uint256 minSharesOut, address to, uint256 deadline) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares, uint256 sharesOut)',
  'function bootstrapPriceMarket(string description, address collateral, uint64 close, address hook, uint256 collateralForLP, address to, uint256 deadline, address priceFeed, uint8 op, uint256 priceThreshold) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares)',
  'function bootstrapETHBalanceMarket(string description, address collateral, uint64 close, address hook, uint256 collateralForLP, address to, uint256 deadline, address account, uint8 op, uint256 balanceThreshold) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares)',
  'function bootstrapTokenBalanceMarket(string description, address collateral, uint64 close, address hook, uint256 collateralForLP, address to, uint256 deadline, address token, address account, uint8 op, uint256 balanceThreshold) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares)',
  'function bootstrapWithCondition(string description, address collateral, uint64 close, bool canClose, address hook, uint256 collateralForLP, bool buyYes, uint256 collateralForBuy, uint256 minSharesOut, address to, uint256 deadline, address target, bytes callData, uint8 op, uint256 threshold) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares, uint256 sharesOut)',
  'function addOrderbookBids(uint256 marketId, address collateral, tuple(bool buyYes, uint256 priceInBps, uint256 amount, uint256 minShares)[] bids, address to) payable',
  'function computeMarketIdResolver(string description, address collateral) view returns (uint256)'
];

const CHAINLINK_ABI = [
  'function latestAnswer() view returns (int256)',
  'function decimals() view returns (uint8)'
];

const ERC20_ABI = [
  'function symbol() view returns (string)',
  'function decimals() view returns (uint8)',
  'function totalSupply() view returns (uint256)',
  'function balanceOf(address) view returns (uint256)',
  'function allowance(address owner, address spender) view returns (uint256)',
  'function approve(address spender, uint256 amount) returns (bool)'
];

const PM_HOOK_ROUTER_ABI = [
  'function addLiquidity(uint256 marketId, address collateral, uint256 collateralIn, uint256 feeOrHook, uint256 amount0Min, uint256 amount1Min, uint256 minLiquidity, address lpRecipient, uint256 deadline) payable returns (uint256 shares, uint256 liquidity)',
  'function depositToVault(uint256 marketId, address collateral, uint256 amount, bool yesVault, address to) payable returns (uint256 vaultShares)',
  'function withdrawFromVault(uint256 marketId, bool isYes, uint256 vaultSharesToRedeem, address receiver, uint256 deadline) returns (uint256 sharesReturned, uint256 feesEarned)',
  'function vaultPositions(uint256, address) view returns (uint112 yesVaultShares, uint112 noVaultShares, uint32 lastDepositTime, uint256 yesRewardDebt, uint256 noRewardDebt)',
  'function rebalanceBootstrapVault(uint256 marketId, uint256 deadline) returns (uint256 collateralUsed)',
  'function updateTWAPObservation(uint256 marketId)',
  'function settleRebalanceBudget(uint256 marketId) returns (uint256 budgetDistributed, uint256 sharesMerged)',
  'function harvestVaultFees(uint256 marketId, bool isYes) returns (uint256 feesEarned)',
  'function finalizeMarket(uint256 marketId) returns (uint256 totalToDAO)',
  'function redeemVaultWinningShares(uint256 marketId) returns (uint256 payout)',
  'function rebalanceCollateralBudget(uint256) view returns (uint256)',
  'function bootstrapVaults(uint256) view returns (uint112 yesShares, uint112 noShares, uint32 lastActivity)',
  'function twapObservations(uint256) view returns (uint32 timestamp0, uint32 timestamp1, uint32 cachedTwapBps, uint32 cacheBlockNum, uint256 cumulative0, uint256 cumulative1)'
];

const MULTICALL3_ABI = [
  'function aggregate3(tuple(address target, bool allowFailure, bytes callData)[] calls) view returns (tuple(bool success, bytes returnData)[])'
];

// ==================== RPC ====================

let rpcIdx = 0;
function getRPC() {
  return new ethers.JsonRpcProvider(RPCS[rpcIdx % RPCS.length], 1, { staticNetwork: true });
}
async function withRPC(fn) {
  for (let i = 0; i < RPCS.length; i++) {
    try {
      const rpc = new ethers.JsonRpcProvider(RPCS[(rpcIdx + i) % RPCS.length], 1, { staticNetwork: true });
      const result = await fn(rpc);
      rpcIdx = (rpcIdx + i) % RPCS.length;
      return result;
    } catch(e) { if (i === RPCS.length - 1) throw e; }
  }
}

async function multicall(calls, rpc) {
  if (!calls.length) return [];
  const mc = new ethers.Contract(MULTICALL3, MULTICALL3_ABI, rpc);
  const callData = calls.map(c => ({ target: c.target, allowFailure: true, callData: c.callData }));
  const results = await mc.aggregate3(callData);
  return results.map((r, i) => ({ success: r.success, data: r.returnData, decode: () => calls[i].decode(r.returnData) }));
}

async function checkResolverVerified(addr) {
  try {
    return await withRPC(async (rpc) => {
      const token = new ethers.Contract(ZORG_TOKEN, ERC20_ABI, rpc);
      const bal = await token.balanceOf(addr);
      return bal >= ZORG_VERIFY_THRESHOLD;
    });
  } catch { return false; }
}

async function getResolverFeeBps(addr) {
  try {
    return await withRPC(async (rpc) => {
      const pamm = new ethers.Contract(CONTRACTS.PAMM, PAMM_ABI, rpc);
      return Number(await pamm.resolverFeeBps(addr));
    });
  } catch { return 0; }
}

async function reverseResolveWei(addr) {
  try {
    return await withRPC(async (rpc) => {
      const ns = new ethers.Contract(WEINS, WEINS_ABI, rpc);
      const name = await ns.reverseResolve(addr);
      return name || null;
    });
  } catch { return null; }
}

// ==================== HELPERS ====================

function fmtETH(wei) {
  const v = Number(ethers.formatEther(wei));
  if (v >= 1) return v.toFixed(4) + ' ETH';
  if (v >= 0.001) return v.toFixed(6) + ' ETH';
  return v.toFixed(8) + ' ETH';
}

function fmtCountdown(closeTs) {
  const now = Math.floor(Date.now() / 1000);
  const diff = closeTs - now;
  if (diff <= 0) return 'Closed';
  const d = Math.floor(diff / 86400);
  const h = Math.floor((diff % 86400) / 3600);
  const m = Math.floor((diff % 3600) / 60);
  if (d > 0) return d + 'd ' + h + 'h';
  if (h > 0) return h + 'h ' + m + 'm';
  return m + 'm';
}

function fmtDate(ts) {
  return new Date(ts * 1000).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
}

function fmtDuration(sec) {
  if (sec <= 0) return '';
  const h = Math.floor(sec / 3600);
  const m = Math.floor((sec % 3600) / 60);
  if (h > 0) return m > 0 ? `${h}h ${m}m` : `${h}h`;
  return `${m}m`;
}

function _vaultCooldownRemaining(depositTime, closeTime) {
  const now = Math.floor(Date.now() / 1000);
  // Late deposit (within 12h of close) = 24h cooldown, otherwise 6h
  const isLate = closeTime > 0 && (closeTime - depositTime) < 43200;
  const cooldown = isLate ? 86400 : 21600;
  const unlockTime = depositTime + cooldown;
  return Math.max(0, unlockTime - now);
}

function formatPrice(val) {
  if (val >= 1e6) return `$${(val/1e6).toFixed(val % 1e6 === 0 ? 0 : 1)}M`;
  if (val >= 1000) return `$${(val/1000).toFixed(val % 1000 === 0 ? 0 : 1)}K`;
  return `$${val}`;
}

function getCollateralSymbol(addr) {
  if (!addr || addr === ethers.ZeroAddress) return 'ETH';
  const known = {
    '0x1f9840a85d5af5bf1d1762f925bdaddc4201f984': 'UNI',
    '0x514910771af9ca656af840dff83e8264ecf986ca': 'LINK',
    '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2': 'WETH',
    '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48': 'USDC',
    '0xdac17f958d2ee523a2206206994597c13d831ec7': 'USDT',
    '0x6b175474e89094c44da98b954eedeac495271d0f': 'DAI'
  };
  return known[(addr || '').toLowerCase()] || 'ERC20';
}

function isOurLabeledMarket(description) {
  if (!description) return false;
  if (description.startsWith('PRICE|') ||
      description.startsWith('GAS|') ||
      description.startsWith('TOKBAL|') ||
      description.startsWith('NFTBAL|') ||
      description.startsWith('ETHBAL|') ||
      description.startsWith('SUPPLY|')) return true;
  if (description.startsWith('V4 Protocol') ||
      description.startsWith('UNI balance') ||
      description.startsWith('UNI voting power') ||
      description.startsWith('UNI totalSupply') ||
      description.startsWith('UNI price')) return true;
  if (description.startsWith('zOrgz')) return true;
  return false;
}

// ==================== MARKET DESCRIPTION PARSER ====================

// Name registries (copied from ethPM.html)
const TOKEN_NAMES = {
  '0x00000000008835cef3e0d2333695f288ee6b63a6': 'zOrgz',
  '0x514910771af9ca656af840dff83e8264ecf986ca': 'LINK',
};
const ACCOUNT_NAMES = {
  '0x5e58ba0e06ed0f5558f83be732a4b899a674053e': 'zOrg DAO',
  '0xbc10f2e862ed4502144c7d632a3459f49dfcdb5e': 'Chainlink Reserve',
  '0x9a709b7b69ea42d5eeb1cebc48674c69e1569ec6': 'RBACTimelock',
};

// Token logos (copied from ethPM.html)
const ZORGZ_LOGO = `<svg width="16" height="16" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" style="vertical-align:middle;margin-right:4px;image-rendering:pixelated"><rect width="16" height="16" fill="#0a0a0a"/><rect x="3" y="1" width="1" height="1" fill="#e8e8e0"/><rect x="5" y="2" width="1" height="1" fill="#e8e8e0"/><rect x="10" y="2" width="1" height="1" fill="#e8e8e0"/><rect x="12" y="1" width="1" height="1" fill="#e8e8e0"/><rect x="4" y="4" width="8" height="1" fill="#e8e8e0"/><rect x="3" y="5" width="10" height="1" fill="#e8e8e0"/><rect x="2" y="6" width="12" height="3" fill="#e8e8e0"/><rect x="3" y="9" width="10" height="1" fill="#e8e8e0"/><rect x="4" y="10" width="8" height="1" fill="#e8e8e0"/><rect x="3" y="6" width="3" height="2" fill="#0a0a0a"/><rect x="10" y="6" width="3" height="2" fill="#0a0a0a"/><rect x="5" y="11" width="2" height="1" fill="#e8e8e0"/><rect x="9" y="11" width="2" height="1" fill="#e8e8e0"/><rect x="2" y="12" width="3" height="1" fill="#e8e8e0"/><rect x="7" y="12" width="2" height="1" fill="#e8e8e0"/><rect x="11" y="12" width="3" height="1" fill="#e8e8e0"/><rect x="1" y="13" width="2" height="1" fill="#e8e8e0"/><rect x="13" y="13" width="2" height="1" fill="#e8e8e0"/></svg>`;
const TOKEN_LOGOS = {
  'zorgz': ZORGZ_LOGO,
  '0x00000000008835cef3e0d2333695f288ee6b63a6': ZORGZ_LOGO,
  '0x514910771af9ca656af840dff83e8264ecf986ca': `<svg width="16" height="16" viewBox="0 0 24 24" role="img" xmlns="http://www.w3.org/2000/svg" style="vertical-align:middle;margin-right:4px"><path fill="currentColor" d="M12 0 9.798 1.266l-6 3.468L1.596 6v12l2.202 1.266 6.055 3.468L12.055 24l2.202-1.266 5.945-3.468L22.404 18V6l-2.202-1.266-6-3.468zM6 15.468V8.532l6-3.468 6 3.468v6.936l-6 3.468z"/></svg>`,
  'eth': `<svg width="16" height="16" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg" style="vertical-align:middle;margin-right:4px"><circle cx="16" cy="16" r="16" fill="#627EEA"/><g fill="#FFF" fill-rule="nonzero"><path fill-opacity=".602" d="M16.498 4v8.87l7.497 3.35z"/><path d="M16.498 4L9 16.22l7.498-3.35z"/><path fill-opacity=".602" d="M16.498 21.968v6.027L24 17.616z"/><path d="M16.498 27.995v-6.028L9 17.616z"/><path fill-opacity=".2" d="M16.498 20.573l7.497-4.353-7.497-3.348z"/><path fill-opacity=".602" d="M9 16.22l7.498 4.353v-7.701z"/></g></svg>`,
  '0x1f9840a85d5af5bf1d1762f925bdaddc4201f984': `<svg width="16" height="16" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg" style="vertical-align:middle;margin-right:4px"><circle fill="#FF007A" cx="16" cy="16" r="16"/><g fill="#FFF"><path d="M12.261 5.767c-.285-.044-.297-.05-.163-.07.257-.04.865.015 1.284.114.977.233 1.866.828 2.816 1.885l.252.28.36-.057c1.52-.245 3.067-.05 4.36.547.356.164.917.491.987.576.023.026.064.199.091.383.096.637.048 1.125-.146 1.49-.106.198-.112.26-.041.43a.416.416 0 00.372.236c.322 0 .668-.52.828-1.243l.064-.287.126.143c.692.784 1.235 1.853 1.328 2.613l.025.199-.117-.18c-.2-.31-.4-.522-.658-.693-.464-.307-.955-.411-2.255-.48-1.174-.062-1.839-.162-2.497-.377-1.121-.365-1.686-.852-3.018-2.599-.591-.776-.957-1.205-1.32-1.55-.827-.786-1.639-1.198-2.678-1.36z"/><path d="M22.422 7.5c.03-.52.1-.863.242-1.176.056-.124.109-.226.117-.226a.773.773 0 01-.055.204c-.103.304-.12.72-.049 1.203.09.614.142.702.79 1.365.305.311.659.703.787.872l.233.306-.233-.219c-.285-.267-.941-.79-1.086-.864-.097-.05-.112-.049-.172.01-.055.056-.067.138-.074.529-.012.608-.095 1-.296 1.39-.108.21-.125.166-.027-.073.073-.178.08-.256.08-.845 0-1.184-.141-1.468-.966-1.956a9.046 9.046 0 00-.764-.396 2.916 2.916 0 01-.374-.182c.023-.023.827.211 1.15.336.482.185.561.209.62.186.039-.015.058-.129.077-.464z"/><path d="M21.06 18.116c-.36-.773-.442-1.52-.245-2.216.021-.074.055-.135.075-.135a.73.73 0 01.189.102c.166.112.498.3 1.383.782 1.105.603 1.735 1.07 2.164 1.602.375.467.607.999.719 1.647.063.367.026 1.25-.068 1.62-.297 1.166-.988 2.082-1.972 2.616a2.53 2.53 0 01-.288.143c-.014 0 .038-.133.117-.297.33-.692.369-1.366.118-2.116-.153-.459-.466-1.02-1.097-1.966-.734-1.1-.914-1.394-1.095-1.782z"/></g></svg>`,
};

function etherscanLink(addr, opts = {}) {
  const { color = '#627EEA', type = 'address' } = opts;
  const lowerAddr = addr.toLowerCase();
  let displayName = ACCOUNT_NAMES[lowerAddr] || TOKEN_NAMES[lowerAddr];
  if (!displayName) displayName = `${addr.slice(0,6)}...${addr.slice(-4)}`;
  const logo = TOKEN_LOGOS[lowerAddr] || '';
  const baseUrl = 'https://etherscan.io';
  const url = type === 'token' ? `${baseUrl}/token/${addr}` : `${baseUrl}/address/${addr}`;
  return `<a href="${url}" target="_blank" rel="noopener" style="color:inherit;text-decoration:underline;text-decoration-color:${color}" title="${addr}">${logo}${displayName}</a>`;
}

const COLORS = {
  ETH: '#627EEA', BTC: '#F7931A', SOL: '#14F195', LINK: '#375BD2',
  UNI: '#FF007A', AAVE: '#B6509E', MKR: '#1AAB9B', SNX: '#00D1FF',
  COMP: '#00D395', YFI: '#006AE3', CRV: '#FF4C4C', BAL: '#1E1E1E',
  SUSHI: '#FA52A0', MATIC: '#8247E5', ARB: '#28A0F0', OP: '#FF0420'
};
const OPS = ['<', '>', '', '', '=', ''];

function parseCalldata(calldata, targetAddr) {
  if (calldata && typeof calldata !== 'string') {
    try { calldata = ethers.hexlify(calldata); } catch { calldata = ''; }
  }
  calldata = calldata || '';
  const swissKnifeUrl = calldata && calldata !== '0x' && calldata.length > 2
    ? `https://calldata.swiss-knife.xyz/decoder?calldata=${calldata}` : null;
  if (!calldata || calldata === '0x' || calldata.length < 10) {
    return { parsed: `ETH balance of ${etherscanLink(targetAddr, { color: '#627EEA' })}`, raw: '(none - ETH balance)', swissKnifeUrl: null };
  }
  const selector = calldata.slice(0, 10).toLowerCase();
  if (selector === '0x70a08231' && calldata.length >= 74) {
    const account = '0x' + calldata.slice(34, 74);
    return { parsed: `balanceOf(${etherscanLink(account)})`, raw: calldata, swissKnifeUrl };
  }
  if (selector === '0x18160ddd') return { parsed: 'totalSupply()', raw: calldata, swissKnifeUrl };
  if (selector === '0x50d25bcd') return { parsed: 'latestAnswer() <span style="opacity:0.5">(Chainlink)</span>', raw: calldata, swissKnifeUrl };
  if (selector === '0xfeaf968c') return { parsed: 'latestRoundData() <span style="opacity:0.5">(Chainlink)</span>', raw: calldata, swissKnifeUrl };
  if (selector === '0xf02de3b2') return { parsed: 'protocolFeeController() <span style="opacity:0.5">(Uniswap V4)</span>', raw: calldata, swissKnifeUrl, functionName: 'protocolFeeController' };
  return { parsed: null, raw: calldata, swissKnifeUrl };
}

function formatCalldataHtml(calldata, targetAddr, label) {
  if (calldata && typeof calldata !== 'string') {
    try { calldata = ethers.hexlify(calldata); } catch { calldata = ''; }
  }
  calldata = calldata || '';
  if (!calldata || calldata === '0x' || calldata.length < 10) {
    if (targetAddr && targetAddr !== ethers.ZeroAddress) {
      return `<div class="inspect-row"><span class="inspect-label">${label}</span><span class="inspect-value">ETH balance of ${etherscanLink(targetAddr)}</span></div>`;
    }
    return `<div class="inspect-row"><span class="inspect-label">${label}</span><span class="inspect-value">(empty)</span></div>`;
  }
  const parsed = parseCalldata(calldata, targetAddr);
  let html = '';
  if (parsed.parsed) {
    html += `<div class="inspect-row"><span class="inspect-label">${label}</span><span class="inspect-value">${parsed.parsed}</span></div>`;
  }
  const rawDisplay = parsed.raw.length > 20 ? parsed.raw.slice(0, 20) + '...' : parsed.raw;
  const swissLink = parsed.swissKnifeUrl ? ` <a href="${parsed.swissKnifeUrl}" target="_blank" rel="noopener" title="Decode on SwissKnife" style="opacity:0.7">decode</a>` : '';
  html += `<div class="inspect-row"><span class="inspect-label">${parsed.parsed ? '' : label}</span><span class="inspect-value" title="${parsed.raw}">${rawDisplay}${swissLink}</span></div>`;
  return html;
}

function formatCloseDate(timestamp) {
  const d = new Date(timestamp * 1000);
  const now = new Date();
  if (d.getFullYear() === now.getFullYear()) {
    return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
  }
  return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
}

function formatBalance(val, decimals = 1) {
  if (val >= 1e9) return `${(val/1e9).toFixed(1)}B`;
  if (val >= 1e6) return `${(val/1e6).toFixed(1)}M`;
  if (val >= 1000) return `${(val/1000).toFixed(1)}K`;
  return val.toFixed(decimals);
}

function stripHtml(s) { return s.replace(/<[^>]*>/g, ''); }
function cardHtml(s) {
  // Strip SVGs and <a> links (can't nest inside <a> cards) but keep <u> highlighting
  return s.replace(/<svg[^>]*>[\s\S]*?<\/svg>/gi, '')
          .replace(/<a[^>]*>([\s\S]*?)<\/a>/gi, '$1')
          .replace(/<span[^>]*>\.{3}<\/span>/gi, '');
}

function showRawTooltip(el, text) {
  let tooltip = document.getElementById('rawHintTooltip');
  if (!tooltip) {
    tooltip = document.createElement('div');
    tooltip.id = 'rawHintTooltip';
    tooltip.style.cssText = 'position:fixed;background:#111;border:1px solid #333;color:#888;padding:8px 12px;font-size:10px;max-width:400px;word-break:break-word;white-space:pre-wrap;z-index:9999;border-radius:4px;box-shadow:0 2px 8px rgba(0,0,0,0.5)';
    document.body.appendChild(tooltip);
  }
  if (tooltip.style.display === 'block' && tooltip._sourceEl === el) {
    tooltip.style.display = 'none';
    return;
  }
  const rect = el.getBoundingClientRect();
  tooltip.textContent = text.replace(/&quot;/g, '"');
  tooltip.style.display = 'block';
  tooltip._sourceEl = el;
  tooltip.style.left = Math.min(rect.left, window.innerWidth - 420) + 'px';
  tooltip.style.top = (rect.bottom + 8) + 'px';
}

function parseMarketDescription(description) {
  if (!description) return { question: 'Unknown market', color: '#627EEA', threshold: 0, raw: '' };

  let displayDesc = description;
  let threshold = 0;
  const qMatch = description.match(/^(.+?\?)/);
  if (qMatch) displayDesc = qMatch[1];
  else if (description.length > 100) displayDesc = description.slice(0, 97) + '...';

  const defaults = { question: escText(displayDesc), color: '#888', threshold, raw: description };
  try {
    const p = description.split('|');
    const type = p[0];

    // PRICE|ASSET|QUOTE|OP|THRESHOLD|CLOSE
    if (type === 'PRICE' && p.length >= 6) {
      const [, asset, quote, op, thresh, close] = p;
      const t = parseInt(thresh);
      const price = formatPrice(t);
      const date = formatCloseDate(parseInt(close));
      const opNum = parseInt(op);
      const verb = (opNum === 0 || opNum === 2) ? 'drop to' : 'hit';
      const color = COLORS[asset] || '#627EEA';
      return {
        question: `<u style="text-decoration-color:${color}">${asset}</u> ${verb} <u style="text-decoration-color:#0F0">${price}</u> by <u style="text-decoration-color:#F50">${date}</u>?`,
        color, threshold: t, raw: description
      };
    }

    // ETHBAL|ADDRESS|OP|THRESHOLD|CLOSE
    if (type === 'ETHBAL' && p.length >= 5) {
      const [, addr, op, thresh, close] = p;
      const t = parseFloat(thresh);
      const bal = formatBalance(t);
      const date = formatCloseDate(parseInt(close));
      const opNum = parseInt(op);
      const verb = (opNum === 0 || opNum === 2) ? 'have under' : 'hold';
      const addrLink = etherscanLink(addr, { color: '#627EEA' });
      return {
        question: `${addrLink} ${verb} <u style="text-decoration-color:#0F0">${bal} ETH</u> by <u style="text-decoration-color:#F50">${date}</u>?`,
        color: '#627EEA', threshold: t, raw: description
      };
    }

    // TOKBAL|TOKEN|ADDRESS|OP|THRESHOLD|CLOSE
    if (type === 'TOKBAL' && p.length >= 6) {
      const [, token, addr, op, thresh, close] = p;
      const t = parseFloat(thresh);
      const bal = formatBalance(t, 0);
      const date = formatCloseDate(parseInt(close));
      const opNum = parseInt(op);
      const verb = (opNum === 0 || opNum === 2) ? 'have under' : 'hold';
      const addrLink = etherscanLink(addr, { color: '#8247E5' });
      const tokenLink = etherscanLink(token, { color: '#FF007A', type: 'token' });
      return {
        question: `${addrLink} ${verb} <u style="text-decoration-color:#0F0">${bal}</u> ${tokenLink} by <u style="text-decoration-color:#F50">${date}</u>?`,
        color: '#8247E5', threshold: t, raw: description
      };
    }

    // NFTBAL|TOKEN|ADDRESS|OP|THRESHOLD|CLOSE
    if (type === 'NFTBAL' && p.length >= 6) {
      const [, token, addr, op, thresh, close] = p;
      const t = parseInt(thresh);
      const date = formatCloseDate(parseInt(close));
      const opNum = parseInt(op);
      const verb = (opNum === 0 || opNum === 2) ? 'have under' : 'hold';
      const addrLink = etherscanLink(addr, { color: '#8247E5' });
      const tokenLink = etherscanLink(token, { color: '#e8e8e0', type: 'token' });
      return {
        question: `${addrLink} ${verb} <u style="text-decoration-color:#0F0">${t}</u> ${tokenLink} NFTs by <u style="text-decoration-color:#F50">${date}</u>?`,
        color: '#8247E5', threshold: t, raw: description
      };
    }

    // GAS|SUBTYPE|...params...|CLOSE
    if (type === 'GAS' && p.length >= 4) {
      const [, subtype, ...rest] = p;
      const close = rest[rest.length - 1];
      const date = formatCloseDate(parseInt(close));
      let q, thresh = parseFloat(rest[0]);
      if (subtype === 'RANGE') {
        const [lower, upper] = rest;
        q = `<u style="text-decoration-color:#FF6B6B">GAS</u> stay in <u style="text-decoration-color:#0F0">${lower}-${upper} gwei</u> by <u style="text-decoration-color:#F50">${date}</u>?`;
        thresh = parseFloat(lower);
      } else {
        const labels = { TWAP: 'avg', PEAK: 'spike to', TROUGH: 'dip to', VOL: 'swing', VOLATILITY: 'swing' };
        const label = labels[subtype] || subtype.toLowerCase();
        q = `<u style="text-decoration-color:#FF6B6B">GAS</u> ${label} <u style="text-decoration-color:#0F0">${rest[0]} gwei</u> by <u style="text-decoration-color:#F50">${date}</u>?`;
      }
      return { question: q, color: '#FF6B6B', threshold: thresh, raw: description };
    }

    // SUPPLY|TOKEN|OP|THRESHOLD|CLOSE
    if (type === 'SUPPLY' && p.length >= 5) {
      const [, token, op, thresh, close] = p;
      const t = parseFloat(thresh);
      const date = formatCloseDate(parseInt(close));
      const opNum = parseInt(op);
      const verb = (opNum === 0 || opNum === 2) ? 'drop below' : 'exceed';
      const tokenLink = etherscanLink(token, { color: '#9945FF', type: 'token' });
      return {
        question: `${tokenLink} supply ${verb} <u style="text-decoration-color:#0F0">${formatBalance(t)}</u> by <u style="text-decoration-color:#F50">${date}</u>?`,
        color: '#9945FF', threshold: t, raw: description
      };
    }

    // LEGACY|TOKEN_SYMBOL|TARGET|OP|THRESHOLD|CLOSE
    if (type === 'LEGACY' && p.length >= 6) {
      const [, tokenSym, target, op, thresh, close] = p;
      const t = parseFloat(thresh);
      const bal = formatBalance(t, 0);
      const date = formatCloseDate(parseInt(close));
      const opNum = parseInt(op);
      const opText = OPS[opNum] || '';
      const shortTarget = `${target.slice(0,6)}...${target.slice(-4)}`;
      const color = COLORS[tokenSym] || '#375BD2';
      return {
        question: `<u style="text-decoration-color:${color}">${shortTarget}</u> bal on <u style="text-decoration-color:${color}">${tokenSym}</u><br>reaches ${opText} <u style="text-decoration-color:#0F0">${bal} ${tokenSym}</u><br>by <u style="text-decoration-color:#F50">${date}</u>`,
        color, threshold: t, raw: description, isLegacy: true
      };
    }

    // totalSupply pattern: "zOrgz totalSupply >= 10000 by 1769288092 Unix time..."
    const totalSupplyMatch = description.match(/^(\w+)\s+totalSupply\s*(>=|<=|>|<|=|!=)\s*(\d+)\s*by\s*(\d+)\s*Unix time/i);
    if (totalSupplyMatch) {
      const [, name, op, value, timestamp] = totalSupplyMatch;
      const val = parseInt(value);
      const lowerName = name.toLowerCase();
      let color = '#9945FF';
      if (lowerName === 'zorgz') color = '#e8e8e0';
      const opMap = { '>=': '', '<=': '', '!=': '', '>': '>', '<': '<', '=': '=' };
      const valText = val >= 1e6 ? `${(val/1e6).toFixed(1)}M` : val >= 1000 ? `${(val/1000).toFixed(1)}K` : val.toString();
      const dateText = formatCloseDate(parseInt(timestamp));
      const nftLogo = TOKEN_LOGOS[lowerName] || '';
      const rawTooltip = description.replace(/"/g, '&quot;');
      return {
        question: `${nftLogo}<u style="text-decoration-color:${color}">${name}</u> mint ${opMap[op]||op} <u style="text-decoration-color:#0F0">${valText}</u> by <u style="text-decoration-color:#F50">${dateText}</u>? <span onclick="event.stopPropagation();showRawTooltip(this,'${rawTooltip}')" title="${rawTooltip}" style="opacity:0.4;cursor:help;font-size:9px">...</span>`,
        color, threshold: val, raw: description
      };
    }

    // uniPM patterns: V4 Protocol, UNI balance/voting/supply/price
    const uniPMPatterns = [
      { prefix: 'V4 Protocol', label: 'V4 FEE SWITCH', color: '#FF007A' },
      { prefix: 'UNI balance', label: 'UNI BALANCE', color: '#FF007A' },
      { prefix: 'UNI voting power', label: 'UNI VOTING POWER', color: '#FF007A' },
      { prefix: 'UNI totalSupply', label: 'UNI SUPPLY', color: '#FF007A' },
      { prefix: 'UNI price', label: 'UNI PRICE', color: '#FF007A' }
    ];
    for (const pattern of uniPMPatterns) {
      if (description.startsWith(pattern.prefix)) {
        const condMatch = description.match(/(.+?)\s*(!=|>=|<=|>|<|=)\s*(\d+(?:\.\d+)?)\s*(?:by\s+(.+))?$/i);
        if (condMatch) {
          const [, subject, op, value, dateStr] = condMatch;
          const val = parseFloat(value);
          let conditionHtml;
          if (val === 0 && (op === '!=' || op === '=')) {
            conditionHtml = `<u style="text-decoration-color:#0F0">${op === '!=' ? 'on' : 'off'}</u>`;
          } else {
            const opMap = { '!=': '', '>=': '', '<=': '' };
            const opText = opMap[op] || op;
            conditionHtml = `${opText} <u style="text-decoration-color:#0F0">${formatBalance(val, val < 1 ? 2 : 0)}</u>`;
          }
          let dateHtml = '';
          if (dateStr) {
            const d = new Date(dateStr);
            if (!isNaN(d)) {
              let displayDate = d;
              if (d.getDate() >= 28) displayDate = new Date(d.getFullYear(), d.getMonth() + 1, 1);
              dateHtml = ` by <u style="text-decoration-color:#F50">${displayDate.toLocaleDateString('en-US', { month: 'short', year: 'numeric' })}</u>`;
            } else {
              dateHtml = ` by <u style="text-decoration-color:#F50">${dateStr}</u>`;
            }
          }
          const rawTooltip = description.replace(/"/g, '&quot;');
          return {
            question: `<u style="text-decoration-color:${pattern.color}">${pattern.label}</u> ${conditionHtml}${dateHtml}? <span onclick="event.stopPropagation();showRawTooltip(this,'${rawTooltip}')" title="${rawTooltip}" style="opacity:0.4;cursor:help;font-size:9px">...</span>`,
            color: pattern.color, threshold: val, raw: description
          };
        }
        const rest = description.slice(pattern.prefix.length).trim();
        return { question: `<u style="text-decoration-color:${pattern.color}">${pattern.label}</u> ${rest}`, color: pattern.color, threshold: 0, raw: description };
      }
    }
  } catch (e) { console.warn('Parse error:', e); }
  return defaults;
}

// ==================== AMM MATH ====================

function quoteBuyYes(collateralInWei, rYes, rNo, feeBps) {
  if (rYes === 0n || rNo === 0n) return 0n;
  feeBps = feeBps || LEGACY_FEE_BPS;
  const mintedShares = collateralInWei;
  const feeMultiplier = 10000n - BigInt(feeBps);
  const swapInputWithFee = collateralInWei * feeMultiplier / 10000n;
  const swappedYes = (swapInputWithFee * rYes) / (rNo + swapInputWithFee);
  return mintedShares + swappedYes;
}

function quoteBuyNo(collateralInWei, rYes, rNo, feeBps) {
  if (rYes === 0n || rNo === 0n) return 0n;
  feeBps = feeBps || LEGACY_FEE_BPS;
  const mintedShares = collateralInWei;
  const feeMultiplier = 10000n - BigInt(feeBps);
  const swapInputWithFee = collateralInWei * feeMultiplier / 10000n;
  const swappedNo = (swapInputWithFee * rNo) / (rYes + swapInputWithFee);
  return mintedShares + swappedNo;
}

function quoteSellYes(sharesInWei, rYes, rNo, feeBps) {
  if (rYes === 0n || rNo === 0n) return 0n;
  feeBps = feeBps || LEGACY_FEE_BPS;
  const feeMultiplier = 10000n - BigInt(feeBps);
  const amountInWithFee = sharesInWei * feeMultiplier / 10000n;
  const noOut = (amountInWithFee * rNo) / (rYes + amountInWithFee);
  return noOut < sharesInWei ? noOut : sharesInWei;
}

function quoteSellNo(sharesInWei, rYes, rNo, feeBps) {
  if (rYes === 0n || rNo === 0n) return 0n;
  feeBps = feeBps || LEGACY_FEE_BPS;
  const feeMultiplier = 10000n - BigInt(feeBps);
  const amountInWithFee = sharesInWei * feeMultiplier / 10000n;
  const yesOut = (amountInWithFee * rYes) / (rNo + amountInWithFee);
  return yesOut < sharesInWei ? yesOut : sharesInWei;
}

// ==================== STATE ====================

let markets = [];
let _walletProvider = null;
let _signer = null;
let _connectedAddress = null;
let _tradeDir = 'buy';
let _tradeSide = 'yes';
let _quoteTimer = null;
let _lastQuote = null;
let _isTrading = false;
let _tradeSlippage = 5; // default 5% slippage tolerance
let _galleryFilter = 'active'; // 'active' | 'resolved' | 'all'
let _currentMarketType = 'price'; // 'price' | 'balance' | 'supply'
let _balanceAssetType = 'eth'; // 'eth' | 'token'
let _balanceDir = 'above'; // 'above' | 'below'
let _currentEthPrice = 0;
let _balTokenData = { address: '', symbol: '', decimals: 18 };
let _supplyTokenData = { address: '', symbol: '', decimals: 18 };

// ==================== WALLET ====================

let _connectedWalletProvider = null;
let _walletConnectProvider = null;
let _isConnecting = false;
let _walletEventHandlers = null;
let _isWalletConnect = false;
let _wcDeepLink = null;

const eip6963Providers = new Map();
window.addEventListener('eip6963:announceProvider', (event) => {
  try {
    const { info, provider } = event.detail || {};
    if (info?.uuid && provider) eip6963Providers.set(info.uuid, { info, provider });
  } catch (e) {}
});
window.dispatchEvent(new Event('eip6963:requestProvider'));

function findProvider(checkFn) {
  if (window.ethereum?.providers?.length) {
    for (const p of window.ethereum.providers) { if (checkFn(p)) return p; }
  }
  if (window.ethereum && checkFn(window.ethereum)) return window.ethereum;
  return null;
}

const WALLET_CONFIG = {
  metamask: { name: 'MetaMask', icon: '', detect: () => findProvider(p => p.isMetaMask), getProvider: () => findProvider(p => p.isMetaMask) },
  coinbase: { name: 'Coinbase', icon: '', detect: () => findProvider(p => p.isCoinbaseWallet), getProvider: () => findProvider(p => p.isCoinbaseWallet) },
  rabby: { name: 'Rabby', icon: '', detect: () => findProvider(p => p.isRabby), getProvider: () => findProvider(p => p.isRabby) },
  rainbow: { name: 'Rainbow', icon: '', detect: () => findProvider(p => p.isRainbow), getProvider: () => findProvider(p => p.isRainbow) },
  walletconnect: { name: 'WalletConnect', icon: '' }
};

function detectWallets() {
  const detected = [];
  const seenNames = new Set();
  for (const [uuid, { info, provider }] of eip6963Providers.entries()) {
    const name = info?.name || 'Unknown';
    if (!seenNames.has(name.toLowerCase())) {
      const iconUrl = info.icon && (info.icon.startsWith('data:image/') || info.icon.startsWith('https://')) ? info.icon : null;
      const safeIconUrl = iconUrl ? iconUrl.replace(/[<>&"']/g, c => ({'<':'&lt;','>':'&gt;','&':'&amp;','"':'&quot;',"'":'&#39;'}[c])) : null;
      detected.push({ key: `eip6963_${uuid}`, name, icon: safeIconUrl ? `<img src="${safeIconUrl}" style="width:1.5rem;height:1.5rem;border-radius:4px;">` : '', getProvider: () => provider });
      seenNames.add(name.toLowerCase());
    }
  }
  if (window.ethereum?.providers?.length) {
    for (let i = 0; i < window.ethereum.providers.length; i++) {
      const p = window.ethereum.providers[i];
      const name = p.isMetaMask ? 'MetaMask' : p.isCoinbaseWallet ? 'Coinbase' : p.isRabby ? 'Rabby' : p.isRainbow ? 'Rainbow' : null;
      if (name && !seenNames.has(name.toLowerCase())) { detected.push({ key: `provider_${i}`, name, icon: '', getProvider: () => p }); seenNames.add(name.toLowerCase()); }
    }
  }
  for (const [key, config] of Object.entries(WALLET_CONFIG)) {
    if (key === 'walletconnect') continue;
    try { if (config.detect && config.detect() && !seenNames.has(config.name.toLowerCase())) { detected.push({ key, ...config }); seenNames.add(config.name.toLowerCase()); } } catch (e) {}
  }
  if (detected.length === 0 && window.ethereum) detected.push({ key: 'injected', name: 'Browser Wallet', icon: '', getProvider: () => window.ethereum });
  const wcModule = globalThis['@walletconnect/ethereum-provider'];
  if (wcModule?.EthereumProvider) detected.push({ key: 'walletconnect', name: 'WalletConnect', icon: '' });
  return detected;
}

function showWalletModal() {
  $('walletModal').classList.add('active');
  document.body.classList.add('modal-open');
  $('walletOptions').innerHTML = '<div style="padding:12px;text-align:center;">Detecting wallets...</div>';
  window.dispatchEvent(new Event('eip6963:requestProvider'));
  const doDetect = (attempt = 1) => {
    const wallets = detectWallets();
    if (!wallets.some(w => w.key !== 'walletconnect') && attempt < 2) setTimeout(() => doDetect(attempt + 1), 250);
    else renderWalletModal(wallets);
  };
  setTimeout(() => doDetect(), 150);
}

function renderWalletModal(wallets) {
  const container = $('walletOptions');
  if (_connectedAddress) {
    const displayName = $('walletBtn').textContent;
    const showName = displayName && displayName !== 'connect' && !displayName.startsWith('0x');
    container.innerHTML = `<div style="padding:12px;border:1px solid currentColor;margin-bottom:12px;"><div style="font-weight:600;margin-bottom:6px;">Connected</div>${showName ? `<div style="font-size:16px;margin-bottom:4px;">${escText(displayName)}</div>` : ''}<div style="font-size:12px;word-break:break-all;opacity:0.6;">${escText(_connectedAddress)}</div></div><div id="walletResolverFee" style="padding:0 12px 12px"><a href="#" style="font-size:12px;color:var(--fg-muted)" onclick="event.preventDefault();const p=this.nextElementSibling;p.style.display=p.style.display==='none'?'block':'none'">Resolver Fee</a><div style="display:none;margin-top:8px"><div id="walletResolverFeeLabel" style="font-size:11px;color:var(--fg-dim);margin-bottom:6px">Loading...</div><div style="display:flex;align-items:center;gap:8px"><input class="form-input" id="walletResolverFeeInput" type="number" min="0" max="10" step="0.01" placeholder="0.00" style="width:80px;padding:6px 8px;font-size:13px" oninput="if(this.value>10)this.value=10"><span style="font-size:12px;color:var(--fg-muted)">%</span><button class="btn" style="font-size:12px;padding:6px 12px;white-space:nowrap" onclick="submitResolverFee()">Set</button></div></div></div><div class="wallet-option disconnect" onclick="disconnectWallet()"><span class="wallet-option-name">Disconnect</span></div>`;
    getResolverFeeBps(_connectedAddress).then(bps => { const lbl = $('walletResolverFeeLabel'); if (lbl) lbl.textContent = bps > 0 ? 'Current fee: ' + (bps / 100).toFixed(2) + '%' : 'No fee set'; });
  } else {
    container.innerHTML = wallets.length > 0 ? wallets.map(w => `<div class="wallet-option" data-wallet-key="${escAttr(w.key)}"><span class="wallet-option-icon">${w.icon}</span><span class="wallet-option-name">${escText(w.name)}</span></div>`).join('') : '<div style="padding:12px;text-align:center;">No wallets detected.</div>';
    container.querySelectorAll('[data-wallet-key]').forEach(el => { el.addEventListener('click', () => connectWithWallet(el.dataset.walletKey)); });
  }
}

function closeWalletModal() { $('walletModal').classList.remove('active'); document.body.classList.remove('modal-open'); }
function toggleWallet() { showWalletModal(); }

async function connectWithWallet(walletKey) {
  if (_isConnecting) return;
  _isConnecting = true;
  try {
    closeWalletModal();
    let walletProvider;
    if (walletKey === 'walletconnect') {
      const wcModule = globalThis['@walletconnect/ethereum-provider'];
      const WCProvider = wcModule?.EthereumProvider;
      if (!WCProvider?.init) throw new Error('WalletConnect not available');
      if (_walletConnectProvider) { try { await _walletConnectProvider.disconnect?.(); } catch (e) {} _walletConnectProvider = null; }
      _walletConnectProvider = await WCProvider.init({ projectId: '1e8390ef1c1d8a185e035912a1409749', chains: [1], showQrModal: true, rpcMap: { 1: 'https://1rpc.io/eth' }, metadata: { name: 'zFi Predict', description: 'Prediction markets', url: window.location.origin, icons: [] } });
      _walletConnectProvider.on('display_uri', () => { try { const s = _walletConnectProvider.session?.peer?.metadata; if (s?.redirect?.native && /^https?:\/\//i.test(s.redirect.native)) _wcDeepLink = s.redirect.native; else if (s?.redirect?.universal && /^https?:\/\//i.test(s.redirect.universal)) _wcDeepLink = s.redirect.universal; } catch (e) {} });
      await _walletConnectProvider.enable();
      walletProvider = _walletConnectProvider;
      _isWalletConnect = true;
    } else if (walletKey.startsWith('eip6963_')) {
      const uuid = walletKey.replace('eip6963_', '');
      walletProvider = eip6963Providers.get(uuid)?.provider;
      if (!walletProvider) { const savedName = localStorage.getItem('zfi_wallet_name')?.toLowerCase(); if (savedName) { for (const [, { info, provider }] of eip6963Providers) { if (info?.name?.toLowerCase() === savedName) { walletProvider = provider; break; } } } }
      _isWalletConnect = false; _wcDeepLink = null;
    } else {
      walletProvider = WALLET_CONFIG[walletKey]?.getProvider() || window.ethereum;
      _isWalletConnect = false; _wcDeepLink = null;
    }
    if (!walletProvider) throw new Error('Wallet not found');
    if (walletKey !== 'walletconnect') await walletProvider.request({ method: 'eth_requestAccounts' });
    const chainId = await walletProvider.request({ method: 'eth_chainId' });
    if (BigInt(chainId) !== 1n) {
      try { await walletProvider.request({ method: 'wallet_switchEthereumChain', params: [{ chainId: '0x1' }] }); const nc = await walletProvider.request({ method: 'eth_chainId' }); if (BigInt(nc) !== 1n) throw new Error('Chain switch failed'); }
      catch (switchErr) { console.error('Chain switch failed:', switchErr); $('walletBtn').textContent = 'connect'; if (walletKey === 'walletconnect') { try { _walletConnectProvider?.disconnect(); } catch (e) {} _walletConnectProvider = null; } _isWalletConnect = false; _wcDeepLink = null; return; }
    }
    _walletProvider = new ethers.BrowserProvider(walletProvider);
    _signer = await _walletProvider.getSigner();
    _connectedAddress = await _signer.getAddress();
    const oldWP = _connectedWalletProvider;
    _connectedWalletProvider = walletProvider;
    $('walletBtn').textContent = _connectedAddress.slice(0, 6) + '...' + _connectedAddress.slice(-4);
    resolveWeiName(_connectedAddress);
    updateWcBanner();
    updateResolverFeeSection();
    // Re-render market page so resolver/position sections update with connected address
    const _hash = location.hash.replace('#', '').trim();
    if (_hash && /^\d+$/.test(_hash)) renderMarketPage(_hash);
    if (oldWP && _walletEventHandlers) { try { oldWP.removeListener('accountsChanged', _walletEventHandlers.accountsChanged); oldWP.removeListener('chainChanged', _walletEventHandlers.chainChanged); } catch (e) {} }
    _walletEventHandlers = { accountsChanged: () => window.location.reload(), chainChanged: () => window.location.reload() };
    walletProvider.on('accountsChanged', _walletEventHandlers.accountsChanged);
    walletProvider.on('chainChanged', _walletEventHandlers.chainChanged);
    try { localStorage.setItem('zfi_wallet', walletKey); if (walletKey.startsWith('eip6963_')) { const uuid = walletKey.replace('eip6963_', ''); const name = eip6963Providers.get(uuid)?.info?.name; if (name) localStorage.setItem('zfi_wallet_name', name); } } catch (e) {}
  } catch (error) {
    if (isUserRejection(error)) {
      // User cancelled - silently ignore
    } else {
      console.error('Wallet connect error:', error);
      $('walletBtn').textContent = 'connect';
    }
  } finally { _isConnecting = false; }
}

function disconnectWallet() {
  if (_connectedWalletProvider && _walletEventHandlers) { try { _connectedWalletProvider.removeListener('accountsChanged', _walletEventHandlers.accountsChanged); _connectedWalletProvider.removeListener('chainChanged', _walletEventHandlers.chainChanged); } catch (e) {} }
  _walletEventHandlers = null;
  if (_walletConnectProvider) { try { _walletConnectProvider.disconnect(); } catch (e) {} _walletConnectProvider = null; }
  _walletProvider = null; _signer = null; _connectedAddress = null; _connectedWalletProvider = null; _isWalletConnect = false; _wcDeepLink = null;
  $('walletBtn').textContent = 'connect';
  updateWcBanner();
  updateResolverFeeSection();
  closeWalletModal();
  try { localStorage.removeItem('zfi_wallet'); localStorage.removeItem('zfi_wallet_name'); } catch (e) {}
}

// Compatibility wrapper  existing code calls connectWallet()
async function connectWallet() {
  if (_signer) return _signer;
  showWalletModal();
  return null;
}

function resolveWeiName(addr) {
  try {
    const rpc = new ethers.JsonRpcProvider(RPCS[0], 1, { staticNetwork: true });
    const ns = new ethers.Contract(WEINS, WEINS_ABI, rpc);
    ns.reverseResolve(addr).then(name => { if (name && _connectedAddress === addr) $('walletBtn').textContent = name.toLowerCase(); }).catch(() => {});
  } catch (e) {}
}

function updateWcBanner() {
  const existing = document.getElementById('wcBanner');
  if (existing) existing.remove();
  if (_isWalletConnect && _connectedAddress) {
    const banner = document.createElement('div');
    banner.id = 'wcBanner';
    banner.style.cssText = 'position:fixed;top:0;left:0;right:0;background:#1a1a2e;color:#fff;padding:10px 16px;display:flex;justify-content:space-between;align-items:center;z-index:9000;font-size:13px;';
    banner.innerHTML = '<span> Connected via WalletConnect</span><button onclick="disconnectWallet()" style="background:#fff;color:#000;border:none;padding:6px 12px;border-radius:0;cursor:pointer;font-size:12px;">Disconnect</button>';
    document.body.prepend(banner);
    document.body.style.paddingTop = '54px';
  } else {
    document.body.style.paddingTop = '';
  }
}

async function tryAutoConnect() {
  const savedWallet = localStorage.getItem('zfi_wallet');
  if (!savedWallet) return;
  $('walletBtn').textContent = '...';
  setTimeout(async () => {
    try {
      window.dispatchEvent(new Event('eip6963:requestProvider'));
      await new Promise(r => setTimeout(r, 300));
      // Silent check: only auto-connect if wallet already unlocked
      let probe;
      if (savedWallet.startsWith('eip6963_')) {
        const uuid = savedWallet.replace('eip6963_', '');
        probe = eip6963Providers.get(uuid)?.provider;
        if (!probe) {
          const savedName = localStorage.getItem('zfi_wallet_name')?.toLowerCase();
          if (savedName) {
            for (const [, { info, provider }] of eip6963Providers) {
              if (info?.name?.toLowerCase() === savedName) { probe = provider; break; }
            }
          }
        }
      } else if (savedWallet !== 'walletconnect') {
        probe = WALLET_CONFIG[savedWallet]?.getProvider() || window.ethereum;
      }
      if (probe) {
        const accts = await probe.request({ method: 'eth_accounts' });
        if (!accts || accts.length === 0) {
          $('walletBtn').textContent = 'connect';
          return;
        }
      }
      await connectWithWallet(savedWallet);
    } catch (e) {
      console.error('Auto-reconnect failed:', e);
      $('walletBtn').textContent = 'connect';
    }
  }, 100);
}

// ==================== ROUTER ====================

function route() {
  const hash = location.hash.replace('#', '').trim();
  if (hash && /^\d+$/.test(hash)) {
    renderMarketPage(hash);
  } else if (hash === 'create') {
    renderGallery().then(() => applyCreateDeeplink());
  } else {
    renderGallery();
  }
}

function applyCreateDeeplink() {
  _applyingDeeplink = true;
  const params = new URLSearchParams(location.search);
  const type = params.get('type'); // price, balance, supply, custom
  if (type && ['price','balance','supply','custom'].includes(type)) {
    switchMarketType(type);
  }
  // Price form
  if (params.get('target'))   { const el = $('targetPrice'); if (el) { el.value = params.get('target'); fmtTargetPrice(); } }
  if (params.get('dir'))      { const d = params.get('dir'); if (d === 'up' || d === 'down') setPriceDir(d); }
  if (params.get('close'))    { const el = $('closeDate'); if (el) el.value = params.get('close'); }
  // Balance form
  if (params.get('balDir'))   { const d = params.get('balDir'); if (d === 'above' || d === 'below') setBalanceDir(d); }
  if (params.get('wallet'))   { const el = $('balWalletAddr'); if (el) { el.value = params.get('wallet'); onBalWalletInput(); } }
  if (params.get('token'))    { const el = $('balTokenAddr'); if (el) { el.value = params.get('token'); setBalanceType('token'); } }
  if (params.get('bal'))      { const el = $('balThreshold'); if (el) el.value = params.get('bal'); }
  if (params.get('balClose')) { const el = $('balCloseDate'); if (el) el.value = params.get('balClose'); }
  // Supply form
  if (params.get('supplyToken')) { const el = $('supplyTokenAddr'); if (el) el.value = params.get('supplyToken'); }
  if (params.get('supplyOp'))    { const el = $('supplyOp'); if (el) el.value = params.get('supplyOp'); }
  if (params.get('supplyVal'))   { const el = $('supplyThreshold'); if (el) el.value = params.get('supplyVal'); }
  if (params.get('supplyClose')) { const el = $('supplyCloseDate'); if (el) el.value = params.get('supplyClose'); }
  // Custom form
  if (params.get('question')) { const el = $('customQuestion'); if (el) el.value = params.get('question'); }
  if (params.get('resolver')) { const el = $('customResolver'); if (el) { el.value = params.get('resolver'); onResolverInput(); } }
  if (params.has('canClose')) { const el = $('customCanClose'); if (el) el.checked = params.get('canClose') !== '0'; }
  if (params.get('customClose')) { const el = $('customCloseDate'); if (el) el.value = params.get('customClose'); }
  // Liquidity
  if (params.get('liq'))      { const el = $('totalLiquidity'); if (el) { el.value = params.get('liq'); updateLiqSplit(); } }
  // Update previews
  updatePricePreview();
  updateBalPreview();
  updateSupplyPreview();
  updateCustomPreview();
  _applyingDeeplink = false;
  openCreateModal();
}
let _applyingDeeplink = false;

function updateCreateDeeplink() {
  if (_applyingDeeplink) return;
  if (location.hash.replace('#','').trim() !== 'create') return;
  const p = new URLSearchParams();
  const type = _currentMarketType || 'price';
  if (type !== 'price') p.set('type', type);
  if (type === 'price') {
    const raw = ($('targetPrice').value || '').replace(/[^0-9]/g, '');
    if (raw) p.set('target', raw);
    if (_priceDir === 'down') p.set('dir', 'down');
    const close = $('closeDate').value;
    if (close) p.set('close', close);
  } else if (type === 'balance') {
    const wallet = $('balWalletAddr').value.trim();
    if (wallet) p.set('wallet', wallet);
    if (_balanceDir === 'below') p.set('balDir', 'below');
    if (_balanceAssetType === 'token') {
      const tok = $('balTokenAddr').value.trim();
      if (tok) p.set('token', tok);
    }
    const bal = $('balThreshold').value;
    if (bal) p.set('bal', bal);
    const close = $('balCloseDate').value;
    if (close) p.set('balClose', close);
  } else if (type === 'supply') {
    const tok = $('supplyTokenAddr').value.trim();
    if (tok) p.set('supplyToken', tok);
    const op = $('supplyOp').value;
    if (op && op !== '3') p.set('supplyOp', op);
    const val = $('supplyThreshold').value;
    if (val) p.set('supplyVal', val);
    const close = $('supplyCloseDate').value;
    if (close) p.set('supplyClose', close);
  } else if (type === 'custom') {
    const q = $('customQuestion').value.trim();
    if (q) p.set('question', q);
    const r = $('customResolver').value.trim();
    if (r) p.set('resolver', r);
    if (!$('customCanClose').checked) p.set('canClose', '0');
    const close = $('customCloseDate').value;
    if (close) p.set('customClose', close);
  }
  const liq = $('totalLiquidity').value;
  if (liq && liq !== '0.01') p.set('liq', liq);
  const qs = p.toString();
  const url = location.pathname + (qs ? '?' + qs : '') + '#create';
  history.replaceState(null, '', url);
}

window.addEventListener('hashchange', route);

// ==================== GALLERY ====================

async function renderGallery() {
  document.title = 'PREDICT';
  const _nav = $('navOrderbook');
  if (_nav) _nav.href = '../orderbook/';
  const app = $('app');
  const createBtnHTML = '<button onclick="openCreateModal()" style="font-size:11px;padding:6px 14px">+ Create</button>';
  app.innerHTML = `
    <div class="header">
      <h1>Predict</h1>
      <div>${createBtnHTML}</div>
    </div>
    <div class="loading">${zfiLoadingSVG(48)}Loading markets...</div>
  `;

  try {
    // Check cache first for instant display
    let cached = null;
    try {
      const raw = localStorage.getItem('zfi_predict_markets');
      if (raw) {
        const parsed = JSON.parse(raw);
        if (Date.now() - parsed.ts < 120000) cached = parsed.data;
      }
    } catch {}

    if (cached && cached.length > 0) {
      markets = cached;
      renderGalleryUI();
    }

    // Fetch from chain using RPC with fallback
    let allFetched = [];
    let fetchSuccess = false;

    try {
      allFetched = await withRPC(async (rpc) => {
        const pamm = new ethers.Contract(CONTRACTS.PAMM, PAMM_ABI, rpc);
        const PAGE_SIZE = 50;
        let start = 0;
        let fetched = [];
        let firstPage = true;

        while (true) {
          let result;
          try {
            result = await pamm.getMarkets(start, PAGE_SIZE, { gasLimit: 5000000 });
          } catch (pageErr) {
            // First page failure = dead RPC, throw so withRPC retries next RPC
            if (firstPage) throw pageErr;
            // Later page failure = likely end of data, stop pagination
            break;
          }
          firstPage = false;
          const batchSize = result.marketIds.length;
          if (batchSize === 0) break;
          for (let i = 0; i < batchSize; i++) {
            const marketId = result.marketIds[i].toString();
            const resolver = result.resolvers[i];
            const description = result.descs[i];
            const close = Number(result.closes[i]);
            const tvl = Number(result.collateralAmounts[i]) / 1e18;
            const states = Number(result.states[i]);
            const resolved = (states & 1) !== 0;
            const outcome = (states & 2) !== 0;
            const parsed = parseMarketDescription(description);
            const legacy = LEGACY_MARKETS.some(l => l.marketId === marketId)
              || resolver.toLowerCase() === CONTRACTS.LEGACY_RESOLVER.toLowerCase()
              || description.startsWith('LEGACY|');
            fetched.push({
              marketId, description, close, tvl, resolved, outcome,
              question: parsed.question,
              collateral: result.collaterals[i],
              resolver,
              isLegacy: legacy,
              isLabeled: !legacy,
              y: 50, oddsLoaded: false
            });
          }
          if (batchSize < PAGE_SIZE) break;
          const next = Number(result.next);
          if (next === 0) break;
          start = next;
        }

        // Inject legacy markets (different resolver, must be loaded individually)
        for (const legacy of LEGACY_MARKETS) {
          if (fetched.find(m => m.marketId === legacy.marketId)) continue;
          try {
            const poolState = await pamm.getPoolState(BigInt(legacy.marketId), LEGACY_FEE_BPS);
            const rYes = Number(poolState.rYes) / 1e18;
            const rNo = Number(poolState.rNo) / 1e18;
            const tvl = rYes + rNo;
            const total = rYes + rNo;
            const yPct = total > 0 ? Math.round((rNo / total) * 100) : 50;

            const marketData = await pamm.getMarket(BigInt(legacy.marketId));
            const onChainDesc = marketData.description || '';
            const parsed = parseMarketDescription(onChainDesc);

            fetched.push({
              marketId: legacy.marketId,
              description: onChainDesc,
              close: Number(marketData.close) || legacy.close,
              tvl,
              resolved: marketData.resolved,
              outcome: marketData.outcome,
              question: parsed.question,
              collateral: marketData.collateral || legacy.collateral,
              resolver: marketData.resolver,
              isLegacy: true,
              isLabeled: false,
              y: yPct,
              oddsLoaded: true
            });
          } catch (e) {
            console.warn('Failed to inject legacy market:', legacy.marketId.slice(0, 8), e.message);
          }
        }

        return fetched;
      });
      fetchSuccess = true;
    } catch (fetchErr) {
      console.warn('getMarkets failed, using cache:', fetchErr.message);
    }

    if (fetchSuccess) {
      // Sort: active first by TVL, resolved by close date (most recent first)
      const now = Math.floor(Date.now() / 1000);
      allFetched.sort((a, b) => {
        const aActive = !a.resolved && a.close > now;
        const bActive = !b.resolved && b.close > now;
        if (aActive && !bActive) return -1;
        if (!aActive && bActive) return 1;
        if (aActive) return (b.tvl || 0) - (a.tvl || 0);
        return (b.close || 0) - (a.close || 0);
      });

      markets = allFetched;
      try {
        localStorage.setItem('zfi_predict_markets', JSON.stringify({ ts: Date.now(), data: markets }));
      } catch {}
      renderGalleryUI();

      // Batch fetch odds via multicall (dual path: getMarketSummary for labeled, getPoolState for legacy)
      const pammIface = new ethers.Interface(PAMM_ABI);
      const quoterIface = new ethers.Interface(QUOTER_ABI);
      const needsOdds = markets.filter(m => !m.oddsLoaded && !m.resolved);
      if (needsOdds.length > 0) {
        try {
          await withRPC(async (rpc) => {
            const calls = needsOdds.map(m => {
              if (m.isLegacy) {
                return {
                  target: CONTRACTS.PAMM,
                  callData: pammIface.encodeFunctionData('getPoolState', [BigInt(m.marketId), LEGACY_FEE_BPS]),
                  decode: data => pammIface.decodeFunctionResult('getPoolState', data),
                  market: m, isLabeled: false
                };
              } else {
                // getMarketSummary works for both our resolver and open resolver markets
                return {
                  target: CONTRACTS.QUOTER,
                  callData: quoterIface.encodeFunctionData('getMarketSummary', [m.marketId]),
                  decode: data => quoterIface.decodeFunctionResult('getMarketSummary', data),
                  market: m, isLabeled: true
                };
              }
            });
            const results = await multicall(calls, rpc);
            for (let i = 0; i < results.length; i++) {
              if (!results[i].success) continue;
              try {
                const decoded = results[i].decode();
                if (calls[i].isLabeled) {
                  calls[i].market.y = Math.round(Number(decoded.ammPriceYesBps) / 100);
                } else {
                  const rYes = Number(decoded.rYes);
                  const rNo = Number(decoded.rNo);
                  const total = rYes + rNo;
                  calls[i].market.y = total > 0 ? Math.round((rNo / total) * 100) : 50;
                }
                calls[i].market.oddsLoaded = true;
              } catch {}
            }
            return true;
          });
          try {
            localStorage.setItem('zfi_predict_markets', JSON.stringify({ ts: Date.now(), data: markets }));
          } catch {}
          renderGalleryUI();
        } catch (e) {
          console.warn('Batch odds fetch failed:', e.message);
        }
      }
    } else if (!markets.length) {
      app.innerHTML = `
        <div class="header"><h1>Predict</h1><div>${createBtnHTML}</div></div>
        <div class="loading">No markets found</div>
      `;
    }
  } catch (e) {
    console.warn('Failed to load markets:', e);
    if (!markets.length) {
      $('app').innerHTML = `
        <div class="header"><h1>Predict</h1><div>${createBtnHTML}</div></div>
        <div class="loading">Failed to load markets: ${escText(e.message || '')}</div>
      `;
    }
  }
}

function renderGalleryUI() {
  const now = Math.floor(Date.now() / 1000);
  let filtered = markets;
  if (_galleryFilter === 'active') filtered = markets.filter(m => !m.resolved && m.close > now);
  else if (_galleryFilter === 'resolved') filtered = markets.filter(m => m.resolved || m.close <= now);

  const searchVal = $('marketSearch')?.value || '';

  let cards = '';
  for (const m of filtered) {
    if (searchVal) {
      const q = searchVal.toLowerCase();
      const plainQ = stripHtml(m.question).toLowerCase();
      if (!plainQ.includes(q) && !m.marketId.includes(q) && !(m.description || '').toLowerCase().includes(q)) continue;
    } else if (!m.resolved) {
      // Hide dust-liquidity markets unless searching or resolved
      const isETH = !m.collateral || m.collateral === ethers.ZeroAddress;
      if (isETH && (m.tvl || 0) < 0.01) continue;
      if (!isETH && (m.tvl || 0) < 10) continue;
    }
    const yPct = m.oddsLoaded ? m.y : 50;
    const nPct = 100 - yPct;
    const isActive = !m.resolved && m.close > now;
    const resolvedClass = m.resolved ? ' resolved' : '';
    const wonAttr = m.resolved ? ` data-won="${m.outcome ? 'yes' : 'no'}"` : '';
    const outcomeLabel = m.resolved ? (m.outcome ? 'YES' : 'NO') : '';
    const tvlDisplay = m.tvl >= 1 ? m.tvl.toFixed(2) : m.tvl.toFixed(4);
    const timeDisplay = isActive ? fmtCountdown(m.close) : (m.resolved ? 'Resolved' : 'Closed');
    const isOurRes = m.resolver && m.resolver.toLowerCase() === CONTRACTS.RESOLVER.toLowerCase();
    const resolverTag = (!isOurRes && !m.isLegacy && m.resolver)
      ? `<span style="font-size:9px;color:var(--fg-dim);opacity:0.7">${m.resolver.slice(0,6)}\u2026${m.resolver.slice(-4)}</span>`
      : '';
    cards += `
      <a href="#${m.marketId}" class="market-card${resolvedClass}"${wonAttr}>
        <div class="market-card-question" data-outcome="${escText(outcomeLabel)}">${cardHtml(m.question)}</div>
        <div class="market-card-odds-label"><span class="yes-label">YES ${yPct}%</span><span class="no-label">NO ${nPct}%</span></div>
        <div class="market-card-odds">
          <div class="market-card-yes" style="width:${yPct}%"></div>
          <div class="market-card-no"></div>
        </div>
        <div class="market-card-meta">
          <span>${tvlDisplay} ${getCollateralSymbol(m.collateral)}</span>
          ${resolverTag}
          <span>${timeDisplay}</span>
        </div>
      </a>
    `;
  }

  if (!cards) cards = '<div class="loading">No markets found</div>';

  $('app').innerHTML = `
    <div class="header">
      <h1>Predict <span style="font-weight:400;color:var(--fg-muted)">(${filtered.length})</span></h1>
      <div>
        <button onclick="openCreateModal()" style="font-size:11px;padding:6px 14px">+ Create</button>
      </div>
    </div>
    <div class="filter-tabs">
      <button class="filter-tab${_galleryFilter === 'active' ? ' active' : ''}" onclick="setFilter('active')">Active</button>
      <button class="filter-tab${_galleryFilter === 'resolved' ? ' active' : ''}" onclick="setFilter('resolved')">Resolved</button>
      <button class="filter-tab${_galleryFilter === 'all' ? ' active' : ''}" onclick="setFilter('all')">All</button>
    </div>
    <input type="text" class="market-search" id="marketSearch" placeholder="Search markets..." oninput="renderGalleryUI()" value="${escText(searchVal)}">
    <div class="market-grid" id="marketGrid">${cards}</div>
    <div style="text-align:center;font-size:11px;color:var(--fg-dim);margin-top:24px;letter-spacing:0.05em;text-transform:uppercase">the open prediction market</div>
  `;
}

function setFilter(f) {
  _galleryFilter = f;
  renderGalleryUI();
}

// ==================== MARKET DETAIL PAGE ====================

let _renderSeq = 0;
async function renderMarketPage(marketId) {
  const seq = ++_renderSeq;
  _selectedPayToken = null;
  const app = $('app');
  app.dataset.marketId = marketId;
  app.innerHTML = `
    <a href="#" class="back-link" onclick="event.preventDefault();history.replaceState(null,'',location.pathname);route()">&larr; All Markets</a>
    <div class="loading">${zfiLoadingSVG(48)}Loading market...</div>
  `;

  _tradeDir = 'buy';
  _tradeSide = 'yes';
  _lastQuote = null;

  try {
    // Load all market data with RPC fallback
    const marketData = await withRPC(async (rpc) => {
      const pammIface = new ethers.Interface(PAMM_ABI);
      const quoterIface = new ethers.Interface(QUOTER_ABI);

      // First: always load market base data
      const calls = [
        {
          target: CONTRACTS.PAMM,
          callData: pammIface.encodeFunctionData('getMarket', [marketId]),
          decode: data => pammIface.decodeFunctionResult('getMarket', data)
        }
      ];

      // Also load user positions if connected
      if (_connectedAddress) {
        calls.push({
          target: CONTRACTS.QUOTER,
          callData: quoterIface.encodeFunctionData('getUserFullPosition', [marketId, _connectedAddress]),
          decode: data => quoterIface.decodeFunctionResult('getUserFullPosition', data)
        });
      }

      const results = await multicall(calls, rpc);
      if (!results[0].success) throw new Error('Market not found');
      const mkt = results[0].decode();

      // Determine if this is a labeled (hooked) or legacy market
      const description = mkt.description || '';
      const resolverAddr = mkt.resolver;
      const isOurResolver = resolverAddr.toLowerCase() === CONTRACTS.RESOLVER.toLowerCase();
      // Legacy: check LEGACY_MARKETS array, resolver address match, description prefix, or gallery flag
      const isLegacyMarket = LEGACY_MARKETS.some(l => l.marketId === marketId)
        || resolverAddr.toLowerCase() === CONTRACTS.LEGACY_RESOLVER.toLowerCase()
        || description.startsWith('LEGACY|')
        || (markets.find(m => m.marketId === marketId)?.isLegacy === true);
      const isLegacyResolver = isLegacyMarket;
      // All non-legacy markets use hooks (including open-resolver markets created via bootstrapper)
      const isLabeled = !isLegacyMarket;

      // Parse user positions from first multicall
      let userYes = 0n, userNo = 0n, userYesVaultLP = 0n, userNoVaultLP = 0n;
      let pendingYesColl = 0n, pendingNoColl = 0n;
      let vaultDepositTime = 0;
      const posIdx = _connectedAddress ? 1 : -1;
      if (posIdx >= 0 && results[posIdx] && results[posIdx].success) {
        try {
          const pos = results[posIdx].decode();
          userYes = BigInt(pos.yesShareBalance);
          userNo = BigInt(pos.noShareBalance);
          userYesVaultLP = BigInt(pos.yesVaultLP);
          userNoVaultLP = BigInt(pos.noVaultLP);
          pendingYesColl = BigInt(pos.pendingYesCollateral);
          pendingNoColl = BigInt(pos.pendingNoCollateral);
        } catch {}
      }
      // Fallback: if multicall didn't return positions, try direct call via wallet provider
      if (_connectedAddress && userYes === 0n && userNo === 0n && userYesVaultLP === 0n && userNoVaultLP === 0n) {
        const _posProviders = [_walletProvider, rpc].filter(Boolean);
        for (const _p of _posProviders) {
          try {
            const q = new ethers.Contract(CONTRACTS.QUOTER, QUOTER_ABI, _p);
            const pos = await q.getUserFullPosition(marketId, _connectedAddress);
            userYes = BigInt(pos.yesShareBalance);
            userNo = BigInt(pos.noShareBalance);
            userYesVaultLP = BigInt(pos.yesVaultLP);
            userNoVaultLP = BigInt(pos.noVaultLP);
            pendingYesColl = BigInt(pos.pendingYesCollateral);
            pendingNoColl = BigInt(pos.pendingNoCollateral);
            break;
          } catch { /* try next */ }
        }
      }
      // Fetch vault deposit time directly from PMHookRouter (Quoter doesn't return it)
      if (_connectedAddress && isLabeled) {
        const _vpProviders = [_walletProvider, rpc].filter(Boolean);
        for (const _p of _vpProviders) {
          try {
            const hr = new ethers.Contract(CONTRACTS.PM_HOOK_ROUTER, PM_HOOK_ROUTER_ABI, _p);
            const vp = await hr.vaultPositions(marketId, _connectedAddress);
            const vyLP = BigInt(vp.yesVaultShares);
            const vnLP = BigInt(vp.noVaultShares);
            if (vyLP > 0n || vnLP > 0n) {
              userYesVaultLP = vyLP;
              userNoVaultLP = vnLP;
            }
            vaultDepositTime = Number(vp.lastDepositTime);
            break;
          } catch { /* try next */ }
        }
      }

      // Second multicall: batch all remaining reads in one RPC round-trip
      let yPct = 50, ammYesReserve = 0n, ammNoReserve = 0n;
      let vaultYesShares = 0n, vaultNoShares = 0n, totalYesVaultLP = 0n, totalNoVaultLP = 0n, vaultBudget = 0n, currentFeeBps = 0n;
      let twapTimestamp1 = 0;
      let resValue = null, resCond = null, resReady = false, condData = null;
      let userAmmLP = 0n, ammLPSupply = 0n;
      let resolverFeeBps = 0;

      const hookIface = new ethers.Interface(PM_HOOK_ROUTER_ABI);
      const zammIface = new ethers.Interface(ZAMM_ABI);
      const resolverAbi = isOurResolver ? RESOLVER_ABI : LEGACY_RESOLVER_ABI;
      const resolverIface = new ethers.Interface(resolverAbi);
      const { poolId: pid } = computePredictionPoolId(marketId, isLabeled);

      const calls2 = [];
      const IDX = {};
      // Market data (summary or pool state)
      if (isLegacyMarket) {
        IDX.poolState = calls2.length;
        calls2.push({ target: CONTRACTS.PAMM, allowFailure: true,
          callData: pammIface.encodeFunctionData('getPoolState', [marketId, LEGACY_FEE_BPS]) });
      } else {
        IDX.summary = calls2.length;
        calls2.push({ target: CONTRACTS.QUOTER, allowFailure: true,
          callData: quoterIface.encodeFunctionData('getMarketSummary', [marketId]) });
        IDX.twap = calls2.length;
        calls2.push({ target: CONTRACTS.PM_HOOK_ROUTER, allowFailure: true,
          callData: hookIface.encodeFunctionData('twapObservations', [marketId]) });
      }
      // Resolver
      IDX.preview = calls2.length;
      calls2.push({ target: resolverAddr, allowFailure: true,
        callData: resolverIface.encodeFunctionData('preview', [marketId]) });
      IDX.conditions = calls2.length;
      calls2.push({ target: resolverAddr, allowFailure: true,
        callData: resolverIface.encodeFunctionData('conditions', [marketId]) });
      // ZAMM pool + user LP
      IDX.zammPool = calls2.length;
      calls2.push({ target: CONTRACTS.ZAMM, allowFailure: true,
        callData: zammIface.encodeFunctionData('pools', [pid]) });
      // Resolver fee (custom resolvers only)
      if (!isOurResolver && !isLegacyResolver) {
        IDX.resolverFee = calls2.length;
        calls2.push({ target: CONTRACTS.PAMM, allowFailure: true,
          callData: pammIface.encodeFunctionData('resolverFeeBps', [resolverAddr]) });
      }
      // ZAMM balanceOf and vaultPositions fetched separately after batch (more reliable)

      try {
        const mc = new ethers.Contract(MULTICALL3, MULTICALL3_ABI, rpc);
        const r2 = await mc.aggregate3(calls2);

        // Parse market data
        if (isLegacyMarket) {
          if (r2[IDX.poolState].success) {
            const ps = pammIface.decodeFunctionResult('getPoolState', r2[IDX.poolState].returnData);
            ammYesReserve = BigInt(ps.rYes);
            ammNoReserve = BigInt(ps.rNo);
            const rY = Number(ps.rYes), rN = Number(ps.rNo), total = rY + rN;
            yPct = total > 0 ? Math.round((rN / total) * 100) : 50;
          }
        } else {
          if (r2[IDX.summary].success) {
            const s = quoterIface.decodeFunctionResult('getMarketSummary', r2[IDX.summary].returnData);
            yPct = Math.round(Number(s.ammPriceYesBps) / 100);
            ammYesReserve = BigInt(s.ammYesReserve);
            ammNoReserve = BigInt(s.ammNoReserve);
            vaultYesShares = BigInt(s.vaultYesShares);
            vaultNoShares = BigInt(s.vaultNoShares);
            totalYesVaultLP = BigInt(s.totalYesVaultLP);
            totalNoVaultLP = BigInt(s.totalNoVaultLP);
            vaultBudget = BigInt(s.vaultBudget);
            currentFeeBps = BigInt(s.feeBps);

          }
          if (r2[IDX.twap].success) {
            try {
              const t = hookIface.decodeFunctionResult('twapObservations', r2[IDX.twap].returnData);
              twapTimestamp1 = Number(t.timestamp1);
            } catch {}
          }
        }

        // Parse resolver
        if (r2[IDX.preview].success) {
          try {
            const prev = resolverIface.decodeFunctionResult('preview', r2[IDX.preview].returnData);
            resValue = prev[0]; resCond = prev[1]; resReady = prev[2];
          } catch {}
        }
        if (r2[IDX.conditions].success) {
          try { condData = resolverIface.decodeFunctionResult('conditions', r2[IDX.conditions].returnData); } catch {}
        }

        // Parse ZAMM
        if (r2[IDX.zammPool].success) {
          try { ammLPSupply = BigInt(zammIface.decodeFunctionResult('pools', r2[IDX.zammPool].returnData).supply); } catch {}
        }
        // Parse resolver fee
        if (IDX.resolverFee !== undefined && r2[IDX.resolverFee].success) {
          try { resolverFeeBps = Number(pammIface.decodeFunctionResult('resolverFeeBps', r2[IDX.resolverFee].returnData)[0]); } catch {}
        }
        // vaultPositions fetched separately after batch
      } catch (e) {
        // Retry once on batch failure
        try {
          const mc2 = new ethers.Contract(MULTICALL3, MULTICALL3_ABI, rpc);
          const r2 = await mc2.aggregate3(calls2);
          if (!isLegacyMarket && r2[IDX.summary].success) {
            const s = quoterIface.decodeFunctionResult('getMarketSummary', r2[IDX.summary].returnData);
            yPct = Math.round(Number(s.ammPriceYesBps) / 100);
            ammYesReserve = BigInt(s.ammYesReserve); ammNoReserve = BigInt(s.ammNoReserve);
            vaultYesShares = BigInt(s.vaultYesShares); vaultNoShares = BigInt(s.vaultNoShares);
            totalYesVaultLP = BigInt(s.totalYesVaultLP); totalNoVaultLP = BigInt(s.totalNoVaultLP);
            vaultBudget = BigInt(s.vaultBudget); currentFeeBps = BigInt(s.feeBps);
          }
          if (r2[IDX.zammPool].success) {
            try { ammLPSupply = BigInt(zammIface.decodeFunctionResult('pools', r2[IDX.zammPool].returnData).supply); } catch {}
          }
          if (r2[IDX.preview].success) {
            try { const prev = resolverIface.decodeFunctionResult('preview', r2[IDX.preview].returnData); resValue = prev[0]; resCond = prev[1]; resReady = prev[2]; } catch {}
          }
          if (r2[IDX.conditions].success) {
            try { condData = resolverIface.decodeFunctionResult('conditions', r2[IDX.conditions].returnData); } catch {}
          }
          if (IDX.resolverFee !== undefined && r2[IDX.resolverFee].success) {
            try { resolverFeeBps = Number(pammIface.decodeFunctionResult('resolverFeeBps', r2[IDX.resolverFee].returnData)[0]); } catch {}
          }
        } catch (retryErr) { console.warn('Market data batch retry failed:', retryErr.message); }
      }

      // Fetch user-specific balances directly (unreliable inside multicall3 batch)
      // Try wallet provider first (most reliable), then current RPC
      if (_connectedAddress) {
        const _tryProviders = [_walletProvider, rpc].filter(Boolean);
        for (const _p of _tryProviders) {
          try {
            userAmmLP = await new ethers.Contract(CONTRACTS.ZAMM, ZAMM_ABI, _p).balanceOf(_connectedAddress, pid);
            break;
          } catch (e) { console.warn('ZAMM balanceOf failed:', e.message); }
        }
      }

      return {
        mkt, description, isLabeled, isOurResolver, isLegacyResolver, resolverAddr,
        yPct, ammYesReserve, ammNoReserve,
        vaultYesShares, vaultNoShares, totalYesVaultLP, totalNoVaultLP, vaultBudget, currentFeeBps,
        twapTimestamp1,
        resValue, resCond, resReady, condData,
        userYes, userNo, userYesVaultLP, userNoVaultLP, pendingYesColl, pendingNoColl,
        userAmmLP, ammLPSupply, vaultDepositTime, resolverFeeBps
      };
    });

    const { mkt, description, isLabeled, isOurResolver, isLegacyResolver, resolverAddr,
            yPct, ammYesReserve, ammNoReserve,
            vaultYesShares, vaultNoShares, totalYesVaultLP, totalNoVaultLP, vaultBudget, currentFeeBps,
            twapTimestamp1,
            resValue, resCond, resReady, condData,
            userYes, userNo, userYesVaultLP, userNoVaultLP, pendingYesColl, pendingNoColl,
            userAmmLP, ammLPSupply, vaultDepositTime, resolverFeeBps } = marketData;

    // Resolver verification + reverse .wei name (skip for onchain resolver)
    let resolverVerified = false, resolverWeiName = null;
    if (!isOurResolver && !isLegacyResolver) {
      [resolverVerified, resolverWeiName] = await Promise.all([
        checkResolverVerified(resolverAddr),
        reverseResolveWei(resolverAddr)
      ]);
    }

    // Abort if a newer render was started while we were loading
    if (seq !== _renderSeq) return;

    const close = Number(mkt.close);
    const resolved = mkt.resolved;
    const outcome = mkt.outcome;
    const collateral = mkt.collateral;
    const collateralLocked = mkt.collateralLocked;
    const tvl = Number(ethers.formatEther(collateralLocked));
    const parsed = parseMarketDescription(description);
    const nPct = 100 - yPct;

    const now = Math.floor(Date.now() / 1000);
    const isActive = !resolved && close > now;
    const collSym = getCollateralSymbol(collateral);

    let html = `<a href="#" class="back-link" onclick="event.preventDefault();history.replaceState(null,'',location.pathname);route()">&larr; All Markets</a>`;

    // Question + odds bar + implied outcome
    const _leadSide = yPct >= 50 ? 'Yes' : 'No';
    const _leadPct = Math.max(yPct, nPct);
    const _leadColor = yPct >= 50 ? 'var(--yes)' : 'var(--no)';
    html += `
      <div style="font-size:18px;font-weight:700;line-height:1.4;margin-bottom:16px">${parsed.question}</div>
      <div class="odds-label"><span class="yes-label">YES ${yPct}%</span><span class="no-label">NO ${nPct}%</span></div>
      <div class="odds-bar">
        <div class="odds-yes" style="width:${yPct}%"></div>
        <div class="odds-no"></div>
      </div>
      ${!resolved && _leadPct !== 50 ? `<div style="font-size:11px;color:var(--fg-dim);margin-top:6px;margin-bottom:2px">${_leadPct}% chance <span style="color:${_leadColor};font-weight:600">${_leadSide}</span></div>` : ''}
    `;

    // Oracle price + countdown strip for onchain-resolver markets
    if ((isOurResolver || isLegacyResolver) && condData && resValue !== null && !resolved) {
      const _cd = condData;
      const _callData = (typeof _cd.callDataA === 'string' ? _cd.callDataA : ethers.hexlify(_cd.callDataA || '0x')).toLowerCase();
      const _isPrice = _callData.slice(0, 10) === '0x50d25bcd';
      const _isBalance = _callData.length >= 74 && _callData.slice(0, 10) === '0x70a08231';
      const _isETHBal = _cd.targetA && (!_cd.callDataA || _cd.callDataA === '0x' || _callData.length < 10);
      const _dec = _isPrice ? 8 : (_isBalance || _isETHBal) ? 18 : 8;
      const _pre = _isPrice ? '$' : '';
      const _suf = _isBalance ? (' ' + (TOKEN_NAMES[_cd.targetA.toLowerCase()] || '')) : _isETHBal ? ' ETH' : '';
      const _val = Number(resValue) / Math.pow(10, _dec);
      const _thresh = Number(_cd.threshold) / Math.pow(10, _dec);
      const _fmtV = (v) => v >= 1e9 ? (v/1e9).toFixed(2)+'B' : v >= 1e6 ? (v/1e6).toFixed(2)+'M' : v < 0.01 && v > 0 ? v.toFixed(4) : v.toLocaleString(undefined, {minimumFractionDigits:2, maximumFractionDigits:2});
      const _timeLeft = close - now;
      const _urgent = _timeLeft > 0 && _timeLeft < 86400;
      const _timeColor = _urgent ? 'var(--no)' : 'var(--fg-muted)';
      const _countdown = _timeLeft <= 0 ? 'Closed' : fmtCountdown(close);
      html += `<div style="display:flex;justify-content:space-between;align-items:center;font-size:12px;margin-bottom:14px;padding:8px 0;border-bottom:1px solid var(--border-muted)">
        <span style="color:var(--fg-muted)">Now <span style="color:var(--fg);font-weight:600">${_pre}${_fmtV(_val)}${_suf}</span> <span style="opacity:0.5">/ ${_pre}${_fmtV(_thresh)}${_suf}</span></span>
        <span style="color:${_timeColor};font-weight:${_urgent ? '700' : '400'}">${_countdown}</span>
      </div>`;
    }

    // Odds chart drawer  collapsed by default, loaded on open
    const { poolId: chartPoolId, yesIsToken0: chartYesIsToken0 } = computePredictionPoolId(marketId, isLabeled);
    html += `<div class="market-chart-drawer" id="marketChartDrawer">
      <button class="market-chart-toggle-btn" onclick="toggleMarketChart()"><span>Odds Chart</span><span class="arrow">&#9660;</span></button>
      <div class="market-chart" id="marketChart" data-pool-id="${chartPoolId}" data-yes-is-token0="${chartYesIsToken0 ? '1' : '0'}" style="display:none"></div>
    </div>`;

    html += `<div class="market-chart-drawer" id="pmActivityDrawer" data-pool-id="${chartPoolId}" data-yes-is-token0="${chartYesIsToken0 ? '1' : '0'}">
      <button class="market-chart-toggle-btn" onclick="togglePoolActivity()"><span>Pool Activity</span><span class="arrow">&#9660;</span></button>
      <div class="pm-activity-body" style="display:none"><div id="pmActivityContent"><div class="pm-activity-empty">Click to load</div></div></div>
    </div>`;

    // Market info card
    const resolverShort = resolverAddr.slice(0, 6) + '...' + resolverAddr.slice(-4);
    const resolverDisplayName = isOurResolver ? 'Onchain Resolver' : (resolverWeiName ? resolverWeiName : resolverShort);
    const resolverLabel = resolverDisplayName + (resolverVerified ? VERIFIED_BADGE : '');
    html += `
      <div class="market-chart-drawer" id="marketInfoDrawer">
        <button class="market-chart-toggle-btn" onclick="toggleDrawer('marketInfoDrawer')"><span>Market Info</span><span class="arrow">&#9660;</span></button>
        <div class="drawer-body" style="display:none;padding:4px 0 8px">
          <div class="stat-row"><span class="stat-label">Status</span><span class="stat-value">${resolved ? (outcome ? '<span style="color:var(--yes)">Resolved YES</span>' : '<span style="color:var(--no)">Resolved NO</span>') : (isActive ? `<span style="color:${close - now < 86400 ? 'var(--no)' : 'var(--fg)'}">${fmtCountdown(close)} left</span>` : 'Closed')}</span></div>
          <div class="stat-row"><span class="stat-label">Closes</span><span class="stat-value"${!resolved && close - now < 86400 ? ' style="color:var(--no)"' : ''}>${fmtDate(close)}</span></div>
          <div class="stat-row"><span class="stat-label">Liquidity</span><span class="stat-value" style="display:inline-flex;align-items:center;gap:3px">${tvl >= 1 ? tvl.toFixed(2) : tvl.toFixed(4)} ${collSym} ${payTokenIcon(collSym).replace(/width="20"/g,'width="14"').replace(/height="20"/g,'height="14"')}</span></div>
          <div class="stat-row"><span class="stat-label">Resolver</span><span class="stat-value" style="font-size:11px"><a href="https://etherscan.io/address/${resolverAddr}" target="_blank" rel="noopener" style="color:var(--fg-muted)">${resolverLabel}</a></span></div>
          ${!isOurResolver && !isLegacyResolver && resolverFeeBps > 0 ? `<div class="stat-row"><span class="stat-label">Resolver Fee</span><span class="stat-value">${(resolverFeeBps / 100).toFixed(2)}%</span></div>` : ''}
          <div class="stat-row"><span class="stat-label">Market ID</span><span class="stat-value" style="font-size:11px;word-break:break-all"><a href="https://etherscan.io/address/${CONTRACTS.PAMM}" target="_blank" rel="noopener" style="color:var(--fg-muted)">${marketId.slice(0, 12)}...${marketId.slice(-6)}</a></span></div>
          ${isLabeled && currentFeeBps > 0n && currentFeeBps <= 10000n ? `<div class="stat-row"><span class="stat-label">Swap Fee <span onclick="event.stopPropagation();showRawTooltip(this,'Dynamic fee  adapts each swap based on market conditions.\\n\\nComponents:\\n Base fee: decays from high to low over the bootstrap window\\n Skew fee: increases when probability deviates from 50% (non-linear curve)\\n Directional fee: linear scaling with probability deviation from 50%\\n Volatility fee: added when recent price variance is high\\n\\nTotal fee is capped at 3%. Fee shown is the current rate  it changes with every trade.\\n\\nzAMM LPs earn fees from pool swaps. Vault LPs earn fees from vault OTC fills  90% to vault when inventory is balanced, 70% when imbalanced. The remainder goes to a rebalance budget.')" style="opacity:0.4;cursor:help;font-size:9px"></span></span><span class="stat-value">${(Number(currentFeeBps) / 100).toFixed(2)}%</span></div>` : ''}
        </div>
      </div>
    `;
    // Vault cooldown (computed once, used in vault card and positions)
    const vaultCooldownSec = vaultDepositTime ? _vaultCooldownRemaining(vaultDepositTime, close) : 0;
    const vaultCooldownLabel = vaultCooldownSec > 0 ? fmtDuration(vaultCooldownSec) : '';

    // Vault info card (labeled markets with vault inventory)
    if (isLabeled && (vaultYesShares > 0n || vaultNoShares > 0n)) {
      const vYes = Number(ethers.formatEther(vaultYesShares));
      const vNo = Number(ethers.formatEther(vaultNoShares));
      const vBudgetEth = Number(ethers.formatEther(vaultBudget));

      // Health checks
      const twapAge = twapTimestamp1 > 0 ? now - twapTimestamp1 : 0;
      const twapStale = twapTimestamp1 > 0 && twapAge >= 1800;
      const twapVeryStale = twapTimestamp1 > 0 && twapAge >= 7200;
      const totalInventory = vaultYesShares + vaultNoShares;
      const imbalanceRatio = totalInventory > 0n
        ? Number(vaultYesShares > vaultNoShares ? vaultYesShares - vaultNoShares : vaultNoShares - vaultYesShares) / Number(totalInventory) * 100
        : 0;
      const isImbalanced = imbalanceRatio > 20;
      const budgetMaterial = vBudgetEth >= 0.0001;
      const needsRebalance = isImbalanced && budgetMaterial && isActive;
      const needsSettle = budgetMaterial && !isActive;
      const needsAttention = (twapVeryStale && isActive) || needsRebalance || needsSettle;
      const hasActions = (isActive && twapStale) || needsRebalance || needsSettle || (resolved && (vaultYesShares > 0n || vaultNoShares > 0n || vaultBudget > 0n));

      html += `
        <div class="market-chart-drawer" id="vaultInfoDrawer">
          <button class="market-chart-toggle-btn" onclick="toggleDrawer('vaultInfoDrawer')"><span>Vault</span><span class="arrow">&#9660;</span></button>
          <div class="drawer-body" style="display:none;padding:4px 0 8px">
            <div style="font-size:11px;color:var(--fg-muted);margin-bottom:10px">Holds shares from sweep trades. Depositors earn OTC fees. <span onclick="event.stopPropagation();showRawTooltip(this,'When large trades sweep through the zAMM, the opposite-side shares are deposited into the vault automatically. Vault depositors earn fees from vault OTC fills proportional to their LP tokens.\\n\\nHow it works:\\n Sweep buys deposit opposite shares into the vault\\n Vault LPs earn 90% of OTC fees when inventory is balanced, 70% when imbalanced\\n Remaining OTC fees go to a rebalance budget used to re-equalize YES/NO inventory\\n\\nMaintenance (permissionless):\\n Update TWAP  refreshes the price oracle used for vault pricing (every 30min)\\n Rebalance  uses budget to swap excess inventory toward balance\\n Settle  after market closes, distributes remaining budget to LPs\\n Finalize  after resolution, redeems vault shares and closes out\\n\\nHarvest lets you claim earned fees without withdrawing your vault position.')" style="opacity:0.4;cursor:help;font-size:9px"></span></div>
            ${vaultYesShares > 0n ? `<div class="stat-row"><span class="stat-label">YES Inventory</span><span class="stat-value">${vYes >= 1 ? vYes.toFixed(2) : vYes.toFixed(4)} shares</span></div>` : ''}
            ${vaultNoShares > 0n ? `<div class="stat-row"><span class="stat-label">NO Inventory</span><span class="stat-value">${vNo >= 1 ? vNo.toFixed(2) : vNo.toFixed(4)} shares</span></div>` : ''}
            ${vaultBudget > 0n && vBudgetEth >= 0.0001 ? `<div class="stat-row"><span class="stat-label">Budget</span><span class="stat-value">${vBudgetEth >= 1 ? vBudgetEth.toFixed(2) : vBudgetEth.toFixed(4)} ${collSym}</span></div>` : ''}
            ${needsAttention ? `<div style="font-size:11px;color:var(--fg-dim);margin-top:8px;padding-top:8px;border-top:1px solid var(--border-muted)">${[twapVeryStale && isActive ? 'TWAP oracle is stale' : '', needsRebalance ? 'Inventory is imbalanced' : '', needsSettle ? 'Budget can be settled' : ''].filter(Boolean).join('. ')}.</div>` : ''}
            ${hasActions ? `<div style="display:flex;gap:6px;margin-top:8px;flex-wrap:wrap">
              ${isActive && twapStale ? `<button onclick="updateTWAP('${marketId}')" id="twapBtn" class="lp-withdraw-btn" style="flex:1;min-width:0;text-align:center;padding:5px 10px">Update TWAP</button>` : ''}
              ${needsRebalance ? `<button onclick="rebalanceVault('${marketId}')" id="rebalanceBtn" class="lp-withdraw-btn" style="flex:1;min-width:0;text-align:center;padding:5px 10px">Rebalance</button>` : ''}
              ${needsSettle ? `<button onclick="settleBudget('${marketId}')" id="settleBudgetBtn" class="lp-withdraw-btn" style="flex:1;min-width:0;text-align:center;padding:5px 10px">Settle</button>` : ''}
              ${resolved ? `<button onclick="finalizeMarket('${marketId}')" id="finalizeBtn" class="lp-withdraw-btn" style="flex:1;min-width:0;text-align:center;padding:5px 10px">Finalize</button>` : ''}
            </div>` : ''}
          </div>
        </div>
      `;
    }

    // User positions (if any)
    const hasTradePos = userYes > 0n || userNo > 0n;
    const hasLPPos = userAmmLP > 0n || userYesVaultLP > 0n || userNoVaultLP > 0n;
    if (hasTradePos || hasLPPos) {
      let posHtml = `<div class="market-chart-drawer open" id="positionsDrawer">
        <button class="market-chart-toggle-btn" onclick="toggleDrawer('positionsDrawer')">
          <span>Your Positions</span><span class="arrow"></span>
        </button>
        <div class="drawer-body" style="padding:0 0 8px">`;
      if (hasTradePos) {
        posHtml += `<div style="font-size:9px;text-transform:uppercase;letter-spacing:0.05em;color:var(--fg-dim);margin-bottom:4px">Outcome Tokens</div>`;
        if (userYes > 0n) posHtml += `<div class="pos-row"><span class="pos-side yes">YES</span><span>${Number(ethers.formatEther(userYes)).toFixed(4)}</span></div>`;
        if (userNo > 0n) posHtml += `<div class="pos-row"><span class="pos-side no">NO</span><span>${Number(ethers.formatEther(userNo)).toFixed(4)}</span></div>`;
      }
      if (hasLPPos) {
        if (hasTradePos) posHtml += `<div style="border-top:1px solid var(--border-muted);margin:8px 0"></div>`;
        posHtml += `<div style="font-size:9px;text-transform:uppercase;letter-spacing:0.05em;color:var(--fg-dim);margin-bottom:4px">Liquidity</div>`;
        if (userAmmLP > 0n) {
          const ammPctShare = ammLPSupply > 0n ? (Number(userAmmLP) / Number(ammLPSupply) * 100) : 0;
          // Estimate collateral value: proportional share of reserves
          let lpCollEst = '';
          if (ammLPSupply > 0n && (ammYesReserve > 0n || ammNoReserve > 0n)) {
            const uYR = ammYesReserve * userAmmLP / ammLPSupply;
            const uNR = ammNoReserve * userAmmLP / ammLPSupply;
            const matched = uYR < uNR ? uYR : uNR;
            const leftover = uYR > uNR ? uYR - uNR : uNR - uYR;
            const leftoverPrice = uYR > uNR ? yPct : nPct; // YES excess  valued at YES%, NO excess  NO%
            const estVal = Number(ethers.formatEther(matched)) + Number(ethers.formatEther(leftover)) * leftoverPrice / 100;
            lpCollEst = ` <span style="color:var(--fg-muted);font-size:11px">~${estVal >= 1 ? estVal.toFixed(2) : estVal.toFixed(4)} ${collSym}</span>`;
          }
          posHtml += `<div class="pos-row"><span class="pos-side" style="color:var(--fg)">AMM</span><span class="pos-val">${Number(ethers.formatEther(userAmmLP)).toFixed(4)} LP${lpCollEst} <span style="color:var(--fg-muted);font-size:11px">(${ammPctShare < 0.01 ? '<0.01' : ammPctShare.toFixed(2)}%)</span></span><span style="display:flex;gap:3px"><button class="lp-withdraw-btn" onclick="withdrawAmmLP(25)">25%</button><button class="lp-withdraw-btn" onclick="withdrawAmmLP(50)">50%</button><button class="lp-withdraw-btn" id="withdrawAmmBtn" onclick="withdrawAmmLP()">ALL</button></span></div>`;
        }
        if (userYesVaultLP > 0n) {
          const yPctShare = totalYesVaultLP > 0n ? (Number(userYesVaultLP) / Number(totalYesVaultLP) * 100) : 0;
          const yBtn = vaultCooldownSec > 0
            ? `<span style="font-size:10px;color:var(--fg-muted)">&#128274; ${vaultCooldownLabel}</span>`
            : `<span style="display:flex;gap:3px"><button class="lp-withdraw-btn" id="harvestYesVaultBtn" onclick="harvestFees('${marketId}',true)">HARVEST</button><button class="lp-withdraw-btn" id="withdrawYesVaultBtn" onclick="withdrawVault(true)">WITHDRAW</button></span>`;
          posHtml += `<div class="pos-row"><span class="pos-side yes">YES Vault</span><span class="pos-val">${Number(ethers.formatEther(userYesVaultLP)).toFixed(4)} <span style="color:var(--fg-muted);font-size:11px">(${yPctShare < 0.01 ? '<0.01' : yPctShare.toFixed(2)}%)</span></span>${yBtn}</div>`;
        }
        if (userNoVaultLP > 0n) {
          const nPctShare = totalNoVaultLP > 0n ? (Number(userNoVaultLP) / Number(totalNoVaultLP) * 100) : 0;
          const nBtn = vaultCooldownSec > 0
            ? `<span style="font-size:10px;color:var(--fg-muted)">&#128274; ${vaultCooldownLabel}</span>`
            : `<span style="display:flex;gap:3px"><button class="lp-withdraw-btn" id="harvestNoVaultBtn" onclick="harvestFees('${marketId}',false)">HARVEST</button><button class="lp-withdraw-btn" id="withdrawNoVaultBtn" onclick="withdrawVault(false)">WITHDRAW</button></span>`;
          posHtml += `<div class="pos-row"><span class="pos-side no">NO Vault</span><span class="pos-val">${Number(ethers.formatEther(userNoVaultLP)).toFixed(4)} <span style="color:var(--fg-muted);font-size:11px">(${nPctShare < 0.01 ? '<0.01' : nPctShare.toFixed(2)}%)</span></span>${nBtn}</div>`;
        }
      }
      posHtml += `</div></div>`;
      html += posHtml;
    }

    // Trade card (only if market is active)
    if (!isActive && !resolved) {
      html += `
        <div class="section-card" style="text-align:center;opacity:0.7">
          <div style="font-size:13px;color:var(--fg-muted)">Market closed  awaiting resolution</div>
          ${(isOurResolver || isLegacyResolver) ? `<button class="resolve-btn" style="margin-top:10px;font-size:12px;padding:6px 18px" onclick="document.getElementById('resolveSection')?.scrollIntoView({behavior:'smooth'})">Check Resolution</button>` : ''}
        </div>
      `;
    }
    if (isActive) {
      const isETH = !collateral || collateral === ethers.ZeroAddress;
      html += `
        <div class="section-card" id="tradeCard">
          <div class="section-title">Trade</div>
          <div class="trade-dir">
            <button class="active" data-dir="buy" onclick="setTradeDir('buy')">Buy</button>
            <button data-dir="sell" onclick="setTradeDir('sell')">Sell</button>
          </div>
          <div class="trade-side">
            <button class="active" data-side="yes" onclick="setTradeSide('yes')">Yes</button>
            <button data-side="no" onclick="setTradeSide('no')">No</button>
          </div>
          <div class="trade-section">
            <div class="trade-section-head">
              <label id="tradeInputLabel">${isETH ? 'ETH' : getCollateralSymbol(collateral)}</label>
              <span class="trade-balance" id="tradeBalance" onclick="setMaxAmount()"></span>
            </div>
            <div class="pay-token-row">
              <input type="number" id="tradeInput" placeholder="0.0" step="any" min="0" oninput="onTradeInput()">
              <button class="pay-token-btn" id="payTokenBtn" onclick="openPayTokenModal()" style="display:none">${isETH ? 'ETH' : getCollateralSymbol(collateral)} <span style="font-size:9px;opacity:0.5">&#9662;</span></button>
            </div>
            <div class="trade-pct-row" id="tradePctRow">
              <button class="trade-pct-btn" onclick="setPct(0.25)">25%</button>
              <button class="trade-pct-btn" onclick="setPct(0.5)">50%</button>
              <button class="trade-pct-btn" onclick="setPct(0.75)">75%</button>
              <button class="trade-pct-btn" onclick="setPct(1)">Max</button>
            </div>
          </div>
          <div class="trade-quote" id="tradeQuote"></div>
          <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:8px;font-size:11px;color:var(--fg-muted)">
            <span>Slippage</span>
            <span style="display:flex;gap:4px;align-items:center" id="slippageRow">
              ${[1,3,5,10].map(v => `<button onclick="setSlippage(${v})" class="trade-pct-btn" style="font-size:10px;padding:2px 6px;min-width:0;${_tradeSlippage===v?'color:var(--btn-fg);background:var(--btn-bg);border-color:var(--btn-bg)':''}" data-slip="${v}">${v}%</button>`).join('')}
              <input type="number" id="slippageCustom" min="0.1" max="50" step="0.1" style="width:44px;padding:2px 4px;font-size:10px;background:var(--surface);border:1px solid ${![1,3,5,10].includes(_tradeSlippage)?'var(--btn-bg)':'var(--border-muted)'};color:var(--fg);text-align:center;border-radius:3px" value="${_tradeSlippage}" onfocus="clearSlippagePresets()" oninput="setSlippage(parseFloat(this.value)||5,true)">
              <span style="font-size:10px">%</span>
            </span>
          </div>
          <button class="form-btn" id="tradeBtn" onclick="executeTrade()" disabled>Enter amount</button>
          <div style="text-align:center;margin-top:12px">
            <button onclick="openLPModal('${marketId}')" style="font-size:11px;padding:6px 16px;background:transparent;border:1px solid var(--border-muted);color:var(--fg-muted)">Provide Liquidity</button>
          </div>
        </div>
      `;
    }

    // Orderbook links for YES/NO limit orders
    {
      const _yesId = BigInt(marketId);
      const _noId = BigInt(ethers.keccak256(ethers.solidityPacked(['string', 'uint256'], ['PMARKET:NO', _yesId])));
      const _pamm = CONTRACTS.PAMM;
      // Sorted: token0=token1=PAMM, ids sorted
      const [_sId0, _sId1, _sLabel0, _sLabel1] = _yesId < _noId
        ? [_yesId, _noId, 'YES', 'NO'] : [_noId, _yesId, 'NO', 'YES'];
      // Price: coin0 per coin1 (depends on sort order)
      const _price = _yesId < _noId
        ? (yPct > 0 ? (nPct / yPct) : '')   // coin0=YES, coin1=NO  price of NO in YES
        : (nPct > 0 ? (yPct / nPct) : '');  // coin0=NO, coin1=YES  price of YES in NO
      const _obBase = '../orderbook/?token0=' + encodeURIComponent(_pamm) + '&token1=' + encodeURIComponent(_pamm)
        + '&id0=' + _sId0.toString() + '&id1=' + _sId1.toString()
        + '&label0=' + encodeURIComponent(_sLabel0) + '&label1=' + encodeURIComponent(_sLabel1);
      const _obHref = _price ? _obBase + '&price=' + _price : _obBase;
      html += `
        <div style="display:flex;gap:12px;justify-content:center;margin:12px 0;font-size:12px">
          <a href="${_obHref}" style="color:var(--fg-muted);text-decoration:none;border-bottom:1px dotted var(--fg-dim)">Limit Orders (YES/NO)</a>
        </div>
      `;
    }

    // Claim card (if resolved and user has position)
    if (resolved && !_connectedAddress) {
      html += `
        <div class="section-card" style="text-align:center">
          <div style="font-size:13px;color:var(--fg-muted);margin-bottom:10px">Market resolved <b style="color:${outcome ? 'var(--yes)' : 'var(--no)'}">${outcome ? 'YES' : 'NO'}</b></div>
          <button class="form-btn" onclick="connectWallet().then(()=>renderMarketPage('${marketId}'))">Connect wallet to check winnings</button>
        </div>
      `;
    }
    if (resolved && _connectedAddress && (userYes > 0n || userNo > 0n)) {
      const winningShares = outcome ? userYes : userNo;
      const losingShares = outcome ? userNo : userYes;
      if (winningShares > 0n) {
        const winAmt = Number(ethers.formatEther(winningShares));
        const pendingColl = outcome ? pendingYesColl : pendingNoColl;
        const payoutAmt = pendingColl > 0n ? Number(ethers.formatEther(pendingColl)) : winAmt;
        const payoutFmt = payoutAmt >= 1 ? payoutAmt.toFixed(2) : payoutAmt.toFixed(4);
        html += `
          <div class="section-card" style="border-color:var(--yes)">
            <div class="section-title" style="color:var(--yes)">Claim Winnings</div>
            <div style="text-align:center;margin-bottom:12px;font-size:14px">
              You have <b>${winAmt >= 1 ? winAmt.toFixed(2) : winAmt.toFixed(4)}</b> winning ${outcome ? 'YES' : 'NO'} shares
            </div>
            <div id="claimQuote" style="text-align:center;font-size:12px;color:var(--fg-muted);margin-bottom:12px">
              ~${payoutFmt} ${collSym} payout${pendingColl > 0n && pendingColl < winningShares ? ' (after resolver fee)' : ''}
            </div>
            <button class="resolve-btn" id="claimBtn" style="background:var(--yes);color:#000" onclick="claimWinnings('${marketId}')">Claim ${payoutFmt} ${collSym}</button>
          </div>
        `;
      } else if (losingShares > 0n) {
        html += `
          <div class="section-card" style="border-color:var(--no);opacity:0.7">
            <div class="section-title" style="color:var(--no)">No Payout</div>
            <div style="text-align:center;font-size:13px;color:var(--fg-muted)">
              Market resolved ${outcome ? 'YES' : 'NO'}  your ${outcome ? 'NO' : 'YES'} shares have no value
            </div>
          </div>
        `;
      }
    }

    // Resolution section
    if (isOurResolver || isLegacyResolver) {
      try {
        html += buildResolutionSection(marketId, { resolved, outcome, resValue, resCond, resReady, condData, close, canClose: mkt.canClose, resolverAddr, isOurResolver, isLegacyResolver });
      } catch (e) {
        console.error('buildResolutionSection error:', e);
        html += `<div class="section-card"><div class="section-title">Resolution</div><div class="resolve-status">Error loading resolver data</div></div>`;
      }
    } else if (!resolved && _connectedAddress && resolverAddr.toLowerCase() === _connectedAddress.toLowerCase()) {
      const canResolveNow = close <= now || mkt.canClose;
      html += `
        <div class="section-card">
          <div class="section-title">You are the Resolver</div>
          ${canResolveNow
            ? `<div class="resolve-status">You can resolve this market as the designated resolver.</div>
               <div style="display:flex;gap:8px;margin-top:8px">
                 <button class="resolve-btn" id="resolveYesBtn" onclick="resolveCustomMarket('${marketId}', true)" style="flex:1;background:var(--yes);color:#000">Resolve YES</button>
                 <button class="resolve-btn" id="resolveNoBtn" onclick="resolveCustomMarket('${marketId}', false)" style="flex:1;background:var(--no);color:#fff">Resolve NO</button>
               </div>`
            : `<div class="resolve-status" style="opacity:0.6">Early close is not enabled. You can resolve after the close date (${fmtDate(close)}).</div>`
          }
        </div>
      `;
    }

    app.innerHTML = html;

    // Pre-check activity: hide odds chart drawer entirely if no swap events, auto-open if data exists
    _chartLoaded = false;
    _chartEventsCache = null;
    fetchAllEvents(chartPoolId).then(events => {
      const hasSwaps = events.some(ev => ev.category === 'SWAP');
      if (!hasSwaps) {
        const drawer = document.getElementById('marketChartDrawer');
        if (drawer) drawer.style.display = 'none';
      } else {
        _chartEventsCache = events;
      }
    }).catch(() => {});

    // Update page title and meta tags for sharing
    const plainQ = parsed.question.replace(/<[^>]*>/g, '');
    document.title = plainQ + '  PREDICT';
    const ogDesc = `${plainQ}  YES ${yPct}% / NO ${nPct}%`;
    const metaUpdates = { 'og:title': plainQ, 'og:description': ogDesc, 'twitter:title': plainQ, 'twitter:description': ogDesc };
    for (const [prop, val] of Object.entries(metaUpdates)) {
      const attr = prop.startsWith('og:') ? 'property' : 'name';
      const el = document.querySelector(`meta[${attr}="${prop}"]`);
      if (el) el.setAttribute('content', val);
    }

    // Store market data for trading
    app.dataset.marketId = marketId;
    app.dataset.collateral = collateral;
    app.dataset.ammYesReserve = ammYesReserve.toString();
    app.dataset.ammNoReserve = ammNoReserve.toString();
    app.dataset.resolved = resolved ? '1' : '0';
    app.dataset.isLabeled = isLabeled ? '1' : '0';
    app.dataset.resolverAddr = resolverAddr;
    app.dataset.isOurResolver = isOurResolver ? '1' : '0';
    app.dataset.userAmmLP = userAmmLP.toString();
    app.dataset.userYesVaultLP = userYesVaultLP.toString();
    app.dataset.userNoVaultLP = userNoVaultLP.toString();

    // Update nav orderbook link for this market's YES/NO pair
    {
      const _nav = $('navOrderbook');
      if (_nav) {
        const _yId = BigInt(marketId);
        const _nId = BigInt(ethers.keccak256(ethers.solidityPacked(['string', 'uint256'], ['PMARKET:NO', _yId])));
        const [_si0, _si1, _sl0, _sl1] = _yId < _nId ? [_yId, _nId, 'YES', 'NO'] : [_nId, _yId, 'NO', 'YES'];
        _nav.href = '../orderbook/?token0=' + encodeURIComponent(CONTRACTS.PAMM) + '&token1=' + encodeURIComponent(CONTRACTS.PAMM)
          + '&id0=' + _si0.toString() + '&id1=' + _si1.toString()
          + '&label0=' + encodeURIComponent(_sl0) + '&label1=' + encodeURIComponent(_sl1);
      }
    }

    // Load balances if connected
    if (_connectedAddress && isActive) {
      loadTradeBalance(marketId, collateral, userYes, userNo);
    }
    showPayTokenBtn();

    if (!_connectedAddress) {
      tryAutoConnect().then(() => {
        if (_connectedAddress) renderMarketPage(marketId);
      });
    }

  } catch (e) {
    app.innerHTML = `
      <a href="#" class="back-link" onclick="event.preventDefault();history.replaceState(null,'',location.pathname);route()">&larr; All Markets</a>
      <div class="loading">Failed to load market: ${escText(e.message || '')}</div>
    `;
  }
}

// ==================== TRADE UI ====================

function setTradeDir(dir) {
  _tradeDir = dir;
  _lastQuote = null;
  if (dir === 'sell') _selectedPayToken = null;
  document.querySelectorAll('.trade-dir button').forEach(b => {
    b.classList.toggle('active', b.dataset.dir === dir);
  });
  const tradeInput = $('tradeInput');
  if (tradeInput) { tradeInput.value = ''; }
  const tradeQuote = $('tradeQuote');
  if (tradeQuote) tradeQuote.textContent = '';
  const tradeBtn = $('tradeBtn');
  if (tradeBtn) { tradeBtn.textContent = 'Enter amount'; tradeBtn.disabled = true; }
  // Update pay token button text when switching back to buy
  if (dir === 'buy') _updatePayTokenBtn();

  updateTradeLabels();
  const marketId = $('app').dataset.marketId;
  const collateral = $('app').dataset.collateral;
  if (_connectedAddress && marketId) {
    loadTradeBalance(marketId, collateral, 0n, 0n);
  }
}

function setTradeSide(side) {
  _tradeSide = side;
  _lastQuote = null;
  document.querySelectorAll('.trade-side button').forEach(b => {
    b.classList.toggle('active', b.dataset.side === side);
  });
  const tradeInput = $('tradeInput');
  if (tradeInput) { tradeInput.value = ''; }
  const tradeQuote = $('tradeQuote');
  if (tradeQuote) tradeQuote.textContent = '';
  const tradeBtn = $('tradeBtn');
  if (tradeBtn) { tradeBtn.textContent = 'Enter amount'; tradeBtn.disabled = true; }

  updateTradeLabels();
  const marketId = $('app').dataset.marketId;
  const collateral = $('app').dataset.collateral;
  if (_connectedAddress && marketId) {
    loadTradeBalance(marketId, collateral, 0n, 0n);
  }
}

function setSlippage(pct, fromCustom) {
  if (!pct || pct < 0.1) pct = 0.1;
  if (pct > 50) pct = 50;
  _tradeSlippage = pct;
  const row = $('slippageRow');
  if (row) {
    const isPreset = [1,3,5,10].includes(pct);
    row.querySelectorAll('button[data-slip]').forEach(b => {
      const v = Number(b.dataset.slip);
      if (v === pct && !fromCustom) { b.style.color = 'var(--btn-fg)'; b.style.background = 'var(--btn-bg)'; b.style.borderColor = 'var(--btn-bg)'; }
      else { b.style.color = ''; b.style.background = ''; b.style.borderColor = ''; }
    });
    const custom = $('slippageCustom');
    if (custom) {
      if (!fromCustom) custom.value = pct;
      custom.style.borderColor = (!isPreset || fromCustom) ? 'var(--btn-bg)' : 'var(--border-muted)';
    }
  }
}
function clearSlippagePresets() {
  const row = $('slippageRow');
  if (row) row.querySelectorAll('button[data-slip]').forEach(b => { b.style.color = ''; b.style.background = ''; b.style.borderColor = ''; });
}

function updateTradeLabels() {
  const label = $('tradeInputLabel');
  if (!label) return;
  if (_tradeDir === 'buy') {
    const d = getSelectedPayTokenData();
    label.textContent = d.symbol;
  } else {
    label.textContent = _tradeSide.toUpperCase() + ' shares';
  }
  showPayTokenBtn();
}

// ==================== PAY TOKEN SELECTOR ====================

function getSelectedPayTokenData() {
  if (!_selectedPayToken) {
    const collateral = $('app').dataset.collateral;
    const isETH = !collateral || collateral === ethers.ZeroAddress;
    if (isETH) return PREDICT_TOKENS.ETH;
    // Find in all tokens by address
    const found = findPayTokenByAddress(collateral);
    if (found) return found;
    return { address: collateral, symbol: getCollateralSymbol(collateral), decimals: 18 };
  }
  return _selectedPayToken;
}

function isPayTokenCollateral() {
  if (!_selectedPayToken) return true;
  const collateral = ($('app').dataset.collateral || '').toLowerCase();
  const isETHCollateral = !collateral || collateral === ethers.ZeroAddress.toLowerCase();
  const selAddr = _selectedPayToken.address.toLowerCase();
  if (isETHCollateral) return selAddr === ZERO_ADDRESS.toLowerCase();
  return selAddr === collateral;
}

function openPayTokenModal() {
  const searchInput = $('payTokenSearch');
  if (searchInput) searchInput.value = '';
  const statusEl = $('payTokenCustomStatus');
  if (statusEl) statusEl.textContent = '';
  const addrInput = $('payTokenCustomAddr');
  if (addrInput) addrInput.value = '';
  renderPayTokenList();
  $('payTokenModal').classList.add('active');
  if (searchInput) setTimeout(() => searchInput.focus(), 50);
}

function renderPayTokenList() {
  const collateral = $('app').dataset.collateral;
  const isETH = !collateral || collateral === ethers.ZeroAddress;
  const collAddr = (collateral || ZERO_ADDRESS).toLowerCase();
  const sel = getSelectedPayTokenData();
  const selAddr = sel.address.toLowerCase();
  const filter = ($('payTokenSearch')?.value || '').trim().toLowerCase();

  const list = $('payTokenList');
  if (!list) return;
  let html = '';

  function matchesFilter(tok) {
    if (!filter) return true;
    return tok.symbol.toLowerCase().includes(filter) || tok.address.toLowerCase().includes(filter);
  }

  function renderItem(key, tok) {
    if (!matchesFilter(tok)) return '';
    const isDefault = tok.address.toLowerCase() === collAddr;
    const isActive = tok.address.toLowerCase() === selAddr;
    const icon = payTokenIcon(tok.symbol);
    const symSafe = escText(tok.symbol);
    return `<li class="${isActive ? 'active' : ''}" onclick="selectPayToken('${escText(key)}')">
      ${icon}<span class="tok-sym">${symSafe}</span>
      ${isDefault ? '<span class="tok-note">collateral</span>' : ''}
    </li>`;
  }

  // Builtin tokens
  for (const [key, tok] of Object.entries(PREDICT_TOKENS)) {
    html += renderItem(key, tok);
  }

  // Custom tokens
  const customEntries = Object.entries(_predictCustomTokens);
  if (customEntries.length > 0) {
    const customHtml = customEntries.map(([k, t]) => renderItem(k, t)).join('');
    if (customHtml) {
      html += `<li style="padding:6px 12px;font-size:10px;letter-spacing:0.08em;text-transform:uppercase;color:var(--fg-muted);cursor:default;border-bottom:1px solid var(--border-muted)">Custom</li>`;
      html += customHtml;
    }
  }

  if (!html) {
    html = `<li style="padding:16px;text-align:center;color:var(--fg-muted);cursor:default">No tokens found</li>`;
  }

  list.innerHTML = html;
}

function closePayTokenModal() {
  $('payTokenModal').classList.remove('active');
}

function selectPayToken(sym) {
  const all = getAllPayTokens();
  const tok = all[sym];
  if (!tok) return;
  const collateral = ($('app').dataset.collateral || '').toLowerCase();
  const isETHCollateral = !collateral || collateral === ethers.ZeroAddress.toLowerCase();
  const collAddr = isETHCollateral ? ZERO_ADDRESS.toLowerCase() : collateral;

  // If selecting the collateral token, reset to null (default)
  if (tok.address.toLowerCase() === collAddr) {
    _selectedPayToken = null;
  } else {
    _selectedPayToken = tok;
  }

  _updatePayTokenBtn();
  updateTradeLabels();

  // Re-load balance for new token
  const marketId = $('app').dataset.marketId;
  if (_connectedAddress && marketId) {
    loadTradeBalance(marketId, $('app').dataset.collateral, 0n, 0n);
  }

  // Clear quote and re-trigger
  _lastQuote = null;
  const input = $('tradeInput');
  if (input && parseFloat(input.value) > 0) {
    onTradeInput();
  }

  closePayTokenModal();
}

function _updatePayTokenBtn() {
  const btn = $('payTokenBtn');
  if (!btn) return;
  const d = getSelectedPayTokenData();
  btn.innerHTML = payTokenIcon(d.symbol) + ' ' + escText(d.symbol) + ' <span style="font-size:9px;opacity:0.5">&#9662;</span>';
}

async function addPredictCustomToken() {
  const addrInput = $('payTokenCustomAddr');
  const statusEl = $('payTokenCustomStatus');
  if (!addrInput) return;
  let address = addrInput.value.trim();
  if (!ethers.isAddress(address)) {
    if (statusEl) statusEl.textContent = 'Invalid address';
    return;
  }
  address = ethers.getAddress(address);
  if (address === ZERO_ADDRESS || address === ethers.ZeroAddress) {
    if (statusEl) statusEl.textContent = 'Use ETH from the list above';
    return;
  }

  // Check if already exists
  const existing = findPayTokenByAddress(address);
  if (existing) {
    selectPayToken(existing.symbol);
    return;
  }

  if (statusEl) statusEl.textContent = 'Loading token info...';

  try {
    const rpc = _walletProvider || new ethers.JsonRpcProvider('https://ethereum.publicnode.com', 1, { staticNetwork: true });
    const code = await rpc.getCode(address);
    if (!code || code === '0x') {
      if (statusEl) statusEl.textContent = 'No contract at this address';
      return;
    }

    const erc20 = new ethers.Contract(address, [
      'function symbol() view returns (string)',
      'function decimals() view returns (uint8)',
    ], rpc);
    const [rawSymbol, rawDecimals] = await Promise.all([erc20.symbol(), erc20.decimals()]);

    const symbol = String(rawSymbol || '').trim().slice(0, 24) || 'TKN';
    const rawDec = Number(rawDecimals);
    const decimals = Number.isInteger(rawDec) && rawDec >= 0 && rawDec <= 36 ? rawDec : 18;

    // Check symbol collision
    const all = getAllPayTokens();
    if (all[symbol] && all[symbol].address.toLowerCase() !== address.toLowerCase()) {
      if (statusEl) statusEl.textContent = `Symbol ${symbol} already used by a different token`;
      return;
    }

    _predictCustomTokens[symbol] = { address, symbol, decimals };
    _savePredictCustomTokens();
    addrInput.value = '';
    if (statusEl) statusEl.textContent = '';
    selectPayToken(symbol);
  } catch (e) {
    console.error('Error adding custom token:', e);
    if (statusEl) statusEl.textContent = 'Failed  ensure valid ERC-20 on Ethereum';
  }
}

function showPayTokenBtn() {
  const btn = $('payTokenBtn');
  if (!btn) return;
  const isLabeled = $('app').dataset.isLabeled === '1';
  // Only show pay token selector for labeled markets (legacy markets only support ETH)
  btn.style.display = (_tradeDir === 'buy' && isLabeled) ? '' : 'none';
  if (_tradeDir === 'buy' && isLabeled) _updatePayTokenBtn();
}

async function loadTradeBalance(marketId, collateral, userYes, userNo) {
  const balEl = $('tradeBalance');
  if (!balEl || !_connectedAddress) return;

  try {
    if (_tradeDir === 'buy') {
      // Use selected pay token if set, otherwise default to collateral
      const payData = getSelectedPayTokenData();
      const isPayETH = payData.address.toLowerCase() === ZERO_ADDRESS.toLowerCase();

      if (isPayETH) {
        const bal = await _walletProvider.getBalance(_connectedAddress);
        balEl.textContent = 'Bal: ' + Number(ethers.formatEther(bal)).toFixed(4) + ' ETH';
        balEl.dataset.balance = bal.toString();
        balEl.dataset.decimals = '18';
      } else {
        try {
          const token = new ethers.Contract(payData.address, ERC20_ABI, _walletProvider);
          const [bal, dec] = await Promise.all([token.balanceOf(_connectedAddress), token.decimals()]);
          const sym = payData.symbol;
          if (bal === 0n && isPayTokenCollateral()) {
            const ethBal = await _walletProvider.getBalance(_connectedAddress);
            const quarter = ethBal / 4n;
            const amt = quarter > 0n ? Number(ethers.formatEther(quarter)).toFixed(4) : '';
            const href = `../?from=ETH&to=${payData.address}${amt ? '&amt=' + amt : ''}`;
            balEl.innerHTML = `Bal: 0  <a href="${href}" style="color:var(--fg);text-decoration:underline">Swap ETH  ${escText(sym)}</a>`;
          } else {
            balEl.textContent = 'Bal: ' + Number(ethers.formatUnits(bal, Number(dec))).toFixed(4) + ' ' + sym;
          }
          balEl.dataset.balance = bal.toString();
          balEl.dataset.decimals = dec.toString();
        } catch {
          balEl.textContent = '';
          balEl.dataset.balance = '0';
          balEl.dataset.decimals = '18';
        }
      }
    } else {
      // Sell: show share balance
      if (userYes > 0n || userNo > 0n) {
        const shares = _tradeSide === 'yes' ? userYes : userNo;
        balEl.textContent = 'Bal: ' + Number(ethers.formatEther(shares)).toFixed(4) + ' shares';
        balEl.dataset.balance = shares.toString();
      } else {
        // Fetch from chain
        const bal = await withRPC(async (rpc) => {
          const pamm = new ethers.Contract(CONTRACTS.PAMM, PAMM_ABI, rpc);
          const yesId = BigInt(marketId);
          const noId = BigInt(ethers.keccak256(ethers.solidityPacked(['string', 'uint256'], ['PMARKET:NO', yesId])));
          const shareId = _tradeSide === 'yes' ? yesId : noId;
          return await pamm.balanceOf(_connectedAddress, shareId);
        });
        balEl.textContent = 'Bal: ' + Number(ethers.formatEther(bal)).toFixed(4) + ' shares';
        balEl.dataset.balance = bal.toString();
      }
    }
  } catch {
    balEl.textContent = '';
  }
}

function _getPayDecimals() {
  const balEl = $('tradeBalance');
  return parseInt(balEl?.dataset.decimals || '18', 10);
}

function _isPayETH() {
  if (_tradeDir !== 'buy') {
    const collateral = $('app').dataset.collateral;
    return !collateral || collateral === ethers.ZeroAddress;
  }
  const d = getSelectedPayTokenData();
  return d.address.toLowerCase() === ZERO_ADDRESS.toLowerCase();
}

function setMaxAmount() {
  const balEl = $('tradeBalance');
  const input = $('tradeInput');
  if (!balEl || !input) return;
  const bal = BigInt(balEl.dataset.balance || '0');
  if (bal === 0n) {
    const marketId = $('app').dataset.marketId;
    if (_connectedAddress && marketId) {
      loadTradeBalance(marketId, $('app').dataset.collateral, 0n, 0n).then(() => {
        const b2 = BigInt(balEl.dataset.balance || '0');
        if (b2 > 0n) setMaxAmount();
      });
    }
    return;
  }
  const dec = _getPayDecimals();
  let amount = bal;
  if (_tradeDir === 'buy' && _isPayETH() && bal > ethers.parseEther('0.001')) {
    amount = bal - ethers.parseEther('0.001');
  }
  input.value = ethers.formatUnits(amount, dec);
  onTradeInput();
}

function setPct(pct) {
  const balEl = $('tradeBalance');
  const input = $('tradeInput');
  if (!balEl || !input) return;
  const bal = BigInt(balEl.dataset.balance || '0');
  if (bal === 0n) {
    // Balance may not have loaded yet  trigger load and retry
    const marketId = $('app').dataset.marketId;
    if (_connectedAddress && marketId) {
      loadTradeBalance(marketId, $('app').dataset.collateral, 0n, 0n).then(() => {
        const b2 = BigInt(balEl.dataset.balance || '0');
        if (b2 > 0n) setPct(pct);
      });
    }
    return;
  }
  const dec = _getPayDecimals();
  let amount = bal * BigInt(Math.round(pct * 10000)) / 10000n;
  if (pct === 1 && _tradeDir === 'buy' && _isPayETH() && amount > ethers.parseEther('0.001')) {
    amount = amount - ethers.parseEther('0.001');
  }
  input.value = ethers.formatUnits(amount, dec);
  onTradeInput();
}

function onTradeInput() {
  clearTimeout(_quoteTimer);
  const input = $('tradeInput');
  const btn = $('tradeBtn');
  const quoteEl = $('tradeQuote');
  if (!input || !btn) return;

  const val = parseFloat(input.value);
  if (!val || val <= 0) {
    btn.textContent = 'Enter amount';
    btn.disabled = true;
    if (quoteEl) quoteEl.textContent = '';
    _lastQuote = null;
    return;
  }

  // Routed buy: non-collateral pay token
  if (_tradeDir === 'buy' && !isPayTokenCollateral()) {
    if (quoteEl) quoteEl.innerHTML = '<span style="color:var(--fg-muted)">Finding best route...</span>';
    btn.textContent = 'Buy ' + _tradeSide.toUpperCase();
    btn.disabled = true;
    _quoteTimer = setTimeout(() => fetchRoutedBuyQuote(input.value.trim()), 500);
    return;
  }

  // Instant local estimate (collateral path)
  const rYes = BigInt($('app').dataset.ammYesReserve || '0');
  const rNo = BigInt($('app').dataset.ammNoReserve || '0');
  const amountWei = ethers.parseEther(val.toString());

  let estimated = 0n;
  if (_tradeDir === 'buy') {
    estimated = _tradeSide === 'yes' ? quoteBuyYes(amountWei, rYes, rNo) : quoteBuyNo(amountWei, rYes, rNo);
    if (quoteEl && estimated > 0n) {
      quoteEl.textContent = '~' + Number(ethers.formatEther(estimated)).toFixed(4) + ' ' + _tradeSide.toUpperCase() + ' shares';
    }
  } else {
    estimated = _tradeSide === 'yes' ? quoteSellYes(amountWei, rYes, rNo) : quoteSellNo(amountWei, rYes, rNo);
    const collateral = $('app').dataset.collateral;
    const collSym = getCollateralSymbol(collateral);
    if (quoteEl && estimated > 0n) {
      quoteEl.textContent = '~' + Number(ethers.formatEther(estimated)).toFixed(4) + ' ' + collSym;
    }
  }

  btn.textContent = _tradeDir === 'buy' ? 'Buy ' + _tradeSide.toUpperCase() : 'Sell ' + _tradeSide.toUpperCase();
  btn.disabled = false;

  // Debounced on-chain quote
  _quoteTimer = setTimeout(() => fetchOnchainQuote(amountWei), 400);
}

async function fetchOnchainQuote(amountWei) {
  const quoteEl = $('tradeQuote');
  const btn = $('tradeBtn');
  const marketId = $('app').dataset.marketId;
  const isLabeled = $('app').dataset.isLabeled === '1';
  if (!marketId || !quoteEl) return;

  try {
    const buyYes = _tradeSide === 'yes';

    if (isLabeled) {
      // Labeled markets: use Quoter contract for accurate sweep quotes
      await withRPC(async (rpc) => {
        const quoter = new ethers.Contract(CONTRACTS.QUOTER, QUOTER_ABI, rpc);
        if (_tradeDir === 'buy') {
          const result = await quoter.quoteBuyWithSweep(marketId, buyYes, amountWei, 9999, { gasLimit: 5000000 });
          const shares = BigInt(result.totalSharesOut);
          const pmShares = BigInt(result.pmSharesOut);
          let quoteHtml = Number(ethers.formatEther(shares)).toFixed(4) + ' ' + _tradeSide.toUpperCase() + ' shares';
          if (pmShares > 0n) {
            const oppSide = buyYes ? 'NO' : 'YES';
            quoteHtml += `<br><span style="font-size:11px;color:var(--fg-muted)">~${Number(ethers.formatEther(pmShares)).toFixed(4)} ${oppSide} minted to vault (withdrawal cooldown)</span>`;
          }
          quoteEl.innerHTML = quoteHtml;
          _lastQuote = { marketId, dir: _tradeDir, side: _tradeSide, amount: amountWei, expectedOut: shares, ts: Date.now() };
        } else {
          const result = await quoter.quoteSellWithSweep(marketId, buyYes, amountWei, 1, { gasLimit: 5000000 });
          const collOut = BigInt(result.totalCollateralOut);
          const collateral = $('app').dataset.collateral;
          const collSym = getCollateralSymbol(collateral);
          quoteEl.textContent = Number(ethers.formatEther(collOut)).toFixed(4) + ' ' + collSym;
          _lastQuote = { marketId, dir: _tradeDir, side: _tradeSide, amount: amountWei, expectedOut: collOut, ts: Date.now() };
        }
        return true;
      });
    } else {
      // Legacy markets: fetch fresh reserves from chain (matching ethPM's fetchLegacyQuote)
      await withRPC(async (rpc) => {
        const pamm = new ethers.Contract(CONTRACTS.PAMM, PAMM_ABI, rpc);
        const poolState = await pamm.getPoolState(BigInt(marketId), LEGACY_FEE_BPS);
        const rYes = poolState.rYes;
        const rNo = poolState.rNo;
        if (rYes === 0n || rNo === 0n) {
          if (quoteEl) quoteEl.textContent = 'No liquidity';
          _lastQuote = null;
          return;
        }
        // Update cached reserves
        $('app').dataset.ammYesReserve = rYes.toString();
        $('app').dataset.ammNoReserve = rNo.toString();
        const collateral = $('app').dataset.collateral;
        const collSym = getCollateralSymbol(collateral);
        if (_tradeDir === 'buy') {
          const shares = buyYes ? quoteBuyYes(amountWei, rYes, rNo, LEGACY_FEE_BPS) : quoteBuyNo(amountWei, rYes, rNo, LEGACY_FEE_BPS);
          if (quoteEl && shares > 0n) quoteEl.textContent = Number(ethers.formatEther(shares)).toFixed(4) + ' ' + _tradeSide.toUpperCase() + ' shares';
          _lastQuote = { marketId, dir: _tradeDir, side: _tradeSide, amount: amountWei, expectedOut: shares, ts: Date.now() };
        } else {
          const collOut = buyYes ? quoteSellYes(amountWei, rYes, rNo, LEGACY_FEE_BPS) : quoteSellNo(amountWei, rYes, rNo, LEGACY_FEE_BPS);
          if (quoteEl && collOut > 0n) quoteEl.textContent = Number(ethers.formatEther(collOut)).toFixed(4) + ' ' + collSym;
          _lastQuote = { marketId, dir: _tradeDir, side: _tradeSide, amount: amountWei, expectedOut: collOut, ts: Date.now() };
        }
        return true;
      });
    }

    if (btn) {
      btn.textContent = _tradeDir === 'buy' ? 'Buy ' + _tradeSide.toUpperCase() : 'Sell ' + _tradeSide.toUpperCase();
      btn.disabled = false;
    }
  } catch (e) {
    console.warn('Quote failed:', e.message);
    if (quoteEl) quoteEl.textContent = 'Quote failed';
    _lastQuote = null;
  }
}


// ==================== ROUTED BUY (any token  collateral  shares) ====================

async function getRoutedBuyQuote(inputAmountStr, marketId, buyYes) {
  const payData = getSelectedPayTokenData();
  const collateral = $('app').dataset.collateral;
  const isETHCollateral = !collateral || collateral === ethers.ZeroAddress;
  const collateralAddr = isETHCollateral ? ZERO_ADDRESS : collateral;
  const amountIn = safeParseUnits(inputAmountStr, payData.decimals);
  const ethIn = payData.address.toLowerCase() === ZERO_ADDRESS.toLowerCase();
  const deadline = BigInt(Math.floor(Date.now() / 1000) + 300);

  return await withRPC(async (rpc) => {
    const quoter = new ethers.Contract(ZQUOTER_ADDRESS, ZQUOTER_IFACE, rpc);
    const pammQuoter = new ethers.Contract(CONTRACTS.QUOTER, QUOTER_ABI, rpc);

    // First leg: swap payToken  collateral via quoter
    let firstLegCalls = [];
    let collateralAmount;
    let msgValue = ethIn ? amountIn : 0n;

    if (ethIn && isETHCollateral) {
      // ETH  ETH: no swap needed (shouldn't reach here, but handle gracefully)
      collateralAmount = amountIn;
    } else if (ethIn && !isETHCollateral) {
      // ETH  ERC20 collateral
      const r = await quoter.buildBestSwapViaETHMulticall(
        ZROUTER_ADDRESS, _connectedAddress, false,
        ZERO_ADDRESS, collateralAddr,
        amountIn, 100n, deadline, 0, 0, ZERO_ADDRESS,
        { gasLimit: 5000000 }
      );
      const isTwoHop = r.b.amountOut > 0n;
      collateralAmount = isTwoHop ? r.b.amountOut : r.a.amountOut;
      firstLegCalls = Array.from(r.calls);
      msgValue = r.msgValue > 0n ? r.msgValue : amountIn;
    } else {
      // ERC20  collateral (via ETH intermediate)
      const r = await quoter.buildBestSwapViaETHMulticall(
        ZROUTER_ADDRESS, _connectedAddress, false,
        payData.address, collateralAddr,
        amountIn, 100n, deadline, 0, 0, ZERO_ADDRESS,
        { gasLimit: 5000000 }
      );
      const isTwoHop = r.b.amountOut > 0n;
      collateralAmount = isTwoHop ? r.b.amountOut : r.a.amountOut;
      firstLegCalls = Array.from(r.calls);
      msgValue = 0n;
    }

    if (collateralAmount <= 0n) throw new Error('Swap quote returned zero');

    // For routed swaps (non-direct ETH), the actual swap output may be slightly less
    // than quoted due to slippage. Use a reduced amount for the second leg to avoid
    // trying to send more ETH/collateral than the router actually received.
    const hasSwapLeg = firstLegCalls.length > 0;
    const collateralForBuy = hasSwapLeg ? collateralAmount * 99n / 100n : collateralAmount;

    // Second leg: PAMM quote  collateral  shares
    const pammResult = await pammQuoter.quoteBuyWithSweep(marketId, buyYes, collateralForBuy, 9999, { gasLimit: 5000000 });
    const sharesOut = BigInt(pammResult.totalSharesOut);
    if (sharesOut <= 0n) throw new Error('PAMM quote returned zero shares');
    const _routedSlipBps = BigInt(Math.round(_tradeSlippage * 100));
    const minSharesOut = sharesOut * (10000n - _routedSlipBps) / 10000n;

    // Build second leg calldata: buyWithSweep via MasterRouter
    const buyCalldata = MASTER_ROUTER_IFACE.encodeFunctionData('buyWithSweep', [
      marketId, buyYes, collateralForBuy, minSharesOut, 9999,
      _connectedAddress, deadline
    ]);

    // Build multicall
    const calls = [];
    for (const c of firstLegCalls) calls.push(c);

    // execute(MASTER_ROUTER, ethValue, buyCalldata)  for ETH-collateral, pass ETH value
    const execEthValue = isETHCollateral ? collateralForBuy : 0n;
    calls.push(ZROUTER_IFACE.encodeFunctionData('execute', [
      CONTRACTS.MASTER_ROUTER, execEthValue, buyCalldata
    ]));

    // Sweep leftovers back to user
    calls.push(ZROUTER_IFACE.encodeFunctionData('sweep', [ZERO_ADDRESS, 0, 0, _connectedAddress]));
    if (!isETHCollateral) {
      calls.push(ZROUTER_IFACE.encodeFunctionData('sweep', [collateralAddr, 0, 0, _connectedAddress]));
    }
    if (!ethIn) {
      calls.push(ZROUTER_IFACE.encodeFunctionData('sweep', [payData.address, 0, 0, _connectedAddress]));
    }

    const multicall = ZROUTER_IFACE.encodeFunctionData('multicall', [calls]);

    return {
      sharesOut, minSharesOut, collateralAmount,
      multicall, calls, msgValue,
      payToken: payData, isRouted: true,
      marketId, dir: 'buy', side: _tradeSide,
      amount: amountIn, expectedOut: sharesOut,
      ts: Date.now()
    };
  });
}

async function getRoutedExactOutBuyQuote(desiredSharesStr, marketId, buyYes) {
  const payData = getSelectedPayTokenData();
  const collateral = $('app').dataset.collateral;
  const isETHCollateral = !collateral || collateral === ethers.ZeroAddress;
  const collateralAddr = isETHCollateral ? ZERO_ADDRESS : collateral;
  const desiredShares = ethers.parseEther(desiredSharesStr);
  const ethIn = payData.address.toLowerCase() === ZERO_ADDRESS.toLowerCase();
  const deadline = BigInt(Math.floor(Date.now() / 1000) + 300);

  return await withRPC(async (rpc) => {
    const pammQuoter = new ethers.Contract(CONTRACTS.QUOTER, QUOTER_ABI, rpc);
    const quoter = new ethers.Contract(ZQUOTER_ADDRESS, ZQUOTER_IFACE, rpc);

    // Iteratively find collateralNeeded
    let c = desiredShares; // initial guess
    for (let i = 0; i < 3; i++) {
      const result = await pammQuoter.quoteBuyWithSweep(marketId, buyYes, c, 9999, { gasLimit: 5000000 });
      const s = BigInt(result.totalSharesOut);
      if (s <= 0n) throw new Error('PAMM quote returned zero');
      if (s >= desiredShares) break;
      c = c * desiredShares / s;
    }
    // Add 2% buffer
    const collateralNeeded = c * 102n / 100n;

    // First leg: exactOut swap  need exactly collateralNeeded of collateral
    let firstLegCalls = [];
    let msgValue = 0n;

    if (ethIn && isETHCollateral) {
      msgValue = collateralNeeded;
    } else {
      const r = await quoter.buildBestSwapViaETHMulticall(
        ZROUTER_ADDRESS, _connectedAddress, true,
        ethIn ? ZERO_ADDRESS : payData.address, collateralAddr,
        collateralNeeded, 100n, deadline, 0, 0, ZERO_ADDRESS,
        { gasLimit: 5000000 }
      );
      firstLegCalls = Array.from(r.calls);
      msgValue = r.msgValue;
    }

    // Second leg  reduce collateral passed to buy to account for swap slippage
    const hasSwapLeg2 = firstLegCalls.length > 0;
    const collateralForBuy2 = hasSwapLeg2 ? collateralNeeded * 99n / 100n : collateralNeeded;
    const _routedSlipBps2 = BigInt(Math.round(_tradeSlippage * 100));
    const minSharesOut = desiredShares * (10000n - _routedSlipBps2) / 10000n;
    const buyCalldata = MASTER_ROUTER_IFACE.encodeFunctionData('buyWithSweep', [
      marketId, buyYes, collateralForBuy2, minSharesOut, 9999,
      _connectedAddress, deadline
    ]);

    const calls = [];
    for (const c2 of firstLegCalls) calls.push(c2);

    const execEthValue = isETHCollateral ? collateralForBuy2 : 0n;
    calls.push(ZROUTER_IFACE.encodeFunctionData('execute', [
      CONTRACTS.MASTER_ROUTER, execEthValue, buyCalldata
    ]));

    calls.push(ZROUTER_IFACE.encodeFunctionData('sweep', [ZERO_ADDRESS, 0, 0, _connectedAddress]));
    if (!isETHCollateral) {
      calls.push(ZROUTER_IFACE.encodeFunctionData('sweep', [collateralAddr, 0, 0, _connectedAddress]));
    }
    if (!ethIn) {
      calls.push(ZROUTER_IFACE.encodeFunctionData('sweep', [payData.address, 0, 0, _connectedAddress]));
    }

    const multicall = ZROUTER_IFACE.encodeFunctionData('multicall', [calls]);

    return {
      sharesOut: desiredShares, minSharesOut, collateralAmount: collateralNeeded,
      multicall, calls, msgValue,
      payToken: payData, isRouted: true,
      marketId, dir: 'buy', side: _tradeSide,
      expectedOut: desiredShares,
      ts: Date.now()
    };
  });
}

async function fetchRoutedBuyQuote(inputAmountStr) {
  const quoteEl = $('tradeQuote');
  const btn = $('tradeBtn');
  const marketId = $('app').dataset.marketId;
  if (!marketId || !quoteEl) return;

  try {
    const buyYes = _tradeSide === 'yes';
    const quote = await getRoutedBuyQuote(inputAmountStr, marketId, buyYes);
    const payData = quote.payToken;
    const collateral = $('app').dataset.collateral;
    const collSym = getCollateralSymbol(collateral);

    quoteEl.innerHTML = Number(ethers.formatEther(quote.sharesOut)).toFixed(4) + ' ' + _tradeSide.toUpperCase() + ' shares' +
      '<br><span style="font-size:11px;color:var(--fg-muted)">' + payData.symbol + '  ' + collSym + '  shares (routed via zRouter)</span>';
    _lastQuote = quote;

    if (btn) {
      btn.textContent = 'Buy ' + _tradeSide.toUpperCase();
      btn.disabled = false;
    }
  } catch (e) {
    console.warn('Routed quote failed:', e.message);
    if (quoteEl) quoteEl.textContent = 'Route not found: ' + (e.message || '').slice(0, 60);
    _lastQuote = null;
  }
}

// ==================== EXECUTE TRADE ====================

async function executeTrade() {
  if (_isTrading) return;
  const s = await connectWallet();
  if (!s) return;

  const btn = $('tradeBtn');
  const quoteEl = $('tradeQuote');
  const marketId = $('app').dataset.marketId;
  const collateral = $('app').dataset.collateral;
  const input = $('tradeInput');
  if (!btn || !marketId || !input) return;

  const val = parseFloat(input.value);
  if (!val || val <= 0) return;
  const amountWei = ethers.parseEther(val.toString());

  const isETH = !collateral || collateral === ethers.ZeroAddress;
  const buyYes = _tradeSide === 'yes';
  const deadline = BigInt(Math.floor(Date.now() / 1000) + 1200); // 20 min
  const origText = btn.textContent;

  _isTrading = true;
  btn.disabled = true;

  const isLabeled = $('app').dataset.isLabeled === '1';

  try {
    // ---- ROUTED BUY (any token  collateral  shares via zRouter) ----
    if (_tradeDir === 'buy' && _lastQuote?.isRouted) {
      if (!_lastQuote || _lastQuote.marketId !== marketId || _lastQuote.dir !== 'buy' || (Date.now() - _lastQuote.ts) >= 30000 || _lastQuote.expectedOut <= 0n) {
        throw new Error('Quote expired  please re-enter amount to get a fresh quote');
      }

      const payData = _lastQuote.payToken;
      const ethIn = payData.address.toLowerCase() === ZERO_ADDRESS.toLowerCase();

      // Resolve token approval: permit  permit2  approve fallback
      let permitPrefix = null; // encoded call to prepend to multicall, or null
      if (!ethIn) {
        btn.textContent = 'Checking approval...';
        const token = new ethers.Contract(payData.address, ERC20_ABI, s);
        const allowance = await token.allowance(_connectedAddress, ZROUTER_ADDRESS);
        const needed = _lastQuote.amount || safeParseUnits(input.value.trim(), payData.decimals);

        if (allowance < needed) {
          // Try 1: EIP-2612 permit (gasless signature, single tx)
          let permitDone = false;
          try {
            const permitCfg = await predictGetPermitConfig(payData.address);
            if (permitCfg) {
              btn.textContent = 'Sign permit...';
              const permitData = await predictSignPermit(permitCfg, payData.address);
              permitPrefix = predictBuildPermitCall(permitData);
              permitDone = true;
            }
          } catch (permitErr) {
            const msg = String(permitErr?.message || '');
            if (/user rejected|user denied|user cancelled/i.test(msg)) throw permitErr;
            console.warn('Permit failed, trying permit2:', permitErr);
            _predictPermitCache.set(payData.address.toLowerCase(), null);
          }

          // Try 2: Permit2 (gasless signature if already approved to Permit2)
          if (!permitDone) {
            try {
              const p2Allowance = await predictCheckPermit2Allowance(payData.address);
              if (p2Allowance >= needed) {
                btn.textContent = 'Sign Permit2...';
                const p2Data = await predictSignPermit2(payData.address, needed);
                permitPrefix = predictBuildPermit2Call(p2Data);
                permitDone = true;
              }
            } catch (p2Err) {
              const msg = String(p2Err?.message || '');
              if (/user rejected|user denied|user cancelled/i.test(msg)) throw p2Err;
              console.warn('Permit2 failed, falling back to approve:', p2Err);
            }
          }

          // Try 3: Classic approve (separate tx)
          if (!permitDone) {
            if (allowance > 0n) {
              btn.textContent = 'Resetting allowance...';
              const resetTx = await token.approve(ZROUTER_ADDRESS, 0);
              await resetTx.wait();
            }
            btn.textContent = 'Approve in wallet...';
            const approveTx = await token.approve(ZROUTER_ADDRESS, ethers.MaxUint256);
            btn.textContent = 'Confirming approval...';
            await approveTx.wait();
          }
        }
      }

      // Re-fetch fresh quote right before tx
      btn.textContent = 'Refreshing quote...';
      const buyYesFresh = _tradeSide === 'yes';
      const freshQuote = await getRoutedBuyQuote(input.value.trim(), marketId, buyYesFresh);

      // If we have a permit call, prepend it to the multicall
      let txData = freshQuote.multicall;
      if (permitPrefix) {
        txData = ZROUTER_IFACE.encodeFunctionData('multicall', [[permitPrefix, ...freshQuote.calls]]);
      }

      btn.textContent = 'Confirm in wallet...';
      const tx = await s.sendTransaction({
        to: ZROUTER_ADDRESS,
        data: txData,
        value: freshQuote.msgValue
      });
      btn.textContent = 'Confirming...';
      if (quoteEl) quoteEl.innerHTML = `<span style="color:var(--fg-muted)">Pending...</span> <a href="https://etherscan.io/tx/${tx.hash}" target="_blank" rel="noopener" style="font-size:11px;color:var(--fg-muted);text-decoration:underline">View on Etherscan</a>`;
      await tx.wait();
      if (quoteEl) quoteEl.innerHTML = `<span style="color:var(--green)">Buy confirmed!</span> <a href="https://etherscan.io/tx/${tx.hash}" target="_blank" rel="noopener" style="font-size:11px;color:var(--fg-muted);text-decoration:underline">View tx</a>`;
      input.value = '';

      setTimeout(() => renderMarketPage(marketId), 2000);
      return;
    }

    const pamm = new ethers.Contract(CONTRACTS.PAMM, PAMM_ABI, s);

    if (isLabeled) {
      // ---- LABELED MARKETS: MASTER_ROUTER with buyWithSweep/sellWithSweep ----
      const router = new ethers.Contract(CONTRACTS.MASTER_ROUTER, MASTER_ROUTER_ABI, s);

      if (_tradeDir === 'buy') {
        if (!_lastQuote || _lastQuote.marketId !== marketId || _lastQuote.dir !== 'buy' || (Date.now() - _lastQuote.ts) >= 30000 || _lastQuote.expectedOut <= 0n) {
          throw new Error('Quote expired  please re-enter amount to get a fresh quote');
        }
        const _buySlipBps = BigInt(Math.round(_tradeSlippage * 100));
        const minSharesOut = _lastQuote.expectedOut * (10000n - _buySlipBps) / 10000n;

        if (!isETH) {
          btn.textContent = 'Checking approval...';
          const token = new ethers.Contract(collateral, ERC20_ABI, s);
          const allowance = await token.allowance(_connectedAddress, CONTRACTS.MASTER_ROUTER);
          if (allowance < amountWei) {
            btn.textContent = 'Approve in wallet...';
            const approveTx = await token.approve(CONTRACTS.MASTER_ROUTER, ethers.MaxUint256);
            btn.textContent = 'Confirming approval...';
            await approveTx.wait();
          }
        }

        btn.textContent = 'Confirm in wallet...';
        const tx = await router.buyWithSweep(
          marketId, buyYes, amountWei, minSharesOut, 9999,
          _connectedAddress, deadline,
          { value: isETH ? amountWei : 0n }
        );
        btn.textContent = 'Confirming...';
        if (quoteEl) quoteEl.innerHTML = `<span style="color:var(--fg-muted)">Pending...</span> <a href="https://etherscan.io/tx/${tx.hash}" target="_blank" rel="noopener" style="font-size:11px;color:var(--fg-muted);text-decoration:underline">View on Etherscan</a>`;
        await tx.wait();
        if (quoteEl) quoteEl.innerHTML = `<span style="color:var(--green)">Buy confirmed!</span> <a href="https://etherscan.io/tx/${tx.hash}" target="_blank" rel="noopener" style="font-size:11px;color:var(--fg-muted);text-decoration:underline">View tx</a>`;
        input.value = '';

      } else {
        if (!_lastQuote || _lastQuote.marketId !== marketId || _lastQuote.dir !== 'sell' || (Date.now() - _lastQuote.ts) >= 30000 || _lastQuote.expectedOut <= 0n) {
          throw new Error('Quote expired  please re-enter amount to get a fresh quote');
        }
        const slipBps = BigInt(Math.round(_tradeSlippage * 100));
        const minCollOut = _lastQuote.expectedOut * (10000n - slipBps) / 10000n;
        btn.textContent = 'Checking approval...';
        const isOp = await pamm.isOperator(_connectedAddress, CONTRACTS.MASTER_ROUTER);
        if (!isOp) {
          btn.textContent = 'Approve operator...';
          const approveTx = await pamm.setOperator(CONTRACTS.MASTER_ROUTER, true);
          btn.textContent = 'Confirming approval...';
          await approveTx.wait();
          // Wait for state propagation after operator approval
          await new Promise(r => setTimeout(r, 1000));
        }
        btn.textContent = 'Confirm in wallet...';
        const tx = await router.sellWithSweep(
          marketId, buyYes, amountWei, minCollOut, 1,
          _connectedAddress, deadline
        );
        btn.textContent = 'Confirming...';
        if (quoteEl) quoteEl.innerHTML = `<span style="color:var(--fg-muted)">Pending...</span> <a href="https://etherscan.io/tx/${tx.hash}" target="_blank" rel="noopener" style="font-size:11px;color:var(--fg-muted);text-decoration:underline">View on Etherscan</a>`;
        await tx.wait();
        if (quoteEl) quoteEl.innerHTML = `<span style="color:var(--green)">Sell confirmed!</span> <a href="https://etherscan.io/tx/${tx.hash}" target="_blank" rel="noopener" style="font-size:11px;color:var(--fg-muted);text-decoration:underline">View tx</a>`;
        input.value = '';
      }

    } else {
      // ---- LEGACY MARKETS: PM_ROUTER with buy/sell (30 bps fee) ----
      const pmRouter = new ethers.Contract(CONTRACTS.PM_ROUTER, PM_ROUTER_ABI, s);

      if (_tradeDir === 'buy') {
        if (!_lastQuote || _lastQuote.marketId !== marketId || _lastQuote.dir !== 'buy' || (Date.now() - _lastQuote.ts) >= 30000 || _lastQuote.expectedOut <= 0n) {
          throw new Error('Quote expired  please re-enter amount to get a fresh quote');
        }
        const _legBuySlipBps = BigInt(Math.round(_tradeSlippage * 100));
        const minSharesOut = _lastQuote.expectedOut * (10000n - _legBuySlipBps) / 10000n;

        if (!isETH) {
          btn.textContent = 'Checking approval...';
          const token = new ethers.Contract(collateral, ERC20_ABI, s);
          const allowance = await token.allowance(_connectedAddress, CONTRACTS.PM_ROUTER);
          if (allowance < amountWei) {
            btn.textContent = 'Approve in wallet...';
            const approveTx = await token.approve(CONTRACTS.PM_ROUTER, ethers.MaxUint256);
            btn.textContent = 'Confirming approval...';
            await approveTx.wait();
          }
        }

        btn.textContent = 'Confirm in wallet...';
        const tx = await pmRouter.buy(
          BigInt(marketId), buyYes, amountWei, minSharesOut,
          LEGACY_FEE_BPS, _connectedAddress, deadline,
          { value: isETH ? amountWei : 0n }
        );
        btn.textContent = 'Confirming...';
        if (quoteEl) quoteEl.innerHTML = `<span style="color:var(--fg-muted)">Pending...</span> <a href="https://etherscan.io/tx/${tx.hash}" target="_blank" rel="noopener" style="font-size:11px;color:var(--fg-muted);text-decoration:underline">View on Etherscan</a>`;
        await tx.wait();
        if (quoteEl) quoteEl.innerHTML = `<span style="color:var(--green)">Buy confirmed!</span> <a href="https://etherscan.io/tx/${tx.hash}" target="_blank" rel="noopener" style="font-size:11px;color:var(--fg-muted);text-decoration:underline">View tx</a>`;
        input.value = '';

      } else {
        if (!_lastQuote || _lastQuote.marketId !== marketId || _lastQuote.dir !== 'sell' || (Date.now() - _lastQuote.ts) >= 30000 || _lastQuote.expectedOut <= 0n) {
          throw new Error('Quote expired  please re-enter amount to get a fresh quote');
        }
        const _legSellSlipBps = BigInt(Math.round(_tradeSlippage * 100));
        const minCollOut = _lastQuote.expectedOut * (10000n - _legSellSlipBps) / 10000n;
        btn.textContent = 'Checking approval...';
        const isOp = await pamm.isOperator(_connectedAddress, CONTRACTS.PM_ROUTER);
        if (!isOp) {
          btn.textContent = 'Approve operator...';
          const approveTx = await pamm.setOperator(CONTRACTS.PM_ROUTER, true);
          btn.textContent = 'Confirming approval...';
          await approveTx.wait();
          await new Promise(r => setTimeout(r, 1000));
        }
        btn.textContent = 'Confirm in wallet...';
        const tx = await pmRouter.sell(
          BigInt(marketId), buyYes, amountWei, minCollOut,
          LEGACY_FEE_BPS, _connectedAddress, deadline
        );
        btn.textContent = 'Confirming...';
        if (quoteEl) quoteEl.innerHTML = `<span style="color:var(--fg-muted)">Pending...</span> <a href="https://etherscan.io/tx/${tx.hash}" target="_blank" rel="noopener" style="font-size:11px;color:var(--fg-muted);text-decoration:underline">View on Etherscan</a>`;
        await tx.wait();
        if (quoteEl) quoteEl.innerHTML = `<span style="color:var(--green)">Sell confirmed!</span> <a href="https://etherscan.io/tx/${tx.hash}" target="_blank" rel="noopener" style="font-size:11px;color:var(--fg-muted);text-decoration:underline">View tx</a>`;
        input.value = '';
      }
    }

    // Refresh market data after trade
    setTimeout(() => renderMarketPage(marketId), 2000);

  } catch (e) {
    if (!isUserRejection(e)) {
      console.error('Trade failed:', e);
      if (quoteEl) quoteEl.textContent = 'Failed: ' + decodeError(e);
    }
  } finally {
    btn.textContent = origText;
    btn.disabled = false;
    _isTrading = false;
  }
}

// ==================== RESOLUTION DISPLAY ====================

function buildResolutionSection(marketId, data) {
  const { resolved, outcome, resValue, resCond, resReady, condData, close, canClose, resolverAddr, isOurResolver, isLegacyResolver } = data;
  const resolverName = (isOurResolver || isLegacyResolver) ? 'Onchain Resolver' : `${resolverAddr.slice(0,6)}...${resolverAddr.slice(-4)}`;
  const resolverLink = `<a href="https://etherscan.io/address/${resolverAddr}" target="_blank" rel="noopener" onclick="event.stopPropagation()" style="color:inherit;text-decoration:underline;text-decoration-color:#0FF;">${resolverName}</a>`;

  // Determine status badge
  let statusText, statusClass;
  if (resolved) {
    const winner = outcome ? 'YES' : 'NO';
    statusText = `RESOLVED ${winner}`;
    statusClass = 'resolved';
  } else if (resReady && resCond) {
    statusText = 'READY';
    statusClass = 'ready';
  } else if (resReady && !resCond) {
    statusText = 'CLOSED';
    statusClass = 'ready';
  } else {
    statusText = 'PENDING';
    statusClass = 'pending';
  }

  let detailsHtml = '';

  if (resolved) {
    const winner = outcome ? 'YES' : 'NO';
    detailsHtml = `<div style="text-align:center;padding:12px;"><div style="font-size:24px;margin-bottom:8px;">${outcome ? '&#10003;' : '&#10007;'}</div><div style="font-weight:bold;color:${outcome ? 'var(--yes)' : 'var(--no)'}">${winner} WINS</div></div>`;
  } else if (condData) {
    detailsHtml = buildConditionDetails(marketId, data);
  } else {
    // No condition data - show basic preview
    detailsHtml = `<div class="resolve-condition" style="text-align:center;">`;
    if (resValue !== null) {
      detailsHtml += `Oracle value: <b>${Number(resValue).toLocaleString()}</b><br>`;
      detailsHtml += `Condition: <b style="color:${resCond ? 'var(--yes)' : 'var(--no)'}">${resCond ? 'TRUE' : 'FALSE'}</b>`;
    } else {
      detailsHtml += `<span style="opacity:0.5">Loading oracle data...</span>`;
    }
    detailsHtml += `</div>`;
    if (!resolved && resReady) {
      detailsHtml += `<button class="resolve-btn" id="resolveBtn" onclick="resolveMarket('${marketId}')">RESOLVE MARKET</button>`;
    }
  }

  return `
    <div class="resolve-section" id="resolveSection">
      <div class="resolve-toggle${resReady && !resolved ? ' expanded' : ''}" id="resolveToggle" onclick="toggleResolveDetails()">
        <span id="resolveToggleLabel">${resolverLink}</span>
        <span class="resolve-toggle-status ${statusClass}" id="resolveToggleStatus">${statusText}</span>
      </div>
      <div class="resolve-details${resReady && !resolved ? ' ready expanded' : ''}" id="resolveDetails">
        ${detailsHtml}
      </div>
    </div>
  `;
}

function buildConditionDetails(marketId, data) {
  const { resValue, resCond, resReady, condData, close, canClose } = data;
  const value = resValue;
  const oracleAddr = condData.targetA;
  let callData = condData.callDataA;
  if (callData && typeof callData !== 'string') {
    try { callData = ethers.hexlify(callData); } catch { callData = ''; }
  }
  callData = callData || '';
  const opName = OPS[Number(condData.op)] || '?';

  const callDataLower = callData.toLowerCase();
  const isBalanceOfCall = callData.length >= 74 && callDataLower.slice(0, 10) === '0x70a08231';
  const isLatestAnswerCall = callData.length >= 10 && callDataLower.slice(0, 10) === '0x50d25bcd';
  const isTotalSupplyCall = callData.length >= 10 && callDataLower.slice(0, 10) === '0x18160ddd';
  const isETHBalanceCheck = oracleAddr && (!callData || callData === '0x' || callData.length < 10);
  const isAddressExistenceCheck = Number(condData.op) === 5 && Number(condData.threshold) === 0;

  // Determine decimals, prefix, suffix, oracleHtml
  let decimals = 8, prefix = '$', suffix = '', oracleHtml = '';

  if (isBalanceOfCall) {
    const accountAddr = '0x' + callData.slice(34, 74);
    decimals = 18;
    prefix = '';
    const accountName = ACCOUNT_NAMES[accountAddr.toLowerCase()] || `${accountAddr.slice(0,6)}...${accountAddr.slice(-4)}`;
    const tokenName = TOKEN_NAMES[oracleAddr.toLowerCase()] || `${oracleAddr.slice(0,6)}...${oracleAddr.slice(-4)}`;
    const tokenLogo = TOKEN_LOGOS[oracleAddr.toLowerCase()] || '';
    const tokenColor = COLORS[tokenName?.toUpperCase()] || '#375BD2';
    suffix = ` ${tokenName}`;
    oracleHtml = `<a href="https://etherscan.io/address/${accountAddr}" target="_blank" rel="noopener" style="color:inherit;text-decoration:underline;text-decoration-color:${tokenColor}" title="${accountAddr}">${accountName}</a>`;
    oracleHtml += ` <span style="opacity:0.5">bal on</span> `;
    oracleHtml += `<a href="https://etherscan.io/token/${oracleAddr}" target="_blank" rel="noopener" style="color:inherit;text-decoration:underline;text-decoration-color:${tokenColor}" title="${oracleAddr}">${tokenLogo}${tokenName}</a>`;
  } else if (isETHBalanceCheck) {
    // Could be ETH balance OR legacy token balance with non-standard format
    // Legacy markets store token addr in targetA with empty calldata
    const oracleLower = oracleAddr.toLowerCase();
    const knownTokenSym = TOKEN_NAMES[oracleLower];
    if (knownTokenSym) {
      // Legacy token balance market - oracleAddr is the token, targetB is the account
      const accountAddr = condData.targetB && condData.targetB !== ethers.ZeroAddress
        ? condData.targetB : oracleAddr;
      decimals = 18;
      prefix = '';
      suffix = ` ${knownTokenSym}`;
      const accountName = ACCOUNT_NAMES[accountAddr.toLowerCase()] || `${accountAddr.slice(0,6)}...${accountAddr.slice(-4)}`;
      const tokenLogo = TOKEN_LOGOS[oracleLower] || '';
      const tokenColor = COLORS[knownTokenSym.toUpperCase()] || '#375BD2';
      oracleHtml = `<a href="https://etherscan.io/address/${accountAddr}" target="_blank" rel="noopener" style="color:inherit;text-decoration:underline;text-decoration-color:${tokenColor}" title="${accountAddr}">${accountName}</a>`;
      oracleHtml += ` <span style="opacity:0.5">bal on</span> `;
      oracleHtml += `<a href="https://etherscan.io/token/${oracleAddr}" target="_blank" rel="noopener" style="color:inherit;text-decoration:underline;text-decoration-color:${tokenColor}" title="${oracleAddr}">${tokenLogo}${knownTokenSym}</a>`;
    } else {
      // ETH balance market
      decimals = 18;
      prefix = '';
      suffix = ' ETH';
      const shortAccount = `${oracleAddr.slice(0,6)}...${oracleAddr.slice(-4)}`;
      const ethLogo = TOKEN_LOGOS['eth'] || '';
      oracleHtml = `<a href="https://etherscan.io/address/${oracleAddr}" target="_blank" rel="noopener" style="color:inherit;text-decoration:underline;text-decoration-color:#627EEA" title="${oracleAddr}">${shortAccount}</a> <span style="opacity:0.5">${ethLogo}ETH bal</span>`;
    }
  } else if (isLatestAnswerCall) {
    decimals = 8;
    prefix = '$';
    suffix = '';
    const shortOracle = `${oracleAddr.slice(0,6)}...${oracleAddr.slice(-4)}`;
    const chainlinkLogo = TOKEN_LOGOS['0x514910771af9ca656af840dff83e8264ecf986ca'] || '';
    oracleHtml = `<a href="https://etherscan.io/address/${oracleAddr}" target="_blank" rel="noopener" style="color:inherit;text-decoration:underline;text-decoration-color:#375BD2" title="Chainlink price feed">${chainlinkLogo}${shortOracle}</a> <span style="opacity:0.5">price feed</span>`;
  } else if (isTotalSupplyCall) {
    decimals = 0;
    prefix = '';
    suffix = ' minted';
    const shortAddr = `${oracleAddr.slice(0,6)}...${oracleAddr.slice(-4)}`;
    const name = TOKEN_NAMES[oracleAddr.toLowerCase()] || shortAddr;
    const logo = TOKEN_LOGOS[oracleAddr.toLowerCase()] || '';
    oracleHtml = `<a href="https://etherscan.io/address/${oracleAddr}" target="_blank" rel="noopener" style="color:inherit;text-decoration:underline;text-decoration-color:#9945FF" title="${oracleAddr}">${logo}${name}</a> <span style="opacity:0.5">totalSupply</span>`;
  } else {
    // Unknown type
    const threshold = Number(condData.threshold);
    if (threshold > 1e15) { decimals = 18; prefix = ''; suffix = ' units'; }
    const shortOracle = `${oracleAddr.slice(0,6)}...${oracleAddr.slice(-4)}`;
    oracleHtml = `<a href="https://etherscan.io/address/${oracleAddr}" target="_blank" rel="noopener" style="color:inherit;text-decoration:underline;text-decoration-color:#666">${shortOracle}</a>`;
  }

  const now = Math.floor(Date.now() / 1000);
  const isClosed = close && close <= now;
  const deadlineText = isClosed
    ? '<span style="color:var(--yes)">Market closed</span>'
    : close ? `Closes ${fmtCountdown(close)}` : '';

  let conditionHtml;

  if (isAddressExistenceCheck) {
    // Special binary layout for address existence checks
    const rawValue = BigInt(value);
    const isSet = rawValue !== 0n;
    let valueDisplay;
    if (isSet && rawValue <= BigInt('0xffffffffffffffffffffffffffffffffffffffff')) {
      const addrHex = '0x' + rawValue.toString(16).padStart(40, '0');
      valueDisplay = `<a href="https://etherscan.io/address/${addrHex}" target="_blank" rel="noopener" style="color:var(--yes);text-decoration:underline">${addrHex.slice(0,6)}...${addrHex.slice(-4)}</a>`;
    } else if (isSet) {
      valueDisplay = `<span style="color:var(--yes)">${rawValue.toString()}</span>`;
    } else {
      valueDisplay = '<span style="color:var(--no);opacity:0.7">Not Set</span>';
    }
    const parsedCall = parseCalldata(callData, oracleAddr);
    let conditionLabel = 'Value';
    let functionDisplay = '';
    if (parsedCall.functionName === 'protocolFeeController') {
      conditionLabel = 'Protocol Fee Controller';
      functionDisplay = `<code style="font-size:10px;opacity:0.6;background:var(--surface);padding:2px 6px;border-radius:3px;">protocolFeeController()</code>`;
    } else if (parsedCall.parsed) {
      conditionLabel = parsedCall.parsed.replace(/<[^>]*>/g, '').replace(/\(\).*$/, '');
    }
    const statusIcon = isSet ? '&#10003;' : '&#9675;';
    const statusColor = isSet ? 'var(--yes)' : '#F50';
    const statusTextVal = isSet ? 'ENABLED' : 'NOT SET';
    conditionHtml = `
      <div class="resolve-condition" style="text-align:center;">
        <div style="font-size:10px;opacity:0.5;margin-bottom:4px;">${oracleHtml}</div>
        ${functionDisplay ? `<div style="margin-bottom:8px;">${functionDisplay}</div>` : ''}
        <div style="font-size:11px;opacity:0.6;margin-bottom:4px;">${conditionLabel}</div>
        <div style="font-size:32px;margin:8px 0;color:${statusColor}">${statusIcon}</div>
        <div style="font-weight:bold;color:${statusColor};margin-bottom:8px;">${statusTextVal}</div>
        <div style="font-size:12px;font-family:monospace;">${valueDisplay}</div>
      </div>
    `;
  } else {
    // Standard progress bar
    const valueFormatted = Number(value) / Math.pow(10, decimals);
    const thresholdFormatted = Number(condData.threshold) / Math.pow(10, decimals);
    const formatVal = (v) => {
      if (v >= 1e9) return (v / 1e9).toFixed(2) + 'B';
      if (v >= 1e6) return (v / 1e6).toFixed(2) + 'M';
      if (v >= 1e3) return (v / 1e3).toFixed(2) + 'K';
      if (v < 0.01 && v > 0) return v.toFixed(6);
      return v.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
    };
    const op = Number(condData.op);
    const isFallBelow = op === 0 || op === 2; // LT or LTE
    let progressPct;
    if (isFallBelow) {
      // Value needs to fall below threshold  progress = how far it has dropped
      // Use 2x threshold as the "starting" reference so the bar empties as value approaches threshold
      progressPct = thresholdFormatted > 0
        ? Math.max(0, Math.min(100, (1 - (valueFormatted - thresholdFormatted) / thresholdFormatted) * 100)) : 0;
    } else {
      progressPct = thresholdFormatted > 0
        ? Math.min(100, (valueFormatted / thresholdFormatted) * 100) : 0;
    }
    const conditionVerb = isFallBelow ? 'falls below' : 'reaches';
    conditionHtml = `
      <div class="resolve-condition">
        <div class="resolve-condition-target">${oracleHtml || 'Oracle value'}</div>
        <div style="margin-top:6px;">${conditionVerb} <span class="resolve-condition-thresh">${opName} ${prefix}${formatVal(thresholdFormatted)}${suffix}</span></div>
      </div>
      <div class="resolve-progress">
        <div class="resolve-progress-bar${resCond ? ' met' : ''}">
          <span class="filled">${'\u2588'.repeat(Math.round(progressPct / 5))}</span><span class="empty">${'\u2591'.repeat(20 - Math.round(progressPct / 5))}</span>
        </div>
        <div class="resolve-progress-text">
          <span><span class="resolve-condition-val">${prefix}${formatVal(valueFormatted)}${suffix}</span></span>
          <span>${progressPct.toFixed(1)}%</span>
        </div>
      </div>
    `;
  }

  // Build inspect panel
  const opNames = ['<', '>', '', '', '=', ''];
  let inspectHtml = `
    <div class="inspect-row"><span class="inspect-label">targetA</span><span class="inspect-value"><a href="https://etherscan.io/address/${condData.targetA}" target="_blank" rel="noopener">${condData.targetA}</a></span></div>
    <div class="inspect-row"><span class="inspect-label">targetB</span><span class="inspect-value">${condData.targetB === ethers.ZeroAddress ? '(none)' : `<a href="https://etherscan.io/address/${condData.targetB}" target="_blank" rel="noopener">${condData.targetB}</a>`}</span></div>
    <div class="inspect-row"><span class="inspect-label">op</span><span class="inspect-value">${condData.op} (${opNames[Number(condData.op)] || '?'})</span></div>
    <div class="inspect-row"><span class="inspect-label">isRatio</span><span class="inspect-value">${condData.isRatio}</span></div>
    <div class="inspect-row"><span class="inspect-label">threshold</span><span class="inspect-value">${condData.threshold.toString()}</span></div>
    ${formatCalldataHtml(condData.callDataA, condData.targetA, 'callDataA')}
    ${formatCalldataHtml(condData.callDataB, condData.targetB, 'callDataB')}
  `;

  return `
    ${conditionHtml}
    ${deadlineText ? `<div style="text-align:center;font-size:11px;margin-bottom:12px;font-family:monospace;opacity:0.8">[${deadlineText}]</div>` : ''}
    <button class="resolve-btn" id="resolveBtn" onclick="resolveMarket('${marketId}')" ${resReady ? '' : 'disabled'}>RESOLVE MARKET</button>
    <div class="resolve-hint">${resReady
      ? 'Condition met! Click to settle the market.'
      : isClosed ? 'Market closed - can resolve with current value' : 'Unlocks when threshold reached or market closes'}</div>
    <button class="inspect-toggle" onclick="toggleInspect()">&#9660; Inspect On-Chain Condition</button>
    <div class="inspect-panel" id="inspectPanel">${inspectHtml}</div>
  `;
}

function toggleResolveDetails() {
  const toggle = $('resolveToggle');
  const details = $('resolveDetails');
  if (toggle && details) {
    toggle.classList.toggle('expanded');
    details.classList.toggle('expanded');
  }
}

function toggleInspect() {
  const panel = $('inspectPanel');
  const toggle = panel?.previousElementSibling;
  if (panel) {
    const expanded = panel.classList.toggle('expanded');
    if (toggle) toggle.innerHTML = expanded ? '&#9650; Hide Condition Details' : '&#9660; Inspect On-Chain Condition';
  }
}

// ==================== RESOLVE & CLAIM ====================

async function resolveMarket(marketId) {
  const s = await connectWallet();
  if (!s) return;
  const btn = $('resolveBtn');
  if (!btn) return;
  const origText = btn.textContent;
  btn.textContent = 'Resolving...';
  btn.disabled = true;
  try {
    const resolverAddr = $('app').dataset.resolverAddr || CONTRACTS.RESOLVER;
    const isOurResolver = $('app').dataset.isOurResolver === '1';
    const resolverAbi = isOurResolver ? RESOLVER_ABI : LEGACY_RESOLVER_ABI;
    const resolver = new ethers.Contract(resolverAddr, resolverAbi, s);
    const tx = await resolver.resolveMarket(marketId);
    btn.innerHTML = `Confirming... <a href="https://etherscan.io/tx/${tx.hash}" target="_blank" rel="noopener" style="color:inherit;text-decoration:underline;font-size:11px">tx &#8599;</a>`;
    await tx.wait();
    btn.innerHTML = `Resolved! <a href="https://etherscan.io/tx/${tx.hash}" target="_blank" rel="noopener" style="color:inherit;text-decoration:underline;font-size:11px">tx &#8599;</a>`;
    setTimeout(() => renderMarketPage(marketId), 2000);
  } catch (e) {
    if (!isUserRejection(e)) btn.textContent = 'Failed';
    setTimeout(() => { btn.textContent = origText; btn.disabled = false; }, 2000);
  }
}

async function claimWinnings(marketId) {
  const s = await connectWallet();
  if (!s) return;
  const btn = $('claimBtn');
  const quoteEl = $('claimQuote');
  if (!btn) return;
  const origText = btn.textContent;
  btn.textContent = 'Claiming...';
  btn.disabled = true;
  try {
    const pamm = new ethers.Contract(CONTRACTS.PAMM, PAMM_ABI, s);
    const tx = await pamm.claim(marketId, _connectedAddress);
    btn.textContent = 'Confirming...';
    if (quoteEl) quoteEl.innerHTML = `<span style="color:var(--fg-muted)">Pending...</span> <a href="https://etherscan.io/tx/${tx.hash}" target="_blank" rel="noopener" style="font-size:11px;color:var(--fg-muted);text-decoration:underline">View on Etherscan</a>`;
    await tx.wait();
    btn.textContent = 'Claimed!';
    btn.style.background = 'var(--green)';
    if (quoteEl) quoteEl.innerHTML = `<span style="color:var(--green)">Claimed!</span> <a href="https://etherscan.io/tx/${tx.hash}" target="_blank" rel="noopener" style="font-size:11px;color:var(--fg-muted);text-decoration:underline">View tx</a>`;
    setTimeout(() => renderMarketPage(marketId), 2000);
  } catch (e) {
    if (!isUserRejection(e)) btn.textContent = 'Failed';
    else btn.textContent = origText;
    btn.disabled = false;
  }
}

async function resolveCustomMarket(marketId, outcomeYes) {
  const s = await connectWallet();
  if (!s) return;
  const btnId = outcomeYes ? 'resolveYesBtn' : 'resolveNoBtn';
  const btn = $(btnId);
  if (!btn) return;
  const origText = btn.textContent;
  btn.textContent = 'Resolving...';
  btn.disabled = true;
  // Disable the other button too
  const otherId = outcomeYes ? 'resolveNoBtn' : 'resolveYesBtn';
  const otherBtn = $(otherId);
  if (otherBtn) otherBtn.disabled = true;
  try {
    // For custom EOA resolvers: if market hasn't reached close time yet,
    // call closeMarket first (requires canClose=true), then resolve
    const pammIface = new ethers.Interface([
      'function resolve(uint256 marketId, bool outcome)',
      'function closeMarket(uint256 marketId)',
      'function multicall(bytes[] calldata data) returns (bytes[])',
      'function markets(uint256) view returns (address resolver, bool resolved, bool outcome, bool canClose, uint64 close, address collateral, uint256 collateralLocked)'
    ]);
    const pamm = new ethers.Contract(CONTRACTS.PAMM, pammIface, s);
    const mktData = await pamm.markets(BigInt(marketId));
    const closeTime = Number(mktData.close);
    const now = Math.floor(Date.now() / 1000);
    let tx;
    if (closeTime > now) {
      // Market not yet closed  multicall closeMarket + resolve in one tx
      btn.textContent = 'Closing & resolving...';
      const closeData = pammIface.encodeFunctionData('closeMarket', [BigInt(marketId)]);
      const resolveData = pammIface.encodeFunctionData('resolve', [BigInt(marketId), outcomeYes]);
      tx = await pamm.multicall([closeData, resolveData]);
    } else {
      btn.textContent = 'Resolving...';
      tx = await pamm.resolve(BigInt(marketId), outcomeYes);
    }
    btn.innerHTML = `Confirming... <a href="https://etherscan.io/tx/${tx.hash}" target="_blank" rel="noopener" style="color:inherit;text-decoration:underline;font-size:11px">tx &#8599;</a>`;
    await tx.wait();
    btn.innerHTML = `${outcomeYes ? 'Resolved YES!' : 'Resolved NO!'} <a href="https://etherscan.io/tx/${tx.hash}" target="_blank" rel="noopener" style="color:inherit;text-decoration:underline;font-size:11px">tx &#8599;</a>`;
    setTimeout(() => renderMarketPage(marketId), 2000);
  } catch (e) {
    if (!isUserRejection(e)) btn.textContent = 'Failed: ' + decodeError(e).slice(0, 50);
    setTimeout(() => { btn.textContent = origText; btn.disabled = false; if (otherBtn) otherBtn.disabled = false; }, 3000);
  }
}

// ==================== CREATE MARKET ====================

function openCreateModal() {
  $('createModal').classList.add('active');
  loadEthPrice();
  updateLiqSplit();
  if (location.hash.replace('#','').trim() !== 'create') {
    history.replaceState(null, '', location.pathname + '#create');
  }
  setDatePreset(30, 'closeDate');
  updateCreateBtn();
  updateCreateDeeplink();
}
function closeCreateModal() {
  $('createModal').classList.remove('active');
  history.replaceState(null, '', location.pathname);
}

function switchMarketType(type) {
  _currentMarketType = type;
  document.querySelectorAll('.market-type-tab').forEach(t => t.classList.remove('active'));
  document.querySelectorAll('.form-section').forEach(s => s.classList.remove('active'));
  const tabs = document.querySelectorAll('.market-type-tab');
  const idx = { price: 0, balance: 1, supply: 2, custom: 3 }[type] || 0;
  if (tabs[idx]) tabs[idx].classList.add('active');
  const formId = { price: 'priceForm', balance: 'balanceForm', supply: 'supplyForm', custom: 'customForm' }[type];
  const form = $(formId);
  if (form) form.classList.add('active');
  const hints = { price: 'Will an asset hit a target price?', balance: 'Will a wallet hold a minimum balance?', supply: "Will a token\u2019s supply cross a threshold?", custom: 'Create a custom yes/no market' };
  const h = $('tabHint'); if (h) h.textContent = hints[type] || '';
  updateCreateBtn();
  updateCreateDeeplink();
}

async function loadEthPrice() {
  const el = $('livePrice');
  if (!el) return;
  el.textContent = '...';
  try {
    await withRPC(async rpc => {
      const chainlink = new ethers.Contract(CONTRACTS.CHAINLINK_ETH_USD, CHAINLINK_ABI, rpc);
      const price = await chainlink.latestAnswer();
      _currentEthPrice = Number(price) / 1e8;
      el.textContent = '$' + _currentEthPrice.toLocaleString('en-US', { maximumFractionDigits: 0 });
      return true;
    });
  } catch { el.textContent = '--'; }
}

function fmtTargetPrice() {
  const el = $('targetPrice');
  if (!el) return;
  const raw = el.value.replace(/[^0-9]/g, '');
  if (raw) el.value = Number(raw).toLocaleString();
}

let _priceDir = 'up';

function setPriceDir(dir) {
  _priceDir = dir;
  const btns = $('priceDirection').querySelectorAll('button');
  btns.forEach(b => b.classList.toggle('active', b.dataset.dir === dir));
  // Update presets
  const presets = $('pricePresets');
  if (dir === 'down') {
    presets.innerHTML = `
      <button type="button" class="date-preset" onclick="setPricePreset(0)">current</button>
      <button type="button" class="date-preset" onclick="setPricePreset(-5)">-5%</button>
      <button type="button" class="date-preset" onclick="setPricePreset(-10)">-10%</button>
      <button type="button" class="date-preset" onclick="setPricePreset(-50)">-50%</button>
    `;
  } else {
    presets.innerHTML = `
      <button type="button" class="date-preset" onclick="setPricePreset(0)">current</button>
      <button type="button" class="date-preset" onclick="setPricePreset(5)">+5%</button>
      <button type="button" class="date-preset" onclick="setPricePreset(10)">+10%</button>
      <button type="button" class="date-preset" onclick="setPricePreset(100)">+100%</button>
    `;
  }
  updatePricePreview();
}

function setPricePreset(pct) {
  if (!_currentEthPrice) return;
  const target = pct === 0 ? Math.round(_currentEthPrice) : Math.round(_currentEthPrice * (1 + pct / 100));
  $('targetPrice').value = target.toLocaleString();
  updatePricePreview();
  updateCreateBtn();
}

function updatePricePreview() {
  const el = $('pricePreview');
  if (!el) return;
  const raw = ($('targetPrice').value || '').replace(/[^0-9]/g, '');
  const price = raw ? '$' + Number(raw).toLocaleString() : '$___';
  const dateStr = $('closeDate').value;
  const date = dateStr ? fmtDate(Math.floor(new Date(dateStr).getTime() / 1000)) : '___';
  const verb = _priceDir === 'down' ? 'drop to' : 'hit';
  el.innerHTML = `Will ETH ${verb} <b>${price}</b> by <b>${date}</b>?`;
  updateCreateDeeplink();
}

function setDatePreset(days, inputId) {
  const el = $(inputId);
  if (!el) return;
  const d = new Date(Date.now() + days * 86400000);
  d.setHours(23, 59, 0, 0);
  el.value = d.toISOString().slice(0, 16);
  el.dispatchEvent(new Event('input'));
  updateDateHint(inputId);
}

function updateDateHint(inputId) {
  const el = $(inputId);
  const hint = $(inputId + 'Hint');
  if (!el || !hint) return;
  const v = el.value;
  if (!v) { hint.textContent = ''; return; }
  const d = new Date(v);
  const now = new Date();
  const diff = Math.round((d - now) / 86400000);
  const fmt = d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
  hint.textContent = diff > 0 ? fmt + ' \u2014 ' + diff + ' day' + (diff !== 1 ? 's' : '') + ' from now' : fmt;
}

function updateCreateBtn() {
  const btn = $('createBtn');
  if (!btn) return;
  const type = _currentMarketType || 'price';
  let missing = '';
  if (type === 'price') {
    const tp = ($('targetPrice').value || '').replace(/[^0-9]/g, '');
    if (!tp) missing = 'Enter target price';
    else if (!$('closeDate').value) missing = 'Set resolution date';
  } else if (type === 'balance') {
    if (!($('balWalletAddr').value || '').trim()) missing = 'Enter wallet address';
    else if (!$('balThreshold').value) missing = 'Enter minimum balance';
    else if (!$('balCloseDate').value) missing = 'Set resolution date';
  } else if (type === 'supply') {
    if (!($('supplyTokenAddr').value || '').trim()) missing = 'Enter token address';
    else if (!$('supplyThreshold').value) missing = 'Enter threshold';
    else if (!$('supplyCloseDate').value) missing = 'Set resolution date';
  } else if (type === 'custom') {
    if (!($('customQuestion').value || '').trim()) missing = 'Enter question';
    else if (!($('customResolver').value || '').trim()) missing = 'Enter resolver address';
    else if (!$('customCloseDate').value) missing = 'Set resolution date';
  }
  if (missing) {
    btn.textContent = missing;
    btn.disabled = true;
  } else {
    btn.textContent = 'Create Market';
    btn.disabled = false;
  }
}

function setBalanceType(type) {
  _balanceAssetType = type;
  document.querySelectorAll('.balance-type-btn').forEach(b => b.classList.remove('active'));
  if (type === 'eth') {
    document.querySelector('.balance-type-btn:first-child').classList.add('active');
    $('balTokenGroup').style.display = 'none';
  } else {
    document.querySelector('.balance-type-btn:last-child').classList.add('active');
    $('balTokenGroup').style.display = '';
  }
  updateBalPreview();
}

function setBalanceDir(dir) {
  _balanceDir = dir;
  const btns = $('balanceDirection').querySelectorAll('button');
  btns.forEach(b => b.classList.toggle('active', b.dataset.dir === dir));
  updateBalPreview();
}

async function loadBalTokenInfo() {
  const addr = ($('balTokenAddr').value || '').trim();
  const hint = $('balTokenHint');
  if (!addr || addr.length < 42) { hint.textContent = ''; _balTokenData = { address: '', symbol: '', decimals: 18 }; return; }
  try {
    await withRPC(async rpc => {
      const token = new ethers.Contract(addr, ERC20_ABI, rpc);
      const [sym, dec] = await Promise.all([token.symbol(), token.decimals()]);
      _balTokenData = { address: addr, symbol: sym, decimals: Number(dec) };
      hint.textContent = sym + ' (' + Number(dec) + ' decimals)';
      return true;
    });
  } catch { hint.textContent = 'Could not load token info'; }
  updateBalPreview();
}

function updateBalPreview() {
  const el = $('balancePreview');
  if (!el) return;
  const raw = ($('balWalletAddr').value || '').trim();
  const resolved = getBalWalletAddress();
  const short = resolved ? resolved.slice(0, 6) + '...' + resolved.slice(-4)
    : (raw.endsWith('.wei') || raw.endsWith('.eth')) ? raw : (raw.length >= 42 ? raw.slice(0, 6) + '...' + raw.slice(-4) : 'address');
  const threshold = $('balThreshold').value || '___';
  const asset = _balanceAssetType === 'eth' ? 'ETH' : (_balTokenData.symbol || 'tokens');
  const dateStr = $('balCloseDate').value;
  const date = dateStr ? fmtDate(Math.floor(new Date(dateStr).getTime() / 1000)) : '___';
  const op = _balanceDir === 'below' ? '&le;' : '&ge;';
  el.innerHTML = `Will <b>${short}</b> hold ${op} <b>${threshold} ${asset}</b> by <b>${date}</b>?`;
  updateCreateDeeplink();
}

async function loadSupplyTokenInfo() {
  const addr = ($('supplyTokenAddr').value || '').trim();
  const hint = $('supplyTokenHint');
  if (!addr || addr.length < 42) { hint.textContent = ''; _supplyTokenData = { address: '', symbol: '', decimals: 18 }; return; }
  try {
    await withRPC(async rpc => {
      const token = new ethers.Contract(addr, ERC20_ABI, rpc);
      const [sym, dec, supply] = await Promise.all([token.symbol(), token.decimals(), token.totalSupply()]);
      _supplyTokenData = { address: addr, symbol: sym, decimals: Number(dec) };
      const fmtSupply = Number(ethers.formatUnits(supply, dec));
      hint.textContent = sym + ' | Current supply: ' + fmtSupply.toLocaleString();
      return true;
    });
  } catch { hint.textContent = 'Could not load token info'; }
  updateSupplyPreview();
}

function updateSupplyPreview() {
  const el = $('supplyPreview');
  if (!el) return;
  const sym = _supplyTokenData.symbol || 'token';
  const threshold = $('supplyThreshold').value || '___';
  const op = $('supplyOp').value;
  const verb = parseInt(op) >= 2 ? 'reach' : 'drop below';
  const dateStr = $('supplyCloseDate').value;
  const date = dateStr ? fmtDate(Math.floor(new Date(dateStr).getTime() / 1000)) : '___';
  el.innerHTML = `Will <b>${sym}</b> supply ${verb} <b>${Number(threshold).toLocaleString() || '___'}</b> by <b>${date}</b>?`;
  updateCreateDeeplink();
}

function updateLiqSplit() {
  const total = parseFloat($('totalLiquidity').value) || 0;
  document.querySelectorAll('.liq-preset').forEach(b => {
    b.classList.toggle('active', parseFloat(b.textContent) === total);
  });
  const el = $('totalCostDisplay');
  if (el) el.textContent = 'Total: ' + total.toFixed(4) + ' ETH';
  updateCreateDeeplink();
}

function setLiqPreset(val) {
  $('totalLiquidity').value = val;
  updateLiqSplit();
}

function isUserRejection(e) {
  return e.code === 'ACTION_REJECTED' || e.code === 4001 || /user rejected/i.test(e.message || '');
}

// Decode known custom error selectors into human-readable messages
const KNOWN_ERRORS = {
  '0x7c7f7bb9': 'Swap failed  try a smaller amount or increase slippage',
  '0xfb30d03a': 'Price impact too high  try a smaller amount or increase slippage',
  '0x7db1be50': 'Market not found',
  '0x8baa579f': 'Insufficient output  increase slippage tolerance',
  '0xfb8f41b2': 'Insufficient liquidity',
  '0x4e487b71': 'Arithmetic error',
  '0x1f2a2005': 'Deadline expired  please retry',
  '0xe450d38c': 'Insufficient balance',
  '0x59c896be': 'Insufficient balance for transfer',
  '0xbb2875c3': 'Insufficient output  increase slippage tolerance',
  '0xbb55fd27': 'Insufficient liquidity in pool',
  '0x1ab7da6b': 'Deadline expired  please retry',
  '0xba2a9fc2': 'Only the designated resolver can resolve this market',
  '0x55e8cb5f': 'Market is already resolved',
  '0x2e96c726': 'Market is not yet resolved  cannot claim',
  '0x82b42900': 'Unauthorized',
  '0x2c5211c6': 'Invalid amount',
  '0x8199f5f3': 'Slippage exceeded  increase slippage tolerance',
  '0x0b5f6bf0': 'Market is closed  no more trading',
  '0xa8a9eb69': 'Market is not closed yet',
};
function decodeError(e) {
  // Try to find error data in various ethers.js error structures
  const data = e.data || e.error?.data || e.info?.error?.data;
  if (data && typeof data === 'string' && data.startsWith('0x') && data.length >= 10) {
    const sel = data.slice(0, 10).toLowerCase();
    if (KNOWN_ERRORS[sel]) return KNOWN_ERRORS[sel];
  }
  // Check shortMessage for "unknown custom error" and try to extract selector
  const msg = e.shortMessage || e.message || '';
  const match = msg.match(/data="(0x[0-9a-f]{8,})"/i);
  if (match) {
    const sel = match[1].slice(0, 10).toLowerCase();
    if (KNOWN_ERRORS[sel]) return KNOWN_ERRORS[sel];
  }
  // Fallback to existing message
  return e.reason || e.shortMessage || e.message || 'Unknown error';
}

function parseMarketIdFromReceipt(receipt) {
  const sigs = [
    'MarketCreated(uint256,uint256,string,address,address,uint64,bool)',
    'MarketCreated(uint256,address,address)',
    'MarketCreated(uint256)'
  ];
  for (const log of receipt.logs) {
    try {
      for (const sig of sigs) {
        if (log.topics[0] === ethers.id(sig) && log.topics[1]) {
          return BigInt(log.topics[1]).toString();
        }
      }
    } catch {}
  }
  // Fallback: any log from PAMM
  for (const log of receipt.logs) {
    try {
      if (log.address.toLowerCase() === CONTRACTS.PAMM.toLowerCase() && log.topics[1]) {
        return BigInt(log.topics[1]).toString();
      }
    } catch {}
  }
  return null;
}

async function createMarket() {
  const s = await connectWallet();
  if (!s) return;

  const total = parseFloat($('totalLiquidity').value) || 0;
  if (total < 0.0001) { alert('Enter at least 0.0001 ETH liquidity'); return; }

  const collateralForLP = ethers.parseEther(total.toFixed(18));
  const deadline = Math.floor(Date.now() / 1000) + 3600;

  if (_currentMarketType === 'price') {
    await createPriceMarket(collateralForLP, deadline);
  } else if (_currentMarketType === 'balance') {
    await createBalanceMarket(collateralForLP, deadline);
  } else if (_currentMarketType === 'supply') {
    await createSupplyMarket(collateralForLP, deadline);
  } else if (_currentMarketType === 'custom') {
    await createCustomMarket(collateralForLP, deadline);
  }
}

async function createPriceMarket(collateralForLP, deadline) {
  const raw = ($('targetPrice').value || '').replace(/[^0-9]/g, '');
  const targetPrice = parseInt(raw);
  const closeDateStr = $('closeDate').value;
  if (!targetPrice || targetPrice < 1) { alert('Enter a valid target price'); return; }
  if (!closeDateStr) { alert('Select a close date'); return; }

  const closeTimestamp = Math.floor(new Date(closeDateStr).getTime() / 1000);
  if (closeTimestamp < Math.floor(Date.now() / 1000) + 3600) { alert('Close date must be at least 1 hour in the future'); return; }

  const threshold = BigInt(targetPrice) * BigInt(1e8); // Chainlink 8 decimals
  const opCode = _priceDir === 'down' ? OP.LTE : OP.GTE;
  const opNum = _priceDir === 'down' ? 2 : 3;
  const description = `PRICE|ETH|USD|${opNum}|${targetPrice}|${closeTimestamp}`;

  const btn = $('createBtn');
  btn.disabled = true; btn.textContent = 'Creating...';

  try {
    const bootstrapper = new ethers.Contract(CONTRACTS.BOOTSTRAPPER, BOOTSTRAPPER_ABI, _signer);
    const tx = await bootstrapper.bootstrapPriceMarket(
      description, ethers.ZeroAddress, closeTimestamp, CONTRACTS.PM_FEE_HOOK,
      collateralForLP, _connectedAddress, deadline,
      CONTRACTS.CHAINLINK_ETH_USD, opCode, threshold,
      { value: collateralForLP }
    );

    btn.innerHTML = `Confirming... <a href="https://etherscan.io/tx/${tx.hash}" target="_blank" rel="noopener" style="color:inherit;text-decoration:underline;font-size:11px">tx &#8599;</a>`;
    const receipt = await tx.wait();
    const marketId = parseMarketIdFromReceipt(receipt);
    closeCreateModal();
    alert('Market created!' + (marketId ? ' Navigating...' : ''));
    if (marketId) { location.hash = '#' + marketId; }
    else { renderGallery(); }
  } catch (e) {
    if (isUserRejection(e)) {
      // silently reset
    } else {
      console.error('Create market failed:', e);
      alert('Failed: ' + decodeError(e));
    }
    btn.disabled = false; btn.textContent = 'Create Market';
  }
}

async function createBalanceMarket(collateralForLP, deadline) {
  const walletAddr = getBalWalletAddress();
  const threshold = parseFloat($('balThreshold').value);
  const closeDateStr = $('balCloseDate').value;

  if (!walletAddr) { alert('Enter a valid wallet address (0x, name.wei, or name.eth)'); return; }
  if (!threshold || threshold <= 0) { alert('Enter a valid threshold'); return; }
  if (!closeDateStr) { alert('Select a close date'); return; }

  const closeTimestamp = Math.floor(new Date(closeDateStr).getTime() / 1000);
  if (closeTimestamp < Math.floor(Date.now() / 1000) + 3600) { alert('Close date must be at least 1 hour in the future'); return; }

  const btn = $('createBtn');
  btn.disabled = true; btn.textContent = 'Creating...';

  try {
    const bootstrapper = new ethers.Contract(CONTRACTS.BOOTSTRAPPER, BOOTSTRAPPER_ABI, _signer);
    let tx;

    const opCode = _balanceDir === 'below' ? OP.LTE : OP.GTE;
    const opNum = _balanceDir === 'below' ? 2 : 3;

    if (_balanceAssetType === 'eth') {
      const thresholdWei = ethers.parseEther(threshold.toString());
      const description = `ETHBAL|${walletAddr}|${opNum}|${threshold}|${closeTimestamp}`;
      tx = await bootstrapper.bootstrapETHBalanceMarket(
        description, ethers.ZeroAddress, closeTimestamp, CONTRACTS.PM_FEE_HOOK,
        collateralForLP, _connectedAddress, deadline, walletAddr, opCode, thresholdWei,
        { value: collateralForLP }
      );
    } else {
      const tokenAddr = _balTokenData.address || ($('balTokenAddr').value || '').trim();
      if (!tokenAddr || !ethers.isAddress(tokenAddr)) { alert('Enter a valid token address'); btn.disabled = false; btn.textContent = 'Create Market'; return; }
      const decimals = _balTokenData.decimals || 18;
      const thresholdUnits = ethers.parseUnits(threshold.toString(), decimals);
      const description = `TOKBAL|${tokenAddr}|${walletAddr}|${opNum}|${threshold}|${closeTimestamp}`;
      tx = await bootstrapper.bootstrapTokenBalanceMarket(
        description, ethers.ZeroAddress, closeTimestamp, CONTRACTS.PM_FEE_HOOK,
        collateralForLP, _connectedAddress, deadline, tokenAddr, walletAddr, opCode, thresholdUnits,
        { value: collateralForLP }
      );
    }

    btn.innerHTML = `Confirming... <a href="https://etherscan.io/tx/${tx.hash}" target="_blank" rel="noopener" style="color:inherit;text-decoration:underline;font-size:11px">tx &#8599;</a>`;
    const receipt = await tx.wait();
    const marketId = parseMarketIdFromReceipt(receipt);
    closeCreateModal();
    alert('Market created!');
    if (marketId) { location.hash = '#' + marketId; }
    else { renderGallery(); }
  } catch (e) {
    if (isUserRejection(e)) {
      // silently reset
    } else {
      console.error('Create market failed:', e);
      alert('Failed: ' + decodeError(e));
    }
    btn.disabled = false; btn.textContent = 'Create Market';
  }
}

async function createSupplyMarket(collateralForLP, deadline) {
  const tokenAddr = (_supplyTokenData.address || $('supplyTokenAddr').value || '').trim();
  const threshold = parseFloat($('supplyThreshold').value);
  const closeDateStr = $('supplyCloseDate').value;
  const op = parseInt($('supplyOp').value);

  if (!tokenAddr || !ethers.isAddress(tokenAddr)) { alert('Enter a valid token address'); return; }
  if (!threshold || threshold <= 0) { alert('Enter a valid threshold'); return; }
  if (!closeDateStr) { alert('Select a close date'); return; }

  const closeTimestamp = Math.floor(new Date(closeDateStr).getTime() / 1000);
  if (closeTimestamp < Math.floor(Date.now() / 1000) + 3600) { alert('Close date must be at least 1 hour in the future'); return; }

  const decimals = _supplyTokenData.decimals || 18;
  const sym = _supplyTokenData.symbol || 'TOKEN';
  const thresholdUnits = ethers.parseUnits(threshold.toString(), decimals);
  const description = `SUPPLY|${tokenAddr}|${op}|${threshold}|${closeTimestamp}`;

  // totalSupply() calldata
  const iface = new ethers.Interface(ERC20_ABI);
  const callData = iface.encodeFunctionData('totalSupply');

  const btn = $('createBtn');
  btn.disabled = true; btn.textContent = 'Creating...';

  try {
    const bootstrapper = new ethers.Contract(CONTRACTS.BOOTSTRAPPER, BOOTSTRAPPER_ABI, _signer);
    const tx = await bootstrapper.bootstrapWithCondition(
      description, ethers.ZeroAddress, closeTimestamp, true, CONTRACTS.PM_FEE_HOOK,
      collateralForLP, false, 0n, 0n, _connectedAddress, deadline,
      tokenAddr, callData, op, thresholdUnits,
      { value: collateralForLP }
    );

    btn.innerHTML = `Confirming... <a href="https://etherscan.io/tx/${tx.hash}" target="_blank" rel="noopener" style="color:inherit;text-decoration:underline;font-size:11px">tx &#8599;</a>`;
    const receipt = await tx.wait();
    const marketId = parseMarketIdFromReceipt(receipt);
    closeCreateModal();
    alert('Market created!');
    if (marketId) { location.hash = '#' + marketId; }
    else { renderGallery(); }
  } catch (e) {
    if (isUserRejection(e)) {
      // silently reset
    } else {
      console.error('Create market failed:', e);
      alert('Failed: ' + decodeError(e));
    }
    btn.disabled = false; btn.textContent = 'Create Market';
  }
}

// ==================== CUSTOM MARKET ====================

function updateCustomPreview() {
  const el = $('customPreview');
  if (!el) return;
  const q = ($('customQuestion').value || '').trim();
  const dateStr = $('customCloseDate').value;
  const date = dateStr ? fmtDate(Math.floor(new Date(dateStr).getTime() / 1000)) : '___';
  if (q) {
    el.innerHTML = `<b>${escText(q)}</b> (closes <b>${date}</b>)`;
  } else {
    el.innerHTML = 'Yes/No market with your own question and resolver';
  }
  updateCreateDeeplink();
}

// ---- Resolver name resolution ----
let _resolvedResolver = null;
let _resolverResolveSeq = 0;
let _resolverDebounce = null;

async function showResolverVerification(addr, el, prefix) {
  const seq = _resolverResolveSeq;
  const [verified, weiName, feeBps] = await Promise.all([checkResolverVerified(addr), reverseResolveWei(addr), getResolverFeeBps(addr)]);
  if (seq !== _resolverResolveSeq) return;
  let display = prefix || addr;
  if (!prefix && weiName) display = weiName + ' \u2192 ' + addr.slice(0, 6) + '...' + addr.slice(-4);
  el.innerHTML = display + (verified ? ' ' + VERIFIED_BADGE : '') + (feeBps > 0 ? ` <span style="opacity:0.6">(${(feeBps / 100).toFixed(2)}% resolver fee)</span>` : '');
}

function onResolverInput() {
  clearTimeout(_resolverDebounce);
  const v = ($('customResolver')?.value || '').trim();
  const el = $('customResolverResolved');
  _resolvedResolver = null;
  if (!v) { el.style.display = 'none'; return; }
  if (ethers.isAddress(v)) {
    _resolvedResolver = ethers.getAddress(v);
    ++_resolverResolveSeq;
    el.style.display = 'block';
    el.style.color = 'var(--fg-muted)';
    el.textContent = ethers.getAddress(v);
    showResolverVerification(ethers.getAddress(v), el);
    return;
  }
  if (v.endsWith('.wei') || v.endsWith('.eth')) {
    el.style.display = 'block';
    el.style.color = 'var(--fg-muted)';
    el.textContent = 'Resolving ' + v + '...';
    _resolverDebounce = setTimeout(() => resolveResolverName(v), 350);
  } else {
    el.style.display = 'block';
    el.style.color = 'var(--remove-fg, #c0392b)';
    el.textContent = 'Enter 0x address, name.wei, or name.eth';
  }
}

async function resolveResolverName(name) {
  const seq = ++_resolverResolveSeq;
  const el = $('customResolverResolved');
  try {
    let resolved = null;
    if (name.endsWith('.wei')) {
      resolved = await withRPC(async (rpc) => {
        const ns = new ethers.Contract(WEINS, WEINS_ABI, rpc);
        const tokenId = await ns.computeId(name);
        const owner = await ns.ownerOf(tokenId).catch(() => null);
        if (!owner || owner === ethers.ZeroAddress) return null;
        return ethers.getAddress(owner);
      });
    } else if (name.endsWith('.eth')) {
      resolved = await withRPC(async (rpc) => rpc.resolveName(name));
    }
    if (seq !== _resolverResolveSeq) return;
    if (resolved && resolved !== ethers.ZeroAddress) {
      _resolvedResolver = resolved;
      el.style.color = 'var(--fg-muted)';
      el.textContent = resolved;
      showResolverVerification(resolved, el, name + ' \u2192 ' + resolved.slice(0, 6) + '...' + resolved.slice(-4));
    } else {
      el.style.color = 'var(--remove-fg, #c0392b)';
      el.textContent = 'Name not found';
    }
  } catch {
    if (seq !== _resolverResolveSeq) return;
    el.style.color = 'var(--remove-fg, #c0392b)';
    el.textContent = 'Failed to resolve ' + name;
  }
}

document.addEventListener('DOMContentLoaded', () => {
  const ri = $('customResolver');
  if (ri) ri.addEventListener('input', onResolverInput);
});

// ---- Resolver fee registration ----
function updateResolverFeeSection() {
  const sec = $('resolverFeeSection');
  if (!sec) return;
  if (_connectedAddress) {
    sec.style.display = 'block';
    getResolverFeeBps(_connectedAddress).then(bps => {
      const lbl = $('resolverFeeCurrentLabel');
      if (lbl) lbl.textContent = bps > 0 ? `Your current fee: ${(bps / 100).toFixed(2)}%` : 'No fee set';
    });
  } else {
    sec.style.display = 'none';
  }
}

async function submitResolverFee() {
  if (!_signer) { alert('Connect wallet first'); return; }
  const input = $('walletResolverFeeInput') || $('resolverFeeInput');
  const pct = parseFloat(input?.value);
  if (isNaN(pct) || pct < 0 || pct > 10) { alert('Fee must be between 0% and 10%'); return; }
  const bps = Math.round(pct * 100);
  try {
    const pamm = new ethers.Contract(CONTRACTS.PAMM, PAMM_ABI, _signer);
    const tx = await pamm.setResolverFeeBps(bps);
    if (input) input.disabled = true;
    await tx.wait();
    const feeText = bps > 0 ? 'Current fee: ' + (bps / 100).toFixed(2) + '%' : 'No fee set';
    const lbl1 = $('walletResolverFeeLabel'); if (lbl1) lbl1.textContent = feeText;
    const lbl2 = $('resolverFeeCurrentLabel'); if (lbl2) lbl2.textContent = feeText;
  } catch (e) {
    if (!isUserRejection(e)) alert('Failed to set fee: ' + (e.shortMessage || e.message));
  }
}

// ---- Balance wallet name resolution ----
let _resolvedBalWallet = null;
let _balWalletResolveSeq = 0;
let _balWalletDebounce = null;

function onBalWalletInput() {
  clearTimeout(_balWalletDebounce);
  const v = ($('balWalletAddr')?.value || '').trim();
  const el = $('balWalletResolved');
  _resolvedBalWallet = null;
  if (!v) { el.style.display = 'none'; updateBalPreview(); updateCreateBtn(); return; }
  if (ethers.isAddress(v)) {
    _resolvedBalWallet = ethers.getAddress(v);
    el.style.display = 'block';
    el.style.color = 'var(--fg-muted)';
    el.textContent = ethers.getAddress(v);
    updateBalPreview(); updateCreateBtn();
    return;
  }
  if (v.endsWith('.wei') || v.endsWith('.eth')) {
    el.style.display = 'block';
    el.style.color = 'var(--fg-muted)';
    el.textContent = 'Resolving ' + v + '...';
    _balWalletDebounce = setTimeout(() => resolveBalWalletName(v), 350);
  } else {
    el.style.display = 'block';
    el.style.color = 'var(--remove-fg, #c0392b)';
    el.textContent = 'Enter 0x address, name.wei, or name.eth';
  }
  updateBalPreview(); updateCreateBtn();
}

async function resolveBalWalletName(name) {
  const seq = ++_balWalletResolveSeq;
  const el = $('balWalletResolved');
  try {
    let resolved = null;
    if (name.endsWith('.wei')) {
      resolved = await withRPC(async (rpc) => {
        const ns = new ethers.Contract(WEINS, WEINS_ABI, rpc);
        const tokenId = await ns.computeId(name);
        const owner = await ns.ownerOf(tokenId).catch(() => null);
        if (!owner || owner === ethers.ZeroAddress) return null;
        return ethers.getAddress(owner);
      });
    } else if (name.endsWith('.eth')) {
      resolved = await withRPC(async (rpc) => rpc.resolveName(name));
    }
    if (seq !== _balWalletResolveSeq) return;
    if (resolved && resolved !== ethers.ZeroAddress) {
      _resolvedBalWallet = resolved;
      el.style.color = 'var(--fg-muted)';
      el.textContent = resolved;
    } else {
      el.style.color = 'var(--remove-fg, #c0392b)';
      el.textContent = 'Name not found';
    }
  } catch {
    if (seq !== _balWalletResolveSeq) return;
    el.style.color = 'var(--remove-fg, #c0392b)';
    el.textContent = 'Failed to resolve ' + name;
  }
  updateBalPreview(); updateCreateBtn();
}

function getBalWalletAddress() {
  const v = ($('balWalletAddr')?.value || '').trim();
  if (ethers.isAddress(v)) return ethers.getAddress(v);
  if (_resolvedBalWallet) return _resolvedBalWallet;
  return null;
}

function getResolverAddress() {
  const v = ($('customResolver')?.value || '').trim();
  if (ethers.isAddress(v)) return ethers.getAddress(v);
  if (_resolvedResolver) return _resolvedResolver;
  return null;
}

async function createCustomMarket(collateralForLP, deadline) {
  const question = ($('customQuestion').value || '').trim();
  const resolverAddr = getResolverAddress();
  const canClose = $('customCanClose').checked;
  const closeDateStr = $('customCloseDate').value;

  if (!question) { alert('Enter a question'); return; }
  if (!resolverAddr) { alert('Enter a valid resolver address (0x, name.wei, or name.eth)'); return; }
  if (!closeDateStr) { alert('Select a close date'); return; }

  const closeTimestamp = Math.floor(new Date(closeDateStr).getTime() / 1000);
  if (closeTimestamp < Math.floor(Date.now() / 1000) + 3600) { alert('Close date must be at least 1 hour in the future'); return; }

  const description = question;

  const btn = $('createBtn');
  btn.disabled = true; btn.textContent = 'Creating...';

  try {
    const bootstrapper = new ethers.Contract(CONTRACTS.BOOTSTRAPPER, BOOTSTRAPPER_ABI, _signer);
    const tx = await bootstrapper.bootstrapMarket(
      description, resolverAddr, ethers.ZeroAddress, closeTimestamp, canClose, CONTRACTS.PM_FEE_HOOK,
      collateralForLP, false, 0n, 0n, _connectedAddress, deadline,
      { value: collateralForLP }
    );

    btn.innerHTML = `Confirming... <a href="https://etherscan.io/tx/${tx.hash}" target="_blank" rel="noopener" style="color:inherit;text-decoration:underline;font-size:11px">tx &#8599;</a>`;
    const receipt = await tx.wait();
    const marketId = parseMarketIdFromReceipt(receipt);
    closeCreateModal();
    alert('Market created!' + (marketId ? ' Navigating...' : ''));
    if (marketId) { location.hash = '#' + marketId; }
    else { renderGallery(); }
  } catch (e) {
    if (isUserRejection(e)) {
      // silently reset
    } else {
      console.error('Create market failed:', e);
      alert('Failed: ' + decodeError(e));
    }
    btn.disabled = false; btn.textContent = 'Create Market';
  }
}

// ==================== LP MODAL ====================

function openLPModal(marketId) {
  const m = markets.find(x => x.marketId === marketId);
  $('lpMarketName').innerHTML = m ? m.question : 'Market #' + marketId.slice(0, 8) + '...';
  const collateral = $('app').dataset.collateral;
  const isETH = !collateral || collateral === ethers.ZeroAddress;
  $('lpAmountLabel').textContent = 'Amount (' + (isETH ? 'ETH' : getCollateralSymbol(collateral)) + ')';
  const isLabeled = $('app').dataset.isLabeled === '1';
  $('lpModal').classList.add('active');
  $('lpModal').dataset.marketId = marketId;
  $('lpModal').dataset.isLabeled = isLabeled ? '1' : '0';
}

function closeLPModal() {
  $('lpModal').classList.remove('active');
}

async function provideLiquidity() {
  const s = await connectWallet();
  if (!s) return;

  const marketId = $('lpModal').dataset.marketId;
  const amount = parseFloat($('lpAmount').value) || 0;
  if (!marketId || amount <= 0) { alert('Enter an amount'); return; }

  const amountWei = ethers.parseEther(amount.toString());
  const btn = $('lpBtn');
  btn.disabled = true; btn.textContent = 'Providing...';
  const isLabeled = $('lpModal').dataset.isLabeled === '1';
  const collateral = $('app').dataset.collateral;
  const isETH = !collateral || collateral === ethers.ZeroAddress;

  try {
    const deadline = BigInt(Math.floor(Date.now() / 1000) + 1200);
    const pamm = new ethers.Contract(CONTRACTS.PAMM, PAMM_ABI, _signer);
    const feeOrHook = isLabeled
      ? (BigInt(CONTRACTS.PM_FEE_HOOK) | FLAG_BEFORE | FLAG_AFTER)
      : BigInt(LEGACY_FEE_BPS);

    if (!isETH) {
      const token = new ethers.Contract(collateral, ERC20_ABI, _signer);
      const allowance = await token.allowance(_connectedAddress, CONTRACTS.PAMM);
      if (allowance < amountWei) {
        btn.textContent = 'Approve in wallet...';
        const approveTx = await token.approve(CONTRACTS.PAMM, ethers.MaxUint256);
        await approveTx.wait();
      }
    }

    btn.textContent = 'Confirm in wallet...';
    const tx = await pamm.splitAndAddLiquidity(
      BigInt(marketId), amountWei, feeOrHook, 0, 0, 0, _connectedAddress, deadline,
      isETH ? { value: amountWei } : {}
    );
    btn.innerHTML = `Pending... <a href="https://etherscan.io/tx/${tx.hash}" target="_blank" rel="noopener" style="color:inherit;text-decoration:underline;font-size:11px">tx &#8599;</a>`;
    await tx.wait();

    closeLPModal();
    alert('Liquidity provided!');
    renderMarketPage(marketId);
  } catch (e) {
    if (!isUserRejection(e)) {
      console.error('LP failed:', e);
      btn.textContent = 'Failed';
      alert('Failed: ' + decodeError(e));
    }
  } finally {
    setTimeout(() => { btn.disabled = false; btn.textContent = 'Provide Liquidity'; }, 2000);
  }
}

// ==================== VAULT MAINTENANCE ====================

async function updateTWAP(marketId) {
  const s = await connectWallet();
  if (!s) return;
  const btn = $('twapBtn');
  btn.disabled = true;
  btn.textContent = 'Confirm...';
  try {
    const hookRouter = new ethers.Contract(CONTRACTS.PM_HOOK_ROUTER, PM_HOOK_ROUTER_ABI, s);
    const tx = await hookRouter.updateTWAPObservation(marketId);
    btn.innerHTML = `Pending... <a href="https://etherscan.io/tx/${tx.hash}" target="_blank" rel="noopener" style="color:inherit;text-decoration:underline;font-size:11px">tx &#8599;</a>`;
    await tx.wait();
    alert('TWAP updated!');
    renderMarketPage(marketId);
  } catch (e) {
    if (!isUserRejection(e)) {
      console.error('TWAP update failed:', e);
      alert('TWAP update failed: ' + decodeError(e));
    }
    btn.disabled = false;
    btn.textContent = 'Update TWAP';
  }
}

async function rebalanceVault(marketId) {
  const s = await connectWallet();
  if (!s) return;
  const btn = $('rebalanceBtn');
  btn.disabled = true;
  btn.textContent = 'Confirm...';
  try {
    const hookRouter = new ethers.Contract(CONTRACTS.PM_HOOK_ROUTER, PM_HOOK_ROUTER_ABI, s);
    const deadline = Math.floor(Date.now() / 1000) + 3600;
    const tx = await hookRouter.rebalanceBootstrapVault(marketId, deadline);
    btn.innerHTML = `Pending... <a href="https://etherscan.io/tx/${tx.hash}" target="_blank" rel="noopener" style="color:inherit;text-decoration:underline;font-size:11px">tx &#8599;</a>`;
    await tx.wait();
    alert('Vault rebalanced!');
    renderMarketPage(marketId);
  } catch (e) {
    if (!isUserRejection(e)) {
      console.error('Rebalance failed:', e);
      alert('Rebalance failed: ' + decodeError(e));
    }
    btn.disabled = false;
    btn.textContent = 'Rebalance';
  }
}

async function settleBudget(marketId) {
  const s = await connectWallet();
  if (!s) return;
  const btn = $('settleBudgetBtn');
  btn.disabled = true;
  btn.textContent = 'Confirm...';
  try {
    const hookRouter = new ethers.Contract(CONTRACTS.PM_HOOK_ROUTER, PM_HOOK_ROUTER_ABI, s);
    const tx = await hookRouter.settleRebalanceBudget(marketId);
    btn.innerHTML = `Pending... <a href="https://etherscan.io/tx/${tx.hash}" target="_blank" rel="noopener" style="color:inherit;text-decoration:underline;font-size:11px">tx &#8599;</a>`;
    await tx.wait();
    alert('Budget settled!');
    renderMarketPage(marketId);
  } catch (e) {
    if (!isUserRejection(e)) {
      console.error('Settle budget failed:', e);
      alert('Settle budget failed: ' + decodeError(e));
    }
    btn.disabled = false;
    btn.textContent = 'Settle';
  }
}

async function harvestFees(marketId, isYes) {
  const s = await connectWallet();
  if (!s) return;
  const btn = $(isYes ? 'harvestYesVaultBtn' : 'harvestNoVaultBtn');
  btn.disabled = true;
  btn.textContent = '...';
  try {
    const hookRouter = new ethers.Contract(CONTRACTS.PM_HOOK_ROUTER, PM_HOOK_ROUTER_ABI, s);
    const tx = await hookRouter.harvestVaultFees(marketId, isYes);
    btn.innerHTML = `Pending... <a href="https://etherscan.io/tx/${tx.hash}" target="_blank" rel="noopener" style="color:inherit;text-decoration:underline;font-size:11px">tx &#8599;</a>`;
    await tx.wait();
    alert('Fees harvested!');
    renderMarketPage(marketId);
  } catch (e) {
    if (!isUserRejection(e)) {
      console.error('Harvest fees failed:', e);
      alert('Harvest failed: ' + decodeError(e));
    }
    btn.disabled = false;
    btn.textContent = 'HARVEST';
  }
}

async function finalizeMarket(marketId) {
  const s = await connectWallet();
  if (!s) return;
  const btn = $('finalizeBtn');
  btn.disabled = true;
  btn.textContent = 'Confirm...';
  try {
    const hookRouter = new ethers.Contract(CONTRACTS.PM_HOOK_ROUTER, PM_HOOK_ROUTER_ABI, s);
    const tx = await hookRouter.finalizeMarket(marketId);
    btn.innerHTML = `Pending... <a href="https://etherscan.io/tx/${tx.hash}" target="_blank" rel="noopener" style="color:inherit;text-decoration:underline;font-size:11px">tx &#8599;</a>`;
    await tx.wait();
    alert('Market finalized!');
    renderMarketPage(marketId);
  } catch (e) {
    if (!isUserRejection(e)) {
      console.error('Finalize failed:', e);
      alert('Finalize failed: ' + decodeError(e));
    }
    btn.disabled = false;
    btn.textContent = 'Finalize';
  }
}

// ==================== WITHDRAW LP ====================

async function withdrawVault(isYes) {
  const s = await connectWallet();
  if (!s) return;
  const marketId = $('app').dataset.marketId;
  if (!marketId) return;
  const vaultShares = BigInt($('app').dataset[isYes ? 'userYesVaultLP' : 'userNoVaultLP'] || '0');
  if (vaultShares <= 0n) { alert(`No ${isYes ? 'YES' : 'NO'} vault shares to withdraw`); return; }

  const btn = $(isYes ? 'withdrawYesVaultBtn' : 'withdrawNoVaultBtn');
  btn.disabled = true;
  btn.textContent = '...';

  try {
    const hookRouter = new ethers.Contract(CONTRACTS.PM_HOOK_ROUTER, PM_HOOK_ROUTER_ABI, s);
    const deadline = Math.floor(Date.now() / 1000) + 3600;
    const tx = await hookRouter.withdrawFromVault(marketId, isYes, vaultShares, _connectedAddress, deadline);
    btn.textContent = 'Pending...';
    await tx.wait();
    renderMarketPage(marketId);
  } catch (e) {
    if (!isUserRejection(e)) {
      console.error('Withdraw vault failed:', e);
      alert('Withdraw failed: ' + decodeError(e));
    }
    btn.disabled = false;
    btn.textContent = 'WITHDRAW';
  }
}

async function withdrawAmmLP(pct) {
  const s = await connectWallet();
  if (!s) return;
  const marketId = $('app').dataset.marketId;
  if (!marketId) return;
  const totalLP = BigInt($('app').dataset.userAmmLP || '0');
  if (totalLP <= 0n) { alert('No AMM LP to withdraw'); return; }

  const withdrawAmt = pct ? totalLP * BigInt(pct) / 100n : totalLP;
  if (withdrawAmt <= 0n) return;

  const btn = $('withdrawAmmBtn');
  if (btn) { btn.disabled = true; btn.textContent = '...'; }

  try {
    const zamm = new ethers.Contract(CONTRACTS.ZAMM, ZAMM_ABI, s);
    const isOp = await zamm.isOperator(_connectedAddress, CONTRACTS.PAMM);
    if (!isOp) {
      if (btn) btn.textContent = 'Approve...';
      const approveTx = await zamm.setOperator(CONTRACTS.PAMM, true);
      await approveTx.wait();
    }

    const isLabeled = $('app').dataset.isLabeled === '1';
    const feeOrHook = isLabeled
      ? (BigInt(CONTRACTS.PM_FEE_HOOK) | FLAG_BEFORE | FLAG_AFTER)
      : BigInt(LEGACY_FEE_BPS);
    const deadline = Math.floor(Date.now() / 1000) + 3600;

    if (btn) btn.textContent = 'Confirm...';
    const pamm = new ethers.Contract(CONTRACTS.PAMM, PAMM_ABI, s);
    const tx = await pamm.removeLiquidityToCollateral(marketId, feeOrHook, withdrawAmt, 0, 0, 0, _connectedAddress, deadline);
    if (btn) btn.innerHTML = `Pending... <a href="https://etherscan.io/tx/${tx.hash}" target="_blank" rel="noopener" style="color:inherit;text-decoration:underline;font-size:11px">tx &#8599;</a>`;
    await tx.wait();
    renderMarketPage(marketId);
  } catch (e) {
    if (!isUserRejection(e)) {
      console.error('Withdraw AMM LP failed:', e);
      alert('Withdraw failed: ' + decodeError(e));
    }
    if (btn) { btn.disabled = false; btn.textContent = 'WITHDRAW'; }
  }
}

// ==================== INIT ====================

tryAutoConnect().then(() => route());
</script>
</body>
</html>
